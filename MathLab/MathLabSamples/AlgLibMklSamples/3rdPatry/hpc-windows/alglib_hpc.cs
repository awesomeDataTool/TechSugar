/**************************************************************************
ALGLIB 3.10.0 (source code generated 2015-08-19)
Copyright (c) Sergey Bochkanov (ALGLIB project).

>>> SOURCE LICENSE >>>
This software is a private code owned by ALGLIB Project.  If  you  somehow
received it without explicit written approval of ALGLIB Project,  then you
CAN NOT use it and  should  immediately  delete  all  files  bearing  this
notice.

If you did receive it from ALGLIB Project, then:
* you may NOT modify it without explicit written consent of ALGLIB Project.
* you may NOT distribute it to  other  parties  without  explicit  written
  consent of ALGLIB Project.
* you may NOT  include  it  into  your  application  and  distribute  such
  applications without explicit written consent of ALGLIB Project.

In all circumstances:
* you may NOT use, copy or distribute it except as explicitly approved  by
  ALGLIB Project.
* you may NOT rent or lease it to any third party.
* you may NOT remove any copyright notice from the software.
* you may NOT disable/remove code which checks  for  presence  of  license
  keys (if such code is included in software).

$NON-GPL$
>>> END OF LICENSE >>>
**************************************************************************/
using System;
using System.Reflection;
using System.Runtime.InteropServices;
public partial class alglib
{
    /********************************************************************
    Callback definitions for optimizers/fitters/solvers.
    
    Callbacks for unparameterized (general) functions:
    * ndimensional_func         calculates f(arg), stores result to func
    * ndimensional_grad         calculates func = f(arg), 
                                grad[i] = df(arg)/d(arg[i])
    * ndimensional_hess         calculates func = f(arg),
                                grad[i] = df(arg)/d(arg[i]),
                                hess[i,j] = d2f(arg)/(d(arg[i])*d(arg[j]))
    
    Callbacks for systems of functions:
    * ndimensional_fvec         calculates vector function f(arg),
                                stores result to fi
    * ndimensional_jac          calculates f[i] = fi(arg)
                                jac[i,j] = df[i](arg)/d(arg[j])
                                
    Callbacks for  parameterized  functions,  i.e.  for  functions  which 
    depend on two vectors: P and Q.  Gradient  and Hessian are calculated 
    with respect to P only.
    * ndimensional_pfunc        calculates f(p,q),
                                stores result to func
    * ndimensional_pgrad        calculates func = f(p,q),
                                grad[i] = df(p,q)/d(p[i])
    * ndimensional_phess        calculates func = f(p,q),
                                grad[i] = df(p,q)/d(p[i]),
                                hess[i,j] = d2f(p,q)/(d(p[i])*d(p[j]))

    Callbacks for progress reports:
    * ndimensional_rep          reports current position of optimization algo    
    
    Callbacks for ODE solvers:
    * ndimensional_ode_rp       calculates dy/dx for given y[] and x
    
    Callbacks for integrators:
    * integrator1_func          calculates f(x) for given x
                                (additional parameters xminusa and bminusx
                                contain x-a and b-x)
    ********************************************************************/
    public delegate void ndimensional_func (double[] arg, ref double func, object obj);
    public delegate void ndimensional_grad (double[] arg, ref double func, double[] grad, object obj);
    public delegate void ndimensional_hess (double[] arg, ref double func, double[] grad, double[,] hess, object obj);
    
    public delegate void ndimensional_fvec (double[] arg, double[] fi, object obj);
    public delegate void ndimensional_jac  (double[] arg, double[] fi, double[,] jac, object obj);
    
    public delegate void ndimensional_pfunc(double[] p, double[] q, ref double func, object obj);
    public delegate void ndimensional_pgrad(double[] p, double[] q, ref double func, double[] grad, object obj);
    public delegate void ndimensional_phess(double[] p, double[] q, ref double func, double[] grad, double[,] hess, object obj);
    
    public delegate void ndimensional_rep(double[] arg, double func, object obj);

    public delegate void ndimensional_ode_rp (double[] y, double x, double[] dy, object obj);

    public delegate void integrator1_func (double x, double xminusa, double bminusx, ref double f, object obj);

    /********************************************************************
    Class defining a complex number with double precision.
    ********************************************************************/
    [StructLayout(LayoutKind.Sequential, Pack=8)]
    public struct complex
    {
        public double x;
        public double y;

        public complex(double _x)
        {
            x = _x;
            y = 0;
        }
        public complex(double _x, double _y)
        {
            x = _x;
            y = _y;
        }
        public static implicit operator complex(double _x)
        {
            return new complex(_x);
        }
        public static bool operator==(complex lhs, complex rhs)
        {
            return ((double)lhs.x==(double)rhs.x) & ((double)lhs.y==(double)rhs.y);
        }
        public static bool operator!=(complex lhs, complex rhs)
        {
            return ((double)lhs.x!=(double)rhs.x) | ((double)lhs.y!=(double)rhs.y);
        }
        public static complex operator+(complex lhs)
        {
            return lhs;
        }
        public static complex operator-(complex lhs)
        {
            return new complex(-lhs.x,-lhs.y);
        }
        public static complex operator+(complex lhs, complex rhs)
        {
            return new complex(lhs.x+rhs.x,lhs.y+rhs.y);
        }
        public static complex operator-(complex lhs, complex rhs)
        {
            return new complex(lhs.x-rhs.x,lhs.y-rhs.y);
        }
        public static complex operator*(complex lhs, complex rhs)
        { 
            return new complex(lhs.x*rhs.x-lhs.y*rhs.y, lhs.x*rhs.y+lhs.y*rhs.x);
        }
        public static complex operator/(complex lhs, complex rhs)
        {
            complex result;
            double e;
            double f;
            if( System.Math.Abs(rhs.y)<System.Math.Abs(rhs.x) )
            {
                e = rhs.y/rhs.x;
                f = rhs.x+rhs.y*e;
                result.x = (lhs.x+lhs.y*e)/f;
                result.y = (lhs.y-lhs.x*e)/f;
            }
            else
            {
                e = rhs.x/rhs.y;
                f = rhs.y+rhs.x*e;
                result.x = (lhs.y+lhs.x*e)/f;
                result.y = (-lhs.x+lhs.y*e)/f;
            }
            return result;
        }
        public override int GetHashCode() 
        { 
            return x.GetHashCode() ^ y.GetHashCode(); 
        }
        public override bool Equals(object obj) 
        { 
            if( obj is byte)
                return Equals(new complex((byte)obj));
            if( obj is sbyte)
                return Equals(new complex((sbyte)obj));
            if( obj is short)
                return Equals(new complex((short)obj));
            if( obj is ushort)
                return Equals(new complex((ushort)obj));
            if( obj is int)
                return Equals(new complex((int)obj));
            if( obj is uint)
                return Equals(new complex((uint)obj));
            if( obj is long)
                return Equals(new complex((long)obj));
            if( obj is ulong)
                return Equals(new complex((ulong)obj));
            if( obj is float)
                return Equals(new complex((float)obj));
            if( obj is double)
                return Equals(new complex((double)obj));
            if( obj is decimal)
                return Equals(new complex((double)(decimal)obj));
            return base.Equals(obj); 
        }    
    }    
    
    /********************************************************************
    Class defining an ALGLIB exception
    ********************************************************************/
    public class alglibexception : System.Exception
    {
        public string msg;
        public alglibexception(string s)
        {
            msg = s;
        }
        
    }
    
    /********************************************************************
    Critical failure, resilts in immediate termination of entire program.
    ********************************************************************/
    public static void AE_CRITICAL_ASSERT(bool x)
    {
        if( !x )
            System.Environment.FailFast("ALGLIB: critical error");
    }
    
    /********************************************************************
    ALGLIB object, parent class for all user-visible objects  managed  by
    ALGLIB.
    
    Methods:
        _deallocate()       deallocation:
                            * in managed ALGLIB it does nothing
                            * in native ALGLIB it clears  dynamic  memory
                              being  hold  by  object  and  sets internal
                              reference to null.
        make_copy()         creates deep copy of the object.
                            Works in both managed and native versions  of
                            ALGLIB.
    ********************************************************************/
    public abstract class alglibobject
    {
        public virtual void _deallocate() {}
        public abstract alglibobject make_copy();
    }
    
    /********************************************************************
    Deallocation of ALGLIB object:
    * in managed ALGLIB this method just sets refence to null
    * in native ALGLIB call of this method:
      1) clears dynamic memory being hold by  object  and  sets  internal
         reference to null.
      2) sets to null variable being passed to this method
      
    IMPORTANT (1): in  native  edition  of  ALGLIB,  obj becomes unusable
                   after this call!!!  It  is  possible  to  save  a copy
                   of reference in another variable (original variable is
                   set to null), but any attempt to work with this object
                   will crash your program.
    
    IMPORTANT (2): memory ownen by object will be recycled by GC  in  any
                   case. This method just enforced IMMEDIATE deallocation.
    ********************************************************************/
    public static void deallocateimmediately<T>(ref T obj) where T : alglib.alglibobject
    {
        obj._deallocate();
        obj = null;
    }
    
    /********************************************************************
    Allocation counter:
    * in managed ALGLIB it always returns 0 (dummy code)
    * in native ALGLIB it returns current value of the allocation counter
      (if it was activated)
    ********************************************************************/
    public static long alloc_counter()
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        return x_alloc_counter();
    }
    
    /********************************************************************
    Activization of the allocation counter:
    * in managed ALGLIB it does nothing (dummy code)
    * in native ALGLIB it turns on allocation counting.
    ********************************************************************/
    public static void alloc_counter_activate()
    {
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_alloc_counter_activate();
    }
    
    /********************************************************************
    internal functions
    ********************************************************************/
    public class ap
    {
        public static int len<T>(T[] a)
        { return a.Length; }
        public static int rows<T>(T[,] a)
        { return a.GetLength(0); }
        public static int cols<T>(T[,] a)
        { return a.GetLength(1); }
        public static void swap<T>(ref T a, ref T b)
        {
            T t = a;
            a = b;
            b = t;
        }
        
        public static void assert(bool cond, string s)
        {
            if( !cond )
                throw new alglibexception(s);
        }
        
        public static void assert(bool cond)
        {
            assert(cond, "ALGLIB: assertion failed");
        }
        
        /****************************************************************
        prints formatted complex
        ****************************************************************/
        public static string format(complex a, int _dps)
        {
            int dps = Math.Abs(_dps);
            string fmt = _dps>=0 ? "F" : "E";
            string fmtx = String.Format("{{0:"+fmt+"{0}}}", dps);
            string fmty = String.Format("{{0:"+fmt+"{0}}}", dps);
            string result = String.Format(fmtx, a.x) + (a.y >= 0 ? "+" : "-") + String.Format(fmty, Math.Abs(a.y)) + "i";
            result = result.Replace(',', '.');
            return result;
        }

        /****************************************************************
        prints formatted array
        ****************************************************************/
        public static string format(bool[] a)
        {
            string[] result = new string[len(a)];
            int i;
            for(i=0; i<len(a); i++)
                if( a[i] )
                    result[i] = "true";
                else
                    result[i] = "false";
            return "{"+String.Join(",",result)+"}";
        }
        
        /****************************************************************
        prints formatted array
        ****************************************************************/
        public static string format(int[] a)
        {
            string[] result = new string[len(a)];
            int i;
            for (i = 0; i < len(a); i++)
                result[i] = a[i].ToString();
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted array
        ****************************************************************/
        public static string format(double[] a, int _dps)
        {
            int dps = Math.Abs(_dps);
            string sfmt = _dps >= 0 ? "F" : "E";
            string fmt = String.Format("{{0:" + sfmt + "{0}}}", dps);
            string[] result = new string[len(a)];
            int i;
            for (i = 0; i < len(a); i++)
            {
                result[i] = String.Format(fmt, a[i]);
                result[i] = result[i].Replace(',', '.');
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted array
        ****************************************************************/
        public static string format(complex[] a, int _dps)
        {
            int dps = Math.Abs(_dps);
            string fmt = _dps >= 0 ? "F" : "E";
            string fmtx = String.Format("{{0:"+fmt+"{0}}}", dps);
            string fmty = String.Format("{{0:"+fmt+"{0}}}", dps);
            string[] result = new string[len(a)];
            int i;
            for (i = 0; i < len(a); i++)
            {
                result[i] = String.Format(fmtx, a[i].x) + (a[i].y >= 0 ? "+" : "-") + String.Format(fmty, Math.Abs(a[i].y)) + "i";
                result[i] = result[i].Replace(',', '.');
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted matrix
        ****************************************************************/
        public static string format(bool[,] a)
        {
            int i, j, m, n;
            n = cols(a);
            m = rows(a);
            bool[] line = new bool[n];
            string[] result = new string[m];
            for (i = 0; i < m; i++)
            {
                for (j = 0; j < n; j++)
                    line[j] = a[i, j];
                result[i] = format(line);
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted matrix
        ****************************************************************/
        public static string format(int[,] a)
        {
            int i, j, m, n;
            n = cols(a);
            m = rows(a);
            int[] line = new int[n];
            string[] result = new string[m];
            for (i = 0; i < m; i++)
            {
                for (j = 0; j < n; j++)
                    line[j] = a[i, j];
                result[i] = format(line);
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted matrix
        ****************************************************************/
        public static string format(double[,] a, int dps)
        {
            int i, j, m, n;
            n = cols(a);
            m = rows(a);
            double[] line = new double[n];
            string[] result = new string[m];
            for (i = 0; i < m; i++)
            {
                for (j = 0; j < n; j++)
                    line[j] = a[i, j];
                result[i] = format(line, dps);
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        prints formatted matrix
        ****************************************************************/
        public static string format(complex[,] a, int dps)
        {
            int i, j, m, n;
            n = cols(a);
            m = rows(a);
            complex[] line = new complex[n];
            string[] result = new string[m];
            for (i = 0; i < m; i++)
            {
                for (j = 0; j < n; j++)
                    line[j] = a[i, j];
                result[i] = format(line, dps);
            }
            return "{" + String.Join(",", result) + "}";
        }

        /****************************************************************
        checks that matrix is symmetric.
        max|A-A^T| is calculated; if it is within 1.0E-14 of max|A|,
        matrix is considered symmetric
        ****************************************************************/
        public static bool issymmetric(double[,] a)
        {
            int i, j, n;
            double err, mx, v1, v2;
            if( rows(a)!=cols(a) )
                return false;
            n = rows(a);
            if( n==0 )
                return true;
            mx = 0;
            err = 0;
            for( i=0; i<n; i++)
            {
                for(j=i+1; j<n; j++)
                {
                    v1 = a[i,j];
                    v2 = a[j,i];
                    if( !math.isfinite(v1) )
                        return false;
                    if( !math.isfinite(v2) )
                        return false;
                    err = Math.Max(err, Math.Abs(v1-v2));
                    mx  = Math.Max(mx,  Math.Abs(v1));
                    mx  = Math.Max(mx,  Math.Abs(v2));
                }
                v1 = a[i,i];
                if( !math.isfinite(v1) )
                    return false;
                mx = Math.Max(mx, Math.Abs(v1));
            }
            if( mx==0 )
                return true;
            return err/mx<=1.0E-14;
        }
        
        /****************************************************************
        checks that matrix is Hermitian.
        max|A-A^H| is calculated; if it is within 1.0E-14 of max|A|,
        matrix is considered Hermitian
        ****************************************************************/
        public static bool ishermitian(complex[,] a)
        {
            int i, j, n;
            double err, mx;
            complex v1, v2, vt;
            if( rows(a)!=cols(a) )
                return false;
            n = rows(a);
            if( n==0 )
                return true;
            mx = 0;
            err = 0;
            for( i=0; i<n; i++)
            {
                for(j=i+1; j<n; j++)
                {
                    v1 = a[i,j];
                    v2 = a[j,i];
                    if( !math.isfinite(v1.x) )
                        return false;
                    if( !math.isfinite(v1.y) )
                        return false;
                    if( !math.isfinite(v2.x) )
                        return false;
                    if( !math.isfinite(v2.y) )
                        return false;
                    vt.x = v1.x-v2.x;
                    vt.y = v1.y+v2.y;
                    err = Math.Max(err, math.abscomplex(vt));
                    mx  = Math.Max(mx,  math.abscomplex(v1));
                    mx  = Math.Max(mx,  math.abscomplex(v2));
                }
                v1 = a[i,i];
                if( !math.isfinite(v1.x) )
                    return false;
                if( !math.isfinite(v1.y) )
                    return false;
                err = Math.Max(err, Math.Abs(v1.y));
                mx = Math.Max(mx, math.abscomplex(v1));
            }
            if( mx==0 )
                return true;
            return err/mx<=1.0E-14;
        }
        
        
        /****************************************************************
        Forces symmetricity by copying upper half of A to the lower one
        ****************************************************************/
        public static bool forcesymmetric(double[,] a)
        {
            int i, j, n;
            if( rows(a)!=cols(a) )
                return false;
            n = rows(a);
            if( n==0 )
                return true;
            for( i=0; i<n; i++)
                for(j=i+1; j<n; j++)
                    a[i,j] = a[j,i];
            return true;
        }
        
        /****************************************************************
        Forces Hermiticity by copying upper half of A to the lower one
        ****************************************************************/
        public static bool forcehermitian(complex[,] a)
        {
            int i, j, n;
            complex v;
            if( rows(a)!=cols(a) )
                return false;
            n = rows(a);
            if( n==0 )
                return true;
            for( i=0; i<n; i++)
                for(j=i+1; j<n; j++)
                {
                    v = a[j,i];
                    a[i,j].x = v.x;
                    a[i,j].y = -v.y;
                }
            return true;
        }
    };
    
    /********************************************************************
    math functions
    ********************************************************************/
    public class math
    {
        public static System.Random rndobject = new System.Random(System.DateTime.Now.Millisecond + 1000*System.DateTime.Now.Second + 60*1000*System.DateTime.Now.Minute);

        public const double machineepsilon = 5E-16;
        public const double maxrealnumber = 1E300;
        public const double minrealnumber = 1E-300;
        
        public static bool isfinite(double d)
        {
            return !System.Double.IsNaN(d) && !System.Double.IsInfinity(d);
        }
        
        public static double randomreal()
        {
            double r = 0;
            lock(rndobject){ r = rndobject.NextDouble(); }
            return r;
        }
        public static int randominteger(int N)
        {
            int r = 0;
            lock(rndobject){ r = rndobject.Next(N); }
            return r;
        }
        public static double sqr(double X)
        {
            return X*X;
        }        
        public static double abscomplex(complex z)
        {
            double w;
            double xabs;
            double yabs;
            double v;
    
            xabs = System.Math.Abs(z.x);
            yabs = System.Math.Abs(z.y);
            w = xabs>yabs ? xabs : yabs;
            v = xabs<yabs ? xabs : yabs; 
            if( v==0 )
                return w;
            else
            {
                double t = v/w;
                return w*System.Math.Sqrt(1+t*t);
            }
        }
        public static complex conj(complex z)
        {
            return new complex(z.x, -z.y); 
        }    
        public static complex csqr(complex z)
        {
            return new complex(z.x*z.x-z.y*z.y, 2*z.x*z.y); 
        }

    }
    

    /*
     * CSV functionality
     */
     
    public static int CSV_DEFAULT      = 0x0;
    public static int CSV_SKIP_HEADERS = 0x1;
    
    /*
     * CSV operations: reading CSV file to real matrix.
     * 
     * This function reads CSV  file  and  stores  its  contents  to  double
     * precision 2D array. Format of the data file must conform to RFC  4180
     * specification, with additional notes:
     * - file size should be less than 2GB
     * - ASCI encoding, UTF-8 without BOM (in header names) are supported
     * - any character (comma/tab/space) may be used as field separator,  as
     *   long as it is distinct from one used for decimal point
     * - multiple subsequent field separators (say, two  spaces) are treated
     *   as MULTIPLE separators, not one big separator
     * - both comma and full stop may be used as decimal point. Parser  will
     *   automatically determine specific character being used.  Both  fixed
     *   and exponential number formats are  allowed.   Thousand  separators
     *   are NOT allowed.
     * - line may end with \n (Unix style) or \r\n (Windows  style),  parser
     *   will automatically adapt to chosen convention
     * - escaped fields (ones in double quotes) are not supported
     * 
     * INPUT PARAMETERS:
     *     filename        relative/absolute path
     *     separator       character used to separate fields.  May  be  ' ',
     *                     ',', '\t'. Other separators are possible too.
     *     flags           several values combined with bitwise OR:
     *                     * alglib::CSV_SKIP_HEADERS -  if present, first row
     *                       contains headers  and  will  be  skipped.   Its
     *                       contents is used to determine fields count, and
     *                       that's all.
     *                     If no flags are specified, default value 0x0  (or
     *                     alglib::CSV_DEFAULT, which is same) should be used.
     *                     
     * OUTPUT PARAMETERS:
     *     out             2D matrix, CSV file parsed with atof()
     *     
     * HANDLING OF SPECIAL CASES:
     * - file does not exist - alglib::ap_error exception is thrown
     * - empty file - empty array is returned (no exception)
     * - skip_first_row=true, only one row in file - empty array is returned
     * - field contents is not recognized by atof() - field value is replaced
     *   by 0.0
     */
    public static void read_csv(string filename, char separator, int flags, out double[,] matrix)
    {
        //
        // Parameters
        //
        bool skip_first_row = (flags&CSV_SKIP_HEADERS)!=0;
        
        //
        // Prepare empty output array
        //
        matrix = new double[0,0];
        
        //
        // Read file, normalize file contents:
        // * replace 0x0 by spaces
        // * remove trailing spaces and newlines
        // * append trailing '\n' and '\0' characters
        // Return if file contains only spaces/newlines.
        //
        byte b_space = System.Convert.ToByte(' ');
        byte b_tab   = System.Convert.ToByte('\t');
        byte b_lf    = System.Convert.ToByte('\n');
        byte b_cr    = System.Convert.ToByte('\r');
        byte b_comma = System.Convert.ToByte(',');
        byte b_fullstop= System.Convert.ToByte('.');
        byte[] v0 = System.IO.File.ReadAllBytes(filename);
        if( v0.Length==0 )
            return;
        byte[] v1 = new byte[v0.Length+2];
        int filesize = v0.Length;
        for(int i=0; i<filesize; i++)
            v1[i] = v0[i]==0 ? b_space : v0[i];
        for(; filesize>0; )
        {
            byte c = v1[filesize-1];
            if( c==b_space || c==b_tab || c==b_cr || c==b_lf )
            {
                filesize--;
                continue;
            }
            break;
        }
        if( filesize==0 )
            return;
        v1[filesize+0] = b_lf;
        v1[filesize+1] = 0x0;
        filesize+=2;
        
        
        //
        // Scan dataset.
        //
        int rows_count, cols_count, max_length = 0;
        cols_count = 1;
        for(int idx=0; idx<filesize; idx++)
        {
            if( v1[idx]==separator )
                cols_count++;
            if( v1[idx]==b_lf )
                break;
        }
        rows_count = 0;
        for(int idx=0; idx<filesize; idx++)
            if( v1[idx]==b_lf )
                rows_count++;
        if( rows_count==1 && skip_first_row ) // empty output, return
            return;
        int[] offsets = new int[rows_count*cols_count];
        int[] lengths = new int[rows_count*cols_count];
        int cur_row_idx = 0;
        for(int row_start=0; v1[row_start]!=0x0; )
        {
            // determine row length
            int row_length;
            for(row_length=0; v1[row_start+row_length]!=b_lf; row_length++);
            
            // determine cols count, perform integrity check
            int cur_cols_cnt=1;
            for(int idx=0; idx<row_length; idx++)
                if( v1[row_start+idx]==separator )
                    cur_cols_cnt++;
            if( cols_count!=cur_cols_cnt )
                throw new alglib.alglibexception("read_csv: non-rectangular contents, rows have different sizes");
            
            // store offsets and lengths of the fields
            int cur_offs = 0;
            int cur_col_idx = 0;
            for(int idx=0; idx<row_length+1; idx++)
                if( v1[row_start+idx]==separator || v1[row_start+idx]==b_lf )
                {
                    offsets[cur_row_idx*cols_count+cur_col_idx] = row_start+cur_offs;
                    lengths[cur_row_idx*cols_count+cur_col_idx] = idx-cur_offs;
                    max_length = idx-cur_offs>max_length ? idx-cur_offs : max_length;
                    cur_offs = idx+1;
                    cur_col_idx++;
                }
            
            // advance row start
            cur_row_idx++;
            row_start = row_start+row_length+1;
        }
        
        //
        // Convert
        //
        int row0 = skip_first_row ? 1 : 0;
        int row1 = rows_count;
        System.Globalization.CultureInfo culture = System.Globalization.CultureInfo.CreateSpecificCulture(""); // invariant culture
        matrix = new double[row1-row0, cols_count];
        alglib.AE_CRITICAL_ASSERT(culture.NumberFormat.NumberDecimalSeparator==".");
        for(int ridx=row0; ridx<row1; ridx++)
            for(int cidx=0; cidx<cols_count; cidx++)
            {
                int field_len  = lengths[ridx*cols_count+cidx];
                int field_offs = offsets[ridx*cols_count+cidx];
                
                // replace , by full stop
                for(int idx=0; idx<field_len; idx++)
                    if( v1[field_offs+idx]==b_comma )
                        v1[field_offs+idx] = b_fullstop;
                
                // convert
                string s_val = System.Text.Encoding.ASCII.GetString(v1, field_offs, field_len);
                double d_val;
                Double.TryParse(s_val, System.Globalization.NumberStyles.Float, culture, out d_val);
                matrix[ridx-row0,cidx] = d_val;
            }
    }
}

//
// Code below contains interface to HPC computational core
//
public partial class alglib
{
    private static object   CoreInitLock     = new object();
    private static volatile IntPtr hAlglibDL = IntPtr.Zero;
    private static string[] paths = new string[0];
    
    // SMP modes
    private enum alglibmode { serial, parallel };
    
    // X status codes
    private const int X_OK       = 0;
    private const int X_ASSERTION_FAILED = 5;
    
    // data types
    private const int DT_BOOL    = 1;
    private const int DT_INT     = 2;
    private const int DT_REAL    = 3;
    private const int DT_COMPLEX = 4;
    
    // datatype sizes
    private const int SIZE_BOOL      = 1;
    private static int SIZE_INT      = IntPtr.Size;
    private const int SIZE_REAL      = 8;
    private const int SIZE_COMPLEX   = 16;

    // owner types
    private const int OWN_CALLER = 1;
    private const int OWN_AE     = 2;

    // actions which are performed during conversion from C# array to X array
    private const int X_SET     = 1; // data are copied into already initialized x-vector/matrix; previous contents of x-structure is freed
    private const int X_CREATE  = 2; // new x-vector/matrix is created, its previous contents is ignored
    private const int X_REWRITE = 3; // data are copied into already allocated storage; size of X array memory must be equal to the source array size

    // actions performed by ALGLIB core under arrays
    private const int ACT_UNCHANGED     = 1;
    private const int ACT_SAME_LOCATION = 2;
    private const int ACT_NEW_LOCATION  = 3;
    
    // X-structure used to exchange pointer-sized integers
    [StructLayout(LayoutKind.Explicit, Pack=1)]
    private struct x_int
    {   
        public x_int(long v)
        { intval = 0; longval = v; }
       
        [FieldOffset(0)] public int intval;   // int-sized data MUST be loaded from this field
        [FieldOffset(0)] public long longval; // int-sized data MUST be stored to this field
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private unsafe struct x_vector
    {
        public long     cnt;
        public long     datatype;
        public long     owner;
        public long     last_action;
        public IntPtr   ptr;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private unsafe struct x_matrix
    {
        public long     rows;
        public long     cols;
        public long     stride;
        public long     datatype;
        public long     owner;
        public long     last_action;
        public IntPtr   ptr;
    }

    private static unsafe void x_vector_create_empty(ref x_vector x, int datatype)
    {
        x.cnt = 0;
        x.datatype = datatype;
        x.owner = OWN_CALLER;
        x.last_action = ACT_UNCHANGED;
        x.ptr = IntPtr.Zero;
    }
               
    private static unsafe void x_matrix_create_empty(ref x_matrix x, int datatype)
    {
        x.rows = 0;
        x.cols = 0;
        x.stride = 0;
        x.datatype = datatype;
        x.owner = OWN_CALLER;
        x.last_action = ACT_UNCHANGED;
        x.ptr = IntPtr.Zero;
    }
    
    private static unsafe void x_vector_clear(ref x_vector x)
    {
        if( x.owner==OWN_AE )
            x_free(x.ptr);
        x.cnt = 0;
        x.ptr = IntPtr.Zero;
    }
    
    private static unsafe void x_matrix_clear(ref x_matrix x)
    {
        if( x.owner==OWN_AE )
            x_free(x.ptr);
        x.rows = 0;
        x.cols = 0;
        x.stride = 0;
        x.ptr = IntPtr.Zero;
    }
               
    private static unsafe void x_vector_from_array(ref x_vector x, bool[] v, int mode)
    {
        int elemsize = SIZE_BOOL;
        int i, cnt;
        byte *p;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_BOOL;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.ptr);
            x.datatype = DT_BOOL;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_BOOL,  "ALGLIB: trying to rewrite vector - types don't match");
            ap.assert(ap.len(v)==x.cnt,     "ALGLIB: trying to rewrite vector - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite vector - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (byte*)x.ptr.ToPointer();
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,  "ALGLIB: 32/64 conversion error (x-vector too long)");
        for(i=0; i<cnt; i++)
            p[i] = v[i] ? (byte)1 : (byte)0;
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_vector_attach_to_array(ref x_vector x, bool *v, int len)
    {
        //
        // Attach
        //
        x.datatype = DT_BOOL;
        x.cnt = len;
        x.owner = OWN_CALLER;
        x.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_vector_to_array(ref x_vector x, ref bool[] v)
    {
        int i, cnt;
        byte *p;
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,           "ALGLIB: 32/64 conversion error (x-vector too long)");
        ap.assert(x.datatype==DT_BOOL,  "ALGLIB: internal error (unexpected x-vector type)");
        p = (byte*)x.ptr;
        if( v==null || ap.len(v)!=cnt )
            v = new bool[cnt];
        for(i=0; i<cnt; i++)
            v[i] = p[i]!=0;
    }
               
    private static unsafe void x_matrix_from_array(ref x_matrix x, bool[,] v, int mode)
    {
        int elemsize = SIZE_BOOL;
        int i, j;
        int rows, cols;
        byte *p;
        
        //
        // Normalize matrix size
        //
        rows = ap.rows(v);
        if( rows>0 )
            cols = ap.cols(v);
        else
            cols = 0;
        if( cols==0 )
            rows = 0;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_BOOL;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.ptr);
            x.datatype = DT_BOOL;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_BOOL,  "ALGLIB: trying to rewrite matrix - types don't match");
            ap.assert(ap.rows(v)==x.rows,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(ap.cols(v)==x.cols,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite matrix - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (byte*)x.ptr.ToPointer();
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                p[j] = v[i,j] ? (byte)1 : (byte)0;
            p += x.stride;
        }
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_matrix_attach_to_array(ref x_matrix x, bool *v, int rows, int cols)
    {
        //
        // Normalize matrix size
        //
        if( rows==0 || cols==0 )
        {
            cols = 0;
            rows = 0;
        }
        
        //
        // Allocate
        //
        x.datatype = DT_BOOL;
        x.rows = rows;
        x.cols = cols;
        x.stride = cols;
        x.owner = OWN_CALLER;
        x.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_matrix_to_array(ref x_matrix x, ref bool[,] v)
    {
        int i, j;
        int rows, cols, stride;
        byte *p;
        rows   = (int)x.rows;
        cols   = (int)x.cols;
        stride = (int)x.stride;
        ap.assert(rows==x.rows,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(cols==x.cols,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(stride==x.stride,     "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(x.datatype==DT_BOOL,  "ALGLIB: internal error (unexpected x-matrix type)");
        if( v==null || ap.rows(v)!=rows || ap.cols(v)!=cols )
            v = new bool[rows,cols];
        p = (byte*)x.ptr;
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                v[i,j] = p[j]!=0;
            p += stride;
        }
    }
               
    private static unsafe void x_vector_from_array(ref x_vector x, int[] v, int mode)
    {
        int elemsize = SIZE_INT;
        int i, cnt;
        IntPtr *p;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_INT;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.ptr);
            x.datatype = DT_INT;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_INT,   "ALGLIB: trying to rewrite vector - types don't match");
            ap.assert(ap.len(v)==x.cnt,     "ALGLIB: trying to rewrite vector - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite vector - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (IntPtr*)x.ptr.ToPointer();
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,  "ALGLIB: 32/64 conversion error (x-vector too long)");
        for(i=0; i<cnt; i++)
            p[i] = (IntPtr)v[i];
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_vector_to_array(ref x_vector x, ref int[] v)
    {
        int i, cnt;
        IntPtr *p;
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,           "ALGLIB: 32/64 conversion error (x-vector too long)");
        ap.assert(x.datatype==DT_INT,   "ALGLIB: internal error (unexpected x-vector type)");
        p = (IntPtr*)x.ptr;
        if( v==null || ap.len(v)!=cnt )
            v = new int[cnt];
        for(i=0; i<cnt; i++)
            v[i] = (int)p[i];
    }
               
    private static unsafe void x_matrix_from_array(ref x_matrix x, int[,] v, int mode)
    {
        int elemsize = SIZE_INT;
        int i, j;
        int rows, cols;
        IntPtr *p;
        
        //
        // Normalize matrix size
        //
        rows = ap.rows(v);
        if( rows>0 )
            cols = ap.cols(v);
        else
            cols = 0;
        if( cols==0 )
            rows = 0;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_INT;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.ptr);
            x.datatype = DT_INT;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_INT,   "ALGLIB: trying to rewrite matrix - types don't match");
            ap.assert(ap.rows(v)==x.rows,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(ap.cols(v)==x.cols,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite matrix - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (IntPtr*)x.ptr.ToPointer();
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                p[j] = (IntPtr)v[i,j];
            p += x.stride;
        }
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_matrix_to_array(ref x_matrix x, ref int[,] v)
    {
        int i, j;
        int rows, cols, stride;
        IntPtr *p;
        rows   = (int)x.rows;
        cols   = (int)x.cols;
        stride = (int)x.stride;
        ap.assert(rows==x.rows,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(cols==x.cols,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(stride==x.stride,     "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(x.datatype==DT_INT,   "ALGLIB: internal error (unexpected x-matrix type)");
        if( v==null || ap.rows(v)!=rows || ap.cols(v)!=cols )
            v = new int[rows,cols];
        p = (IntPtr*)x.ptr;
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                v[i,j] = (int)p[j];
            p += stride;
        }
    }
               
    private static unsafe void x_vector_from_array(ref x_vector x, double[] v, int mode)
    {
        int elemsize = SIZE_REAL;
        int i, cnt;
        double *p;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_REAL;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.ptr);
            x.datatype = DT_REAL;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_REAL,  "ALGLIB: trying to rewrite vector - types don't match");
            ap.assert(ap.len(v)==x.cnt,     "ALGLIB: trying to rewrite vector - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite vector - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (double*)x.ptr.ToPointer();
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,  "ALGLIB: 32/64 conversion error (x-vector too long)");
        for(i=0; i<cnt; i++)
            p[i] = v[i];
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_vector_attach_to_array(ref x_vector x, double *v, int len)
    {
        //
        // Attach
        //
        x.datatype = DT_REAL;
        x.cnt = len;
        x.owner = OWN_CALLER;
        x.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_vector_to_array(ref x_vector x, ref double[] v)
    {
        int i, cnt;
        double *p;
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,           "ALGLIB: 32/64 conversion error (x-vector too long)");
        ap.assert(x.datatype==DT_REAL,  "ALGLIB: internal error (unexpected x-vector type)");
        p = (double*)x.ptr;
        if( v==null || ap.len(v)!=cnt )
            v = new double[cnt];
        for(i=0; i<cnt; i++)
            v[i] = p[i];
    }
               
    private static unsafe void x_matrix_from_array(ref x_matrix x, double[,] v, int mode)
    {
        int elemsize = SIZE_REAL;
        int i, j;
        int rows, cols;
        double *p;
        
        //
        // Normalize matrix size
        //
        rows = ap.rows(v);
        if( rows>0 )
            cols = ap.cols(v);
        else
            cols = 0;
        if( cols==0 )
            rows = 0;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_REAL;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.ptr);
            x.datatype = DT_REAL;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_REAL,  "ALGLIB: trying to rewrite matrix - types don't match");
            ap.assert(ap.rows(v)==x.rows,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(ap.cols(v)==x.cols,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite matrix - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (double*)x.ptr.ToPointer();
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                p[j] = v[i,j];
            p += x.stride;
        }
    }
               
    private static unsafe void x_matrix_attach_to_array(ref x_matrix x, double *v, int rows, int cols)
    {   
        //
        // Normalize matrix size
        //
        if( rows==0 || cols==0 )
        {
            cols = 0;
            rows = 0;
        }
        
        //
        // Allocate
        //
        x.datatype = DT_REAL;
        x.rows = rows;
        x.cols = cols;
        x.stride = cols;
        x.owner = OWN_CALLER;
        x.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_matrix_to_array(ref x_matrix x, ref double[,] v)
    {
        int i, j;
        int rows, cols, stride;
        double *p;
        rows   = (int)x.rows;
        cols   = (int)x.cols;
        stride = (int)x.stride;
        ap.assert(rows==x.rows,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(cols==x.cols,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(stride==x.stride,     "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(x.datatype==DT_REAL,  "ALGLIB: internal error (unexpected x-matrix type)");
        if( v==null || ap.rows(v)!=rows || ap.cols(v)!=cols )
            v = new double[rows,cols];
        p = (double*)x.ptr;
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
                v[i,j] = p[j];
            p += stride;
        }
    }
               
    private static unsafe void x_vector_from_array(ref x_vector x, alglib.complex[] v, int mode)
    {
        int elemsize = SIZE_COMPLEX;
        int i, cnt;
        alglib.complex *p;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_COMPLEX;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.ptr);
            x.datatype = DT_COMPLEX;
            x.cnt = ap.len(v);
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.cnt)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_COMPLEX,"ALGLIB: trying to rewrite vector - types don't match");
            ap.assert(ap.len(v)==x.cnt,     "ALGLIB: trying to rewrite vector - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite vector - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (alglib.complex*)x.ptr.ToPointer();
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,  "ALGLIB: 32/64 conversion error (x-vector too long)");
        for(i=0; i<cnt; i++)
        {
            p[i].x = v[i].x;
            p[i].y = v[i].y;
        }
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_vector_attach_to_array(ref x_vector x, alglib.complex *v, int len)
    {
        //
        // Attach
        //
        x.datatype = DT_COMPLEX;
        x.cnt = len;
        x.owner = OWN_CALLER;
        x.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_vector_to_array(ref x_vector x, ref alglib.complex[] v)
    {
        int i, cnt;
        alglib.complex *p;
        cnt = (int)x.cnt;
        ap.assert(cnt==x.cnt,               "ALGLIB: 32/64 conversion error (x-vector too long)");
        ap.assert(x.datatype==DT_COMPLEX,   "ALGLIB: internal error (unexpected x-vector type)");
        p = (alglib.complex*)x.ptr;
        if( v==null || ap.len(v)!=cnt )
            v = new alglib.complex[cnt];
        for(i=0; i<cnt; i++)
        {
            v[i].x = p[i].x;
            v[i].y = p[i].y;
        }
    }
               
    private static unsafe void x_matrix_from_array(ref x_matrix x, alglib.complex[,] v, int mode)
    {
        int elemsize = SIZE_COMPLEX;
        int i, j;
        int rows, cols;
        alglib.complex *p;
        
        //
        // Normalize matrix size
        //
        rows = ap.rows(v);
        if( rows>0 )
            cols = ap.cols(v);
        else
            cols = 0;
        if( cols==0 )
            rows = 0;
        
        //
        // Allocate
        //
        if( mode==X_CREATE )
        {
            x.datatype = DT_COMPLEX;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_UNCHANGED;
        }
        if( mode==X_SET )
        {
            if( x.owner==OWN_AE )
                x_free(x.ptr);
            x.datatype = DT_COMPLEX;
            x.rows = rows;
            x.cols = cols;
            x.stride = cols;
            x.owner = OWN_AE;
            ap.assert(x_malloc(out x.ptr, elemsize*x.stride*x.rows)==X_OK, "ALGLIB: x_malloc failed");
            x.last_action = ACT_NEW_LOCATION;
        }
        if( mode==X_REWRITE )
        {
            ap.assert(x.datatype==DT_COMPLEX,"ALGLIB: trying to rewrite matrix - types don't match");
            ap.assert(ap.rows(v)==x.rows,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(ap.cols(v)==x.cols,   "ALGLIB: trying to rewrite matrix - sizes don't match");
            ap.assert(x.last_action==ACT_UNCHANGED ||
                      x.last_action==ACT_SAME_LOCATION ||
                      x.last_action==ACT_NEW_LOCATION, "ALGLIB: trying to rewrite matrix - internal protection error");
            if( x.last_action==ACT_UNCHANGED )
                x.last_action = ACT_SAME_LOCATION;
        }
        
        //
        // Copy data
        //
        p = (alglib.complex*)x.ptr.ToPointer();
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
            {
                p[j].x = v[i,j].x;
                p[j].y = v[i,j].y;
            }
            p += x.stride;
        }
    }
    
    // attaches X-array to existing C# array
    private static unsafe void x_matrix_attach_to_array(ref x_matrix x, alglib.complex *v, int rows, int cols)
    {   
        //
        // Normalize matrix size
        //
        if( rows==0 || cols==0 )
        {
            cols = 0;
            rows = 0;
        }
        
        //
        // Allocate
        //
        x.datatype = DT_COMPLEX;
        x.rows = rows;
        x.cols = cols;
        x.stride = cols;
        x.owner = OWN_CALLER;
        x.ptr = new IntPtr((void*)v);
        x.last_action = ACT_UNCHANGED;
    }
    
    // converts X-array to C# array; v can be null.
    private static unsafe void x_matrix_to_array(ref x_matrix x, ref alglib.complex[,] v)
    {
        int i, j;
        int rows, cols, stride;
        alglib.complex *p;
        rows   = (int)x.rows;
        cols   = (int)x.cols;
        stride = (int)x.stride;
        ap.assert(rows==x.rows,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(cols==x.cols,         "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(stride==x.stride,     "ALGLIB: 32/64 conversion error (x-matrix too long)");
        ap.assert(x.datatype==DT_COMPLEX,"ALGLIB: internal error (unexpected x-matrix type)");
        if( v==null || ap.rows(v)!=rows || ap.cols(v)!=cols )
            v = new alglib.complex[rows,cols];
        p = (alglib.complex*)x.ptr;
        for(i=0; i<rows; i++)
        {
            for(j=0; j<cols; j++)
            {
                v[i,j].x = p[j].x;
                v[i,j].y = p[j].y;
            }
            p += stride;
        }
    }
    
    [DllImport("kernel32")]
    private extern static IntPtr LoadLibrary(string libraryName);
    
    [DllImport("kernel32", CharSet=CharSet.Ansi)]
    private extern static IntPtr GetProcAddress(IntPtr hwnd, string procedureName);
    
    // loads dynamic library returns IntPtr which holds its handle
    private static IntPtr DynamicLoad(string name)
    {
        return LoadLibrary(name);
    }
    
    // returns IntPtr pointing to function 'name' from dynamic library hLib
    private static IntPtr DynamicAddr(IntPtr hLib, string name)
    {
        return GetProcAddress(hLib, name);
    }
    
    // returns OS name: 'windows' or 'linux'
    private static string GetOSName()
    {
        if( System.IO.Path.DirectorySeparatorChar=='/' )
            return "linux";
        return "windows";
    }
    
    //
    // This function tries to locate library given by its name (with
    // OS-specific extension) in one of the following search directories:
    // *  given by paths[] array
    // *  given by GetExecutingAssembly().CodeBase property for
    //    assemblies NOT in the GAC (if previous attempt failed)
    // *  given by GetEntryAssembly().CodeBase property (if previous
    //    attempt failed)
    //
    private static string LocateLibrary(string name)
    {
        string libpath = "";
        string tmppath = "";
        if( libpath=="" )
        {
            int i;
            for(i=0; i<paths.Length; i++)
                if( System.IO.File.Exists(paths[i]+System.IO.Path.DirectorySeparatorChar+name) )
                {
                    libpath = paths[i];
                    break;
                }
                    
        }
        if( libpath=="" && Assembly.GetExecutingAssembly().CodeBase!="" )
        {
            string codeBase = Assembly.GetExecutingAssembly().CodeBase;
            UriBuilder uri = new UriBuilder(codeBase);
            string path = Uri.UnescapeDataString(uri.Path);
            tmppath = System.IO.Path.GetDirectoryName(path);
            if( System.IO.File.Exists(tmppath+System.IO.Path.DirectorySeparatorChar+name) )
                libpath = tmppath;
        }
        if( libpath=="" && Assembly.GetEntryAssembly()!=null )
        {
            string codeBase = Assembly.GetEntryAssembly().CodeBase;
            UriBuilder uri = new UriBuilder(codeBase);
            string path = Uri.UnescapeDataString(uri.Path);
            tmppath = System.IO.Path.GetDirectoryName(path);
            if( System.IO.File.Exists(tmppath+System.IO.Path.DirectorySeparatorChar+name) )
                libpath = tmppath;
        }
        if( libpath=="" )
            throw new System.Exception("ALGLIB: can't determine path to "+name);
        return libpath+System.IO.Path.DirectorySeparatorChar+name;
    }
    
    /********************************************************************
    This function loads ALGLIB HPC core (if not loaded yet).
    
    ALGLIB core is automatically  loaded  before  first  call  of  ALGLIB
    functions, but you may call this function  if  you  want  core  being
    loaded right now.
    ********************************************************************/
    public static void activatealglibcore()
    {
        // code below uses double-checked locking, safe in NET 2.0 and later
        if( hAlglibDL==IntPtr.Zero )
            lock(CoreInitLock)
            {
                if( hAlglibDL==IntPtr.Zero )
                {
                    string os = GetOSName();
                    string libname = "";
                    if( os=="linux" )
                        libname = "alglib_hpc.so";
                    if( os=="windows" )
                        libname = "alglib"+(IntPtr.Size*8).ToString()+"_hpc.dll";
                    if( libname=="" )
                        throw new System.Exception("ALGLIB: unknown OS - '"+os+"'");
                    libname = LocateLibrary(libname);
                    IntPtr hTemporaryAlglibDL = DynamicLoad(libname);
                    if( hTemporaryAlglibDL==IntPtr.Zero )
                        throw new System.Exception("ALGLIB: unable to load binaries");
                    LoadALGLIBFunctions(hTemporaryAlglibDL);
                    hAlglibDL = hTemporaryAlglibDL;
                }
            }
    }
    
    /************************************************************************
    This function adds to search list  one  more  potential  path  to  ALGLIB
    native DLL's. This function should be  called  prior  to  first  call  of
    ALGLIB  functions.
    
    INPUT PARAMETERS:
        path        -   search path, can be relative (to  current  directory)
                        or absolute.
                        
                        
    NOTE 1: If  you  specified  relative  path, you should remember that path
            is evaluated during first call of ALGLIB functions. Say, if:
            * 'programdir' is current directory, with  'subdir'  subdirectory
              where ALGLIB DLL's are located.
            * you added 'subdir' as search path
            * you changed current directory to 'c:/'
            * and only after THAT you called first ALGLIB function
            then you won't be able to detect and load ALGLIB DLL's
            
    NOTE 2: If you want, you may enforce activation of ALGLIB core by calling
            activatealglibcore() function.
    ************************************************************************/
    public static void addsearchpath(string path)
    {
         lock(CoreInitLock)
         {
             string[] newpaths = new string[paths.Length+1];
             int i;
             for(i=0; i<paths.Length; i++)
                 newpaths[i] = paths[i];
             newpaths[paths.Length] = path;
             paths = newpaths;
         }
    }
    
    /************************************************************************
    This function sets number of CPU cores which should  be  used  by  worker
    threads. In case user specified non-positive number of cores to use, this
    number will be converted according to following rules:
    *  0 => ae_cores_count()
    * -1 => max(ae_cores_count()-1,1)
    * -2 => max(ae_cores_count()-2,1)
    and so on.

    In case user specified positive number of  cores,  greater  than 1,  then
    ALGLIB will launch no more than ncores threads (or less, when nworkers is
    larger than actual number of cores).
    ************************************************************************/
    public static void setnworkers(long nworkers)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        x_setnworkers(nworkers);
    }

    
    
    //
    // Subpackage hqrnd
    //
    

    public unsafe class hqrndstate : alglibobject
    {
        public void *ptr;
        public hqrndstate(void *x)
        {
            ptr = x;
        }
        ~hqrndstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new hqrndstate(null);
            return new hqrndstate(_i_x_obj_copy_hqrndstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_hqrndstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_hqrndstate(void *x);
    private static _d_x_obj_copy_hqrndstate _i_x_obj_copy_hqrndstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_hqrndstate(void *x);
    private static _d_x_obj_free_hqrndstate _i_x_obj_free_hqrndstate = null;
    private static unsafe void _core_hqrndrandomize(out hqrndstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hqrndrandomize(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrndrandomize' call");
            }
            state = new hqrndstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_hqrndstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void hqrndrandomize(out hqrndstate state)
    {
    _core_hqrndrandomize(out  state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hqrndseed(int s1, int s2, out hqrndstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_s1 = new x_int(s1);
        x_int _d_s2 = new x_int(s2);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hqrndseed(&_s_errormsg, &_d_s1, &_d_s2, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrndseed' call");
            }
            state = new hqrndstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_hqrndstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void hqrndseed(int s1, int s2, out hqrndstate state)
    {
    _core_hqrndseed( s1,  s2, out  state, alglibmode.serial);
    return;
    }
    private static unsafe double _core_hqrnduniformr(hqrndstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hqrnduniformr(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrnduniformr' call");
            }
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double hqrnduniformr(hqrndstate state)
    {
    double result = _core_hqrnduniformr( state, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_hqrnduniformi(hqrndstate state, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_state = state.ptr;
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hqrnduniformi(&_s_errormsg, &_d_result, &_d_state, &_d_n);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrnduniformi' call");
            }
            result = _d_result.intval;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int hqrnduniformi(hqrndstate state, int n)
    {
    int result = _core_hqrnduniformi( state,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_hqrndnormal(hqrndstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hqrndnormal(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrndnormal' call");
            }
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double hqrndnormal(hqrndstate state)
    {
    double result = _core_hqrndnormal( state, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_hqrndunit2(hqrndstate state, out double x, out double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_x = 0;
        double _d_y = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hqrndunit2(&_s_errormsg, &_d_state, &_d_x, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrndunit2' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void hqrndunit2(hqrndstate state, out double x, out double y)
    {
    _core_hqrndunit2( state, out  x, out  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hqrndnormal2(hqrndstate state, out double x1, out double x2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_x1 = 0;
        double _d_x2 = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hqrndnormal2(&_s_errormsg, &_d_state, &_d_x1, &_d_x2);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrndnormal2' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            x1 = _d_x1;
            x2 = _d_x2;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void hqrndnormal2(hqrndstate state, out double x1, out double x2)
    {
    _core_hqrndnormal2( state, out  x1, out  x2, alglibmode.serial);
    return;
    }
    private static unsafe double _core_hqrndexponential(hqrndstate state, double lambdav, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hqrndexponential(&_s_errormsg, &_d_result, &_d_state, &_d_lambdav);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrndexponential' call");
            }
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double hqrndexponential(hqrndstate state, double lambdav)
    {
    double result = _core_hqrndexponential( state,  lambdav, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_hqrnddiscrete(hqrndstate state, double[] x, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_hqrnddiscrete(&_s_errormsg, &_d_result, &_d_state, &_d_x, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrnddiscrete' call");
            }
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double hqrnddiscrete(hqrndstate state, double[] x, int n)
    {
    double result = _core_hqrnddiscrete( state,  x,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_hqrndcontinuous(hqrndstate state, double[] x, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_hqrndcontinuous(&_s_errormsg, &_d_result, &_d_state, &_d_x, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hqrndcontinuous' call");
            }
            result = _d_result;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double hqrndcontinuous(hqrndstate state, double[] x, int n)
    {
    double result = _core_hqrndcontinuous( state,  x,  n, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage nearestneighbor
    //
    

    public unsafe class kdtree : alglibobject
    {
        public void *ptr;
        public kdtree(void *x)
        {
            ptr = x;
        }
        ~kdtree()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new kdtree(null);
            return new kdtree(_i_x_obj_copy_kdtree(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_kdtree(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_kdtree(void *x);
    private static _d_x_obj_copy_kdtree _i_x_obj_copy_kdtree = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_kdtree(void *x);
    private static _d_x_obj_free_kdtree _i_x_obj_free_kdtree = null;
    public static unsafe void kdtreeserialize(kdtree obj, out string s_out)
    {
        byte *_error_msg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        int _error_code = _i_x_kdtreeserialize(&_error_msg, &_x, &_out);
        if( _error_code!=X_OK )
            throw new alglibexception(_error_code==X_ASSERTION_FAILED
                ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                : "ALGLIB: unknown error during kdtreeserialize() call");
        s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        x_free((IntPtr)_out);
    }
    
    public static unsafe void kdtreeunserialize(string s_in, out kdtree obj)
    {
        byte *_error_msg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            int _error_code = _i_x_kdtreeunserialize(&_error_msg, &_in, &_x);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                    : "ALGLIB: unknown error during kdtreeunserialize() call");
            obj = new kdtree(_x);
        }
    }
    private static unsafe void _core_kdtreebuild(double[,] xy, int n, int nx, int ny, int normtype, out kdtree kdt, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_nx = new x_int(nx);
        x_int _d_ny = new x_int(ny);
        x_int _d_normtype = new x_int(normtype);
        void *_d_kdt = null;
        kdt = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_kdtreebuild(&_s_errormsg, &_d_xy, &_d_n, &_d_nx, &_d_ny, &_d_normtype, &_d_kdt);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreebuild' call");
            }
            kdt = new kdtree(_d_kdt);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_kdt!=null && kdt==null)
                _i_x_obj_free_kdtree(_d_kdt); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void kdtreebuild(double[,] xy, int n, int nx, int ny, int normtype, out kdtree kdt)
    {
    _core_kdtreebuild( xy,  n,  nx,  ny,  normtype, out  kdt, alglibmode.serial);
    return;
    }
    public static void kdtreebuild(double[,] xy, int nx, int ny, int normtype, out kdtree kdt)
    {
    int n;
    
    
    n = ap.rows(xy);
    
    _core_kdtreebuild( xy,  n,  nx,  ny,  normtype, out  kdt, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_kdtreebuildtagged(double[,] xy, int[] tags, int n, int nx, int ny, int normtype, out kdtree kdt, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_vector _d_tags = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_nx = new x_int(nx);
        x_int _d_ny = new x_int(ny);
        x_int _d_normtype = new x_int(normtype);
        void *_d_kdt = null;
        kdt = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_from_array(ref _d_tags, tags, X_CREATE);
                _error_code = _i_ser_kdtreebuildtagged(&_s_errormsg, &_d_xy, &_d_tags, &_d_n, &_d_nx, &_d_ny, &_d_normtype, &_d_kdt);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreebuildtagged' call");
            }
            kdt = new kdtree(_d_kdt);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_tags);
            if( _d_kdt!=null && kdt==null)
                _i_x_obj_free_kdtree(_d_kdt); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void kdtreebuildtagged(double[,] xy, int[] tags, int n, int nx, int ny, int normtype, out kdtree kdt)
    {
    _core_kdtreebuildtagged( xy,  tags,  n,  nx,  ny,  normtype, out  kdt, alglibmode.serial);
    return;
    }
    public static void kdtreebuildtagged(double[,] xy, int[] tags, int nx, int ny, int normtype, out kdtree kdt)
    {
    int n;
    
    if( (ap.rows(xy)!=ap.len(tags)))
        throw new alglibexception("Error while calling 'kdtreebuildtagged': looks like one of arguments has wrong size");
    
    n = ap.rows(xy);
    
    _core_kdtreebuildtagged( xy,  tags,  n,  nx,  ny,  normtype, out  kdt, alglibmode.serial);
    
    return;
    }
    private static unsafe int _core_kdtreequeryknn(kdtree kdt, double[] x, int k, bool selfmatch, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_k = new x_int(k);
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_kdtreequeryknn(&_s_errormsg, &_d_result, &_d_kdt, &_d_x, &_d_k, &_d_selfmatch);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryknn' call");
            }
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static int kdtreequeryknn(kdtree kdt, double[] x, int k, bool selfmatch)
    {
    int result = _core_kdtreequeryknn( kdt,  x,  k,  selfmatch, alglibmode.serial);
    return result;
    }
    public static int kdtreequeryknn(kdtree kdt, double[] x, int k)
    {
    bool selfmatch;
    
    
    selfmatch = true;
    
    int result = _core_kdtreequeryknn( kdt,  x,  k,  selfmatch, alglibmode.serial);
    
    return result;
    }
    private static unsafe int _core_kdtreequeryrnn(kdtree kdt, double[] x, double r, bool selfmatch, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        x_vector _d_x = new x_vector();
        double _d_r = r;
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_kdtreequeryrnn(&_s_errormsg, &_d_result, &_d_kdt, &_d_x, &_d_r, &_d_selfmatch);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryrnn' call");
            }
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static int kdtreequeryrnn(kdtree kdt, double[] x, double r, bool selfmatch)
    {
    int result = _core_kdtreequeryrnn( kdt,  x,  r,  selfmatch, alglibmode.serial);
    return result;
    }
    public static int kdtreequeryrnn(kdtree kdt, double[] x, double r)
    {
    bool selfmatch;
    
    
    selfmatch = true;
    
    int result = _core_kdtreequeryrnn( kdt,  x,  r,  selfmatch, alglibmode.serial);
    
    return result;
    }
    private static unsafe int _core_kdtreequeryaknn(kdtree kdt, double[] x, int k, bool selfmatch, double eps, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_kdt = kdt.ptr;
        x_vector _d_x = new x_vector();
        x_int _d_k = new x_int(k);
        byte _d_selfmatch = (byte)(selfmatch ? 1 : 0);
        double _d_eps = eps;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_kdtreequeryaknn(&_s_errormsg, &_d_result, &_d_kdt, &_d_x, &_d_k, &_d_selfmatch, &_d_eps);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryaknn' call");
            }
            result = _d_result.intval;
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static int kdtreequeryaknn(kdtree kdt, double[] x, int k, bool selfmatch, double eps)
    {
    int result = _core_kdtreequeryaknn( kdt,  x,  k,  selfmatch,  eps, alglibmode.serial);
    return result;
    }
    public static int kdtreequeryaknn(kdtree kdt, double[] x, int k, double eps)
    {
    bool selfmatch;
    
    
    selfmatch = true;
    
    int result = _core_kdtreequeryaknn( kdt,  x,  k,  selfmatch,  eps, alglibmode.serial);
    
    return result;
    }
    private static unsafe void _core_kdtreequeryresultsx(kdtree kdt, ref double[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                _error_code = _i_ser_kdtreequeryresultsx(&_s_errormsg, &_d_kdt, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryresultsx' call");
            }
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void kdtreequeryresultsx(kdtree kdt, ref double[,] x)
    {
    _core_kdtreequeryresultsx( kdt, ref  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_kdtreequeryresultsxy(kdtree kdt, ref double[,] xy, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_matrix _d_xy = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_kdtreequeryresultsxy(&_s_errormsg, &_d_kdt, &_d_xy);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryresultsxy' call");
            }
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void kdtreequeryresultsxy(kdtree kdt, ref double[,] xy)
    {
    _core_kdtreequeryresultsxy( kdt, ref  xy, alglibmode.serial);
    return;
    }
    private static unsafe void _core_kdtreequeryresultstags(kdtree kdt, ref int[] tags, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_vector _d_tags = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_tags, tags, X_CREATE);
            _error_code = _i_ser_kdtreequeryresultstags(&_s_errormsg, &_d_kdt, &_d_tags);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryresultstags' call");
            }
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_tags, ref tags);
        }
        finally
        {
            x_vector_clear(ref _d_tags);
        }
        // This function returns no value.
    }
    public static void kdtreequeryresultstags(kdtree kdt, ref int[] tags)
    {
    _core_kdtreequeryresultstags( kdt, ref  tags, alglibmode.serial);
    return;
    }
    private static unsafe void _core_kdtreequeryresultsdistances(kdtree kdt, ref double[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_r = r){
                x_vector_attach_to_array(ref _d_r, _fp_r, ap.len(r));
                _error_code = _i_ser_kdtreequeryresultsdistances(&_s_errormsg, &_d_kdt, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryresultsdistances' call");
            }
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void kdtreequeryresultsdistances(kdtree kdt, ref double[] r)
    {
    _core_kdtreequeryresultsdistances( kdt, ref  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_kdtreequeryresultsxi(kdtree kdt, out double[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_x, DT_REAL);
            x = null;
            _error_code = _i_ser_kdtreequeryresultsxi(&_s_errormsg, &_d_kdt, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryresultsxi' call");
            }
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void kdtreequeryresultsxi(kdtree kdt, out double[,] x)
    {
    _core_kdtreequeryresultsxi( kdt, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_kdtreequeryresultsxyi(kdtree kdt, out double[,] xy, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_matrix _d_xy = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_xy, DT_REAL);
            xy = null;
            _error_code = _i_ser_kdtreequeryresultsxyi(&_s_errormsg, &_d_kdt, &_d_xy);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryresultsxyi' call");
            }
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void kdtreequeryresultsxyi(kdtree kdt, out double[,] xy)
    {
    _core_kdtreequeryresultsxyi( kdt, out  xy, alglibmode.serial);
    return;
    }
    private static unsafe void _core_kdtreequeryresultstagsi(kdtree kdt, out int[] tags, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_vector _d_tags = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_tags, DT_INT);
            tags = null;
            _error_code = _i_ser_kdtreequeryresultstagsi(&_s_errormsg, &_d_kdt, &_d_tags);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryresultstagsi' call");
            }
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_tags, ref tags);
        }
        finally
        {
            x_vector_clear(ref _d_tags);
        }
        // This function returns no value.
    }
    public static void kdtreequeryresultstagsi(kdtree kdt, out int[] tags)
    {
    _core_kdtreequeryresultstagsi( kdt, out  tags, alglibmode.serial);
    return;
    }
    private static unsafe void _core_kdtreequeryresultsdistancesi(kdtree kdt, out double[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_kdt = kdt.ptr;
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_r, DT_REAL);
            r = null;
            _error_code = _i_ser_kdtreequeryresultsdistancesi(&_s_errormsg, &_d_kdt, &_d_r);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kdtreequeryresultsdistancesi' call");
            }
            ap.assert(kdt.ptr==_d_kdt, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void kdtreequeryresultsdistancesi(kdtree kdt, out double[] r)
    {
    _core_kdtreequeryresultsdistancesi( kdt, out  r, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage xdebug
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_xdebugrecord1
    {
        public x_int i;
        public alglib.complex c;
        public x_vector a;
    }

    public class xdebugrecord1 : alglibobject
    {
        public int i;
        public alglib.complex c;
        public double[] a;
        public override alglib.alglibobject make_copy()
        {
            xdebugrecord1 dst = new xdebugrecord1();
            dst.i = i;
            dst.c = c;
            dst.a = (double[])a.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_xdebugrecord1_init(ref x_xdebugrecord1 x)
    {
        x.i.longval = 0;
        x.c.x = 0;
        x.c.y = 0;
        x_vector_create_empty(ref x.a, DT_REAL);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_xdebugrecord1_clear(ref x_xdebugrecord1 x)
    {
        x_vector_clear(ref x.a);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_xdebugrecord1_init_from(ref x_xdebugrecord1 x, xdebugrecord1 v)
    {
        x.i.longval = v.i;
        x.c.x = v.c.x;
        x.c.y = v.c.y;
        x_vector_from_array(ref x.a, v.a, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_xdebugrecord1_to_record(ref x_xdebugrecord1 x, ref xdebugrecord1 v)
    {
        if( v==null )
            v = new xdebugrecord1();
        v.i = x.i.intval; // long is silently truncated to int
        v.c.x = x.c.x;
        v.c.y = x.c.y;
        x_vector_to_array(ref x.a, ref v.a);
    }
    private static unsafe void _core_xdebuginitrecord1(out xdebugrecord1 rec1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_xdebugrecord1 _d_rec1 = new x_xdebugrecord1();
        
        // Pack, call, unpack
        try
        {
            x_xdebugrecord1_init(ref _d_rec1);
            _error_code = _i_ser_xdebuginitrecord1(&_s_errormsg, &_d_rec1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebuginitrecord1' call");
            }
            rec1 = null;
            x_xdebugrecord1_to_record(ref _d_rec1, ref rec1);
        }
        finally
        {
            x_xdebugrecord1_clear(ref _d_rec1);
        }
        // This function returns no value.
    }
    public static void xdebuginitrecord1(out xdebugrecord1 rec1)
    {
    _core_xdebuginitrecord1(out  rec1, alglibmode.serial);
    return;
    }
    private static unsafe int _core_xdebugb1count(bool[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugb1count(&_s_errormsg, &_d_result, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugb1count' call");
            }
            result = _d_result.intval;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        return result;
    }
    public static int xdebugb1count(bool[] a)
    {
    int result = _core_xdebugb1count( a, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_xdebugb1not(ref bool[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugb1not(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugb1not' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugb1not(ref bool[] a)
    {
    _core_xdebugb1not(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugb1appendcopy(ref bool[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugb1appendcopy(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugb1appendcopy' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugb1appendcopy(ref bool[] a)
    {
    _core_xdebugb1appendcopy(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugb1outeven(int n, out bool[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_BOOL);
            a = null;
            _error_code = _i_ser_xdebugb1outeven(&_s_errormsg, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugb1outeven' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugb1outeven(int n, out bool[] a)
    {
    _core_xdebugb1outeven( n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe int _core_xdebugi1sum(int[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_ser_xdebugi1sum(&_s_errormsg, &_d_result, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugi1sum' call");
            }
            result = _d_result.intval;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        return result;
    }
    public static int xdebugi1sum(int[] a)
    {
    int result = _core_xdebugi1sum( a, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_xdebugi1neg(ref int[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_ser_xdebugi1neg(&_s_errormsg, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugi1neg' call");
            }
            x_vector_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugi1neg(ref int[] a)
    {
    _core_xdebugi1neg(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugi1appendcopy(ref int[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_ser_xdebugi1appendcopy(&_s_errormsg, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugi1appendcopy' call");
            }
            x_vector_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugi1appendcopy(ref int[] a)
    {
    _core_xdebugi1appendcopy(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugi1outeven(int n, out int[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_INT);
            a = null;
            _error_code = _i_ser_xdebugi1outeven(&_s_errormsg, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugi1outeven' call");
            }
            x_vector_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugi1outeven(int n, out int[] a)
    {
    _core_xdebugi1outeven( n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe double _core_xdebugr1sum(double[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugr1sum(&_s_errormsg, &_d_result, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugr1sum' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        return result;
    }
    public static double xdebugr1sum(double[] a)
    {
    double result = _core_xdebugr1sum( a, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_xdebugr1neg(ref double[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugr1neg(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugr1neg' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugr1neg(ref double[] a)
    {
    _core_xdebugr1neg(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugr1appendcopy(ref double[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugr1appendcopy(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugr1appendcopy' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugr1appendcopy(ref double[] a)
    {
    _core_xdebugr1appendcopy(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugr1outeven(int n, out double[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_ser_xdebugr1outeven(&_s_errormsg, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugr1outeven' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugr1outeven(int n, out double[] a)
    {
    _core_xdebugr1outeven( n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe complex _core_xdebugc1sum(complex[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        alglib.complex result;
        alglib.complex _d_result;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                _d_result.x = 0;
                _d_result.y = 0;
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugc1sum(&_s_errormsg, &_d_result, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugc1sum' call");
            }
            result.x = _d_result.x;
            result.y = _d_result.y;
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        return result;
    }
    public static alglib.complex xdebugc1sum(complex[] a)
    {
    alglib.complex result = _core_xdebugc1sum( a, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_xdebugc1neg(ref complex[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugc1neg(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugc1neg' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugc1neg(ref complex[] a)
    {
    _core_xdebugc1neg(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugc1appendcopy(ref complex[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_xdebugc1appendcopy(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugc1appendcopy' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugc1appendcopy(ref complex[] a)
    {
    _core_xdebugc1appendcopy(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugc1outeven(int n, out complex[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_ser_xdebugc1outeven(&_s_errormsg, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugc1outeven' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugc1outeven(int n, out complex[] a)
    {
    _core_xdebugc1outeven( n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe int _core_xdebugb2count(bool[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugb2count(&_s_errormsg, &_d_result, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugb2count' call");
            }
            result = _d_result.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static int xdebugb2count(bool[,] a)
    {
    int result = _core_xdebugb2count( a, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_xdebugb2not(ref bool[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugb2not(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugb2not' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugb2not(ref bool[,] a)
    {
    _core_xdebugb2not(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugb2transpose(ref bool[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(bool* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugb2transpose(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugb2transpose' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugb2transpose(ref bool[,] a)
    {
    _core_xdebugb2transpose(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugb2outsin(int m, int n, out bool[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_BOOL);
            a = null;
            _error_code = _i_ser_xdebugb2outsin(&_s_errormsg, &_d_m, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugb2outsin' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new bool[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugb2outsin(int m, int n, out bool[,] a)
    {
    _core_xdebugb2outsin( m,  n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe int _core_xdebugi2sum(int[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_ser_xdebugi2sum(&_s_errormsg, &_d_result, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugi2sum' call");
            }
            result = _d_result.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static int xdebugi2sum(int[,] a)
    {
    int result = _core_xdebugi2sum( a, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_xdebugi2neg(ref int[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_ser_xdebugi2neg(&_s_errormsg, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugi2neg' call");
            }
            x_matrix_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugi2neg(ref int[,] a)
    {
    _core_xdebugi2neg(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugi2transpose(ref int[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_from_array(ref _d_a, a, X_CREATE);
            _error_code = _i_ser_xdebugi2transpose(&_s_errormsg, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugi2transpose' call");
            }
            x_matrix_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugi2transpose(ref int[,] a)
    {
    _core_xdebugi2transpose(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugi2outsin(int m, int n, out int[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_INT);
            a = null;
            _error_code = _i_ser_xdebugi2outsin(&_s_errormsg, &_d_m, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugi2outsin' call");
            }
            x_matrix_to_array(ref _d_a, ref a);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugi2outsin(int m, int n, out int[,] a)
    {
    _core_xdebugi2outsin( m,  n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe double _core_xdebugr2sum(double[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugr2sum(&_s_errormsg, &_d_result, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugr2sum' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double xdebugr2sum(double[,] a)
    {
    double result = _core_xdebugr2sum( a, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_xdebugr2neg(ref double[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugr2neg(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugr2neg' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugr2neg(ref double[,] a)
    {
    _core_xdebugr2neg(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugr2transpose(ref double[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugr2transpose(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugr2transpose' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugr2transpose(ref double[,] a)
    {
    _core_xdebugr2transpose(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugr2outsin(int m, int n, out double[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_ser_xdebugr2outsin(&_s_errormsg, &_d_m, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugr2outsin' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugr2outsin(int m, int n, out double[,] a)
    {
    _core_xdebugr2outsin( m,  n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe complex _core_xdebugc2sum(complex[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        alglib.complex result;
        alglib.complex _d_result;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                _d_result.x = 0;
                _d_result.y = 0;
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugc2sum(&_s_errormsg, &_d_result, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugc2sum' call");
            }
            result.x = _d_result.x;
            result.y = _d_result.y;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static alglib.complex xdebugc2sum(complex[,] a)
    {
    alglib.complex result = _core_xdebugc2sum( a, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_xdebugc2neg(ref complex[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugc2neg(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugc2neg' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugc2neg(ref complex[,] a)
    {
    _core_xdebugc2neg(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugc2transpose(ref complex[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_xdebugc2transpose(&_s_errormsg, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugc2transpose' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugc2transpose(ref complex[,] a)
    {
    _core_xdebugc2transpose(ref  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_xdebugc2outsincos(int m, int n, out complex[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_ser_xdebugc2outsincos(&_s_errormsg, &_d_m, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugc2outsincos' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void xdebugc2outsincos(int m, int n, out complex[,] a)
    {
    _core_xdebugc2outsincos( m,  n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe double _core_xdebugmaskedbiasedproductsum(int m, int n, double[,] a, double[,] b, bool[,] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_matrix _d_b = new x_matrix();
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){fixed(bool* _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                _error_code = _i_ser_xdebugmaskedbiasedproductsum(&_s_errormsg, &_d_result, &_d_m, &_d_n, &_d_a, &_d_b, &_d_c);
            }}
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'xdebugmaskedbiasedproductsum' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_matrix_clear(ref _d_c);
        }
        return result;
    }
    public static double xdebugmaskedbiasedproductsum(int m, int n, double[,] a, double[,] b, bool[,] c)
    {
    double result = _core_xdebugmaskedbiasedproductsum( m,  n,  a,  b,  c, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage ablas
    //
    
    private static unsafe void _core_cmatrixtranspose(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_ser_cmatrixtranspose(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_b, &_d_ib, &_d_jb);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixtranspose' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void cmatrixtranspose(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb)
    {
    _core_cmatrixtranspose( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixtranspose(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_ser_rmatrixtranspose(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_b, &_d_ib, &_d_jb);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixtranspose' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void rmatrixtranspose(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb)
    {
    _core_rmatrixtranspose( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixenforcesymmetricity(ref double[,] a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_rmatrixenforcesymmetricity(&_s_errormsg, &_d_a, &_d_n, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixenforcesymmetricity' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void rmatrixenforcesymmetricity(ref double[,] a, int n, bool isupper)
    {
    _core_rmatrixenforcesymmetricity(ref  a,  n,  isupper, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixcopy(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_ser_cmatrixcopy(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_b, &_d_ib, &_d_jb);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixcopy' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void cmatrixcopy(int m, int n, complex[,] a, int ia, int ja, ref complex[,] b, int ib, int jb)
    {
    _core_cmatrixcopy( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixcopy(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_ser_rmatrixcopy(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_b, &_d_ib, &_d_jb);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixcopy' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void rmatrixcopy(int m, int n, double[,] a, int ia, int ja, ref double[,] b, int ib, int jb)
    {
    _core_rmatrixcopy( m,  n,  a,  ia,  ja, ref  b,  ib,  jb, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixrank1(int m, int n, ref complex[,] a, int ia, int ja, ref complex[] u, int iu, ref complex[] v, int iv, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_vector _d_u = new x_vector();
        x_int _d_iu = new x_int(iu);
        x_vector _d_v = new x_vector();
        x_int _d_iv = new x_int(iv);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_u = u, _fp_v = v){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_ser_cmatrixrank1(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_u, &_d_iu, &_d_v, &_d_iv);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixrank1' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            if( _d_u.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_u, ref u);
            if( u == null )
                u = new alglib.complex[0];
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_v, ref v);
            if( v == null )
                v = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    public static void cmatrixrank1(int m, int n, ref complex[,] a, int ia, int ja, ref complex[] u, int iu, ref complex[] v, int iv)
    {
    _core_cmatrixrank1( m,  n, ref  a,  ia,  ja, ref  u,  iu, ref  v,  iv, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixrank1(int m, int n, ref double[,] a, int ia, int ja, ref double[] u, int iu, ref double[] v, int iv, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_vector _d_u = new x_vector();
        x_int _d_iu = new x_int(iu);
        x_vector _d_v = new x_vector();
        x_int _d_iv = new x_int(iv);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_u = u, _fp_v = v){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_ser_rmatrixrank1(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_u, &_d_iu, &_d_v, &_d_iv);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixrank1' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_u.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_u, ref u);
            if( u == null )
                u = new double[0];
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    public static void rmatrixrank1(int m, int n, ref double[,] a, int ia, int ja, ref double[] u, int iu, ref double[] v, int iv)
    {
    _core_rmatrixrank1( m,  n, ref  a,  ia,  ja, ref  u,  iu, ref  v,  iv, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixmv(int m, int n, complex[,] a, int ia, int ja, int opa, complex[] x, int ix, ref complex[] y, int iy, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_opa = new x_int(opa);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        x_vector _d_y = new x_vector();
        x_int _d_iy = new x_int(iy);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_cmatrixmv(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_opa, &_d_x, &_d_ix, &_d_y, &_d_iy);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixmv' call");
            }
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void cmatrixmv(int m, int n, complex[,] a, int ia, int ja, int opa, complex[] x, int ix, ref complex[] y, int iy)
    {
    _core_cmatrixmv( m,  n,  a,  ia,  ja,  opa,  x,  ix, ref  y,  iy, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixmv(int m, int n, double[,] a, int ia, int ja, int opa, double[] x, int ix, ref double[] y, int iy, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_opa = new x_int(opa);
        x_vector _d_x = new x_vector();
        x_int _d_ix = new x_int(ix);
        x_vector _d_y = new x_vector();
        x_int _d_iy = new x_int(iy);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_rmatrixmv(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_ia, &_d_ja, &_d_opa, &_d_x, &_d_ix, &_d_y, &_d_iy);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixmv' call");
            }
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void rmatrixmv(int m, int n, double[,] a, int ia, int ja, int opa, double[] x, int ix, ref double[] y, int iy)
    {
    _core_rmatrixmv( m,  n,  a,  ia,  ja,  opa,  x,  ix, ref  y,  iy, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixrighttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_i1 = new x_int(i1);
        x_int _d_j1 = new x_int(j1);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_matrix _d_x = new x_matrix();
        x_int _d_i2 = new x_int(i2);
        x_int _d_j2 = new x_int(j2);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixrighttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2);
                else    _error_code = _i_smp_cmatrixrighttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixrighttrsm' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void cmatrixrighttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
    {
    _core_cmatrixrighttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixrighttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
    {
    _core_cmatrixrighttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixlefttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_i1 = new x_int(i1);
        x_int _d_j1 = new x_int(j1);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_matrix _d_x = new x_matrix();
        x_int _d_i2 = new x_int(i2);
        x_int _d_j2 = new x_int(j2);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixlefttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2);
                else    _error_code = _i_smp_cmatrixlefttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlefttrsm' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void cmatrixlefttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
    {
    _core_cmatrixlefttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixlefttrsm(int m, int n, complex[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref complex[,] x, int i2, int j2)
    {
    _core_cmatrixlefttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixrighttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_i1 = new x_int(i1);
        x_int _d_j1 = new x_int(j1);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_matrix _d_x = new x_matrix();
        x_int _d_i2 = new x_int(i2);
        x_int _d_j2 = new x_int(j2);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixrighttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2);
                else    _error_code = _i_smp_rmatrixrighttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixrighttrsm' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixrighttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
    {
    _core_rmatrixrighttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixrighttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
    {
    _core_rmatrixrighttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixlefttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        x_int _d_i1 = new x_int(i1);
        x_int _d_j1 = new x_int(j1);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_matrix _d_x = new x_matrix();
        x_int _d_i2 = new x_int(i2);
        x_int _d_j2 = new x_int(j2);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_x = x){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixlefttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2);
                else    _error_code = _i_smp_rmatrixlefttrsm(&_s_errormsg, &_d_m, &_d_n, &_d_a, &_d_i1, &_d_j1, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_i2, &_d_j2);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlefttrsm' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixlefttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
    {
    _core_rmatrixlefttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixlefttrsm(int m, int n, double[,] a, int i1, int j1, bool isupper, bool isunit, int optype, ref double[,] x, int i2, int j2)
    {
    _core_rmatrixlefttrsm( m,  n,  a,  i1,  j1,  isupper,  isunit,  optype, ref  x,  i2,  j2, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixherk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        double _d_beta = beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixherk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper);
                else    _error_code = _i_smp_cmatrixherk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixherk' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void cmatrixherk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper)
    {
    _core_cmatrixherk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixherk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper)
    {
    _core_cmatrixherk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixsyrk(int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double beta, ref double[,] c, int ic, int jc, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        double _d_beta = beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixsyrk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper);
                else    _error_code = _i_smp_rmatrixsyrk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixsyrk' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void rmatrixsyrk(int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double beta, ref double[,] c, int ic, int jc, bool isupper)
    {
    _core_rmatrixsyrk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixsyrk(int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double beta, ref double[,] c, int ic, int jc, bool isupper)
    {
    _core_rmatrixsyrk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixgemm(int m, int n, int k, complex alpha, complex[,] a, int ia, int ja, int optypea, complex[,] b, int ib, int jb, int optypeb, complex beta, ref complex[,] c, int ic, int jc, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        alglib.complex _d_alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        x_int _d_optypeb = new x_int(optypeb);
        alglib.complex _d_beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b, _fp_c = c){
                _d_alpha.x = alpha.x;
                _d_alpha.y = alpha.y;
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _d_beta.x = beta.x;
                _d_beta.y = beta.y;
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixgemm(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_b, &_d_ib, &_d_jb, &_d_optypeb, &_d_beta, &_d_c, &_d_ic, &_d_jc);
                else    _error_code = _i_smp_cmatrixgemm(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_b, &_d_ib, &_d_jb, &_d_optypeb, &_d_beta, &_d_c, &_d_ic, &_d_jc);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixgemm' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void cmatrixgemm(int m, int n, int k, complex alpha, complex[,] a, int ia, int ja, int optypea, complex[,] b, int ib, int jb, int optypeb, complex beta, ref complex[,] c, int ic, int jc)
    {
    _core_cmatrixgemm( m,  n,  k,  alpha,  a,  ia,  ja,  optypea,  b,  ib,  jb,  optypeb,  beta, ref  c,  ic,  jc, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixgemm(int m, int n, int k, complex alpha, complex[,] a, int ia, int ja, int optypea, complex[,] b, int ib, int jb, int optypeb, complex beta, ref complex[,] c, int ic, int jc)
    {
    _core_cmatrixgemm( m,  n,  k,  alpha,  a,  ia,  ja,  optypea,  b,  ib,  jb,  optypeb,  beta, ref  c,  ic,  jc, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixgemm(int m, int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double[,] b, int ib, int jb, int optypeb, double beta, ref double[,] c, int ic, int jc, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        x_matrix _d_b = new x_matrix();
        x_int _d_ib = new x_int(ib);
        x_int _d_jb = new x_int(jb);
        x_int _d_optypeb = new x_int(optypeb);
        double _d_beta = beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b, _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixgemm(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_b, &_d_ib, &_d_jb, &_d_optypeb, &_d_beta, &_d_c, &_d_ic, &_d_jc);
                else    _error_code = _i_smp_rmatrixgemm(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_b, &_d_ib, &_d_jb, &_d_optypeb, &_d_beta, &_d_c, &_d_ic, &_d_jc);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixgemm' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void rmatrixgemm(int m, int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double[,] b, int ib, int jb, int optypeb, double beta, ref double[,] c, int ic, int jc)
    {
    _core_rmatrixgemm( m,  n,  k,  alpha,  a,  ia,  ja,  optypea,  b,  ib,  jb,  optypeb,  beta, ref  c,  ic,  jc, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixgemm(int m, int n, int k, double alpha, double[,] a, int ia, int ja, int optypea, double[,] b, int ib, int jb, int optypeb, double beta, ref double[,] c, int ic, int jc)
    {
    _core_rmatrixgemm( m,  n,  k,  alpha,  a,  ia,  ja,  optypea,  b,  ib,  jb,  optypeb,  beta, ref  c,  ic,  jc, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixsyrk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        double _d_alpha = alpha;
        x_matrix _d_a = new x_matrix();
        x_int _d_ia = new x_int(ia);
        x_int _d_ja = new x_int(ja);
        x_int _d_optypea = new x_int(optypea);
        double _d_beta = beta;
        x_matrix _d_c = new x_matrix();
        x_int _d_ic = new x_int(ic);
        x_int _d_jc = new x_int(jc);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_c = c){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixsyrk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper);
                else    _error_code = _i_smp_cmatrixsyrk(&_s_errormsg, &_d_n, &_d_k, &_d_alpha, &_d_a, &_d_ia, &_d_ja, &_d_optypea, &_d_beta, &_d_c, &_d_ic, &_d_jc, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixsyrk' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void cmatrixsyrk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper)
    {
    _core_cmatrixsyrk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixsyrk(int n, int k, double alpha, complex[,] a, int ia, int ja, int optypea, double beta, ref complex[,] c, int ic, int jc, bool isupper)
    {
    _core_cmatrixsyrk( n,  k,  alpha,  a,  ia,  ja,  optypea,  beta, ref  c,  ic,  jc,  isupper, alglibmode.parallel);
    return;
    }
    
    
    //
    // Subpackage basestat
    //
    
    private static unsafe void _core_samplemoments(double[] x, int n, out double mean, out double variance, out double skewness, out double kurtosis, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_mean = 0;
        double _d_variance = 0;
        double _d_skewness = 0;
        double _d_kurtosis = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_samplemoments(&_s_errormsg, &_d_x, &_d_n, &_d_mean, &_d_variance, &_d_skewness, &_d_kurtosis);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'samplemoments' call");
            }
            mean = _d_mean;
            variance = _d_variance;
            skewness = _d_skewness;
            kurtosis = _d_kurtosis;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void samplemoments(double[] x, int n, out double mean, out double variance, out double skewness, out double kurtosis)
    {
    _core_samplemoments( x,  n, out  mean, out  variance, out  skewness, out  kurtosis, alglibmode.serial);
    return;
    }
    public static void samplemoments(double[] x, out double mean, out double variance, out double skewness, out double kurtosis)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_samplemoments( x,  n, out  mean, out  variance, out  skewness, out  kurtosis, alglibmode.serial);
    
    return;
    }
    private static unsafe double _core_samplemean(double[] x, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_samplemean(&_s_errormsg, &_d_result, &_d_x, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'samplemean' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double samplemean(double[] x, int n)
    {
    double result = _core_samplemean( x,  n, alglibmode.serial);
    return result;
    }
    public static double samplemean(double[] x)
    {
    int n;
    
    
    n = ap.len(x);
    
    double result = _core_samplemean( x,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_samplevariance(double[] x, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_samplevariance(&_s_errormsg, &_d_result, &_d_x, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'samplevariance' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double samplevariance(double[] x, int n)
    {
    double result = _core_samplevariance( x,  n, alglibmode.serial);
    return result;
    }
    public static double samplevariance(double[] x)
    {
    int n;
    
    
    n = ap.len(x);
    
    double result = _core_samplevariance( x,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_sampleskewness(double[] x, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_sampleskewness(&_s_errormsg, &_d_result, &_d_x, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sampleskewness' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double sampleskewness(double[] x, int n)
    {
    double result = _core_sampleskewness( x,  n, alglibmode.serial);
    return result;
    }
    public static double sampleskewness(double[] x)
    {
    int n;
    
    
    n = ap.len(x);
    
    double result = _core_sampleskewness( x,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_samplekurtosis(double[] x, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_samplekurtosis(&_s_errormsg, &_d_result, &_d_x, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'samplekurtosis' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double samplekurtosis(double[] x, int n)
    {
    double result = _core_samplekurtosis( x,  n, alglibmode.serial);
    return result;
    }
    public static double samplekurtosis(double[] x)
    {
    int n;
    
    
    n = ap.len(x);
    
    double result = _core_samplekurtosis( x,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe void _core_sampleadev(double[] x, int n, out double adev, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_adev = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_sampleadev(&_s_errormsg, &_d_x, &_d_n, &_d_adev);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sampleadev' call");
            }
            adev = _d_adev;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void sampleadev(double[] x, int n, out double adev)
    {
    _core_sampleadev( x,  n, out  adev, alglibmode.serial);
    return;
    }
    public static void sampleadev(double[] x, out double adev)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_sampleadev( x,  n, out  adev, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_samplemedian(double[] x, int n, out double median, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_median = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_samplemedian(&_s_errormsg, &_d_x, &_d_n, &_d_median);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'samplemedian' call");
            }
            median = _d_median;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void samplemedian(double[] x, int n, out double median)
    {
    _core_samplemedian( x,  n, out  median, alglibmode.serial);
    return;
    }
    public static void samplemedian(double[] x, out double median)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_samplemedian( x,  n, out  median, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_samplepercentile(double[] x, int n, double p, out double v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_p = p;
        double _d_v = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_samplepercentile(&_s_errormsg, &_d_x, &_d_n, &_d_p, &_d_v);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'samplepercentile' call");
            }
            v = _d_v;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void samplepercentile(double[] x, int n, double p, out double v)
    {
    _core_samplepercentile( x,  n,  p, out  v, alglibmode.serial);
    return;
    }
    public static void samplepercentile(double[] x, double p, out double v)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_samplepercentile( x,  n,  p, out  v, alglibmode.serial);
    
    return;
    }
    private static unsafe double _core_cov2(double[] x, double[] y, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_cov2(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cov2' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    public static double cov2(double[] x, double[] y, int n)
    {
    double result = _core_cov2( x,  y,  n, alglibmode.serial);
    return result;
    }
    public static double cov2(double[] x, double[] y)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'cov2': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    double result = _core_cov2( x,  y,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_pearsoncorr2(double[] x, double[] y, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_pearsoncorr2(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pearsoncorr2' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    public static double pearsoncorr2(double[] x, double[] y, int n)
    {
    double result = _core_pearsoncorr2( x,  y,  n, alglibmode.serial);
    return result;
    }
    public static double pearsoncorr2(double[] x, double[] y)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'pearsoncorr2': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    double result = _core_pearsoncorr2( x,  y,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_spearmancorr2(double[] x, double[] y, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_spearmancorr2(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spearmancorr2' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    public static double spearmancorr2(double[] x, double[] y, int n)
    {
    double result = _core_spearmancorr2( x,  y,  n, alglibmode.serial);
    return result;
    }
    public static double spearmancorr2(double[] x, double[] y)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spearmancorr2': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    double result = _core_spearmancorr2( x,  y,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe void _core_covm(double[,] x, int n, int m, out double[,] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_covm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c);
                else    _error_code = _i_smp_covm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'covm' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void covm(double[,] x, int n, int m, out double[,] c)
    {
    _core_covm( x,  n,  m, out  c, alglibmode.serial);
    return;
    }
    public static void covm(double[,] x, out double[,] c)
    {
    int n;
    int m;
    
    
    n = ap.rows(x);
    m = ap.cols(x);
    
    _core_covm( x,  n,  m, out  c, alglibmode.serial);
    
    return;
    }
    public static void smp_covm(double[,] x, int n, int m, out double[,] c)
    {
    _core_covm( x,  n,  m, out  c, alglibmode.parallel);
    return;
    }
    public static void smp_covm(double[,] x, out double[,] c)
    {
    int n;
    int m;
    
    
    n = ap.rows(x);
    m = ap.cols(x);
    
    _core_covm( x,  n,  m, out  c, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_pearsoncorrm(double[,] x, int n, int m, out double[,] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_pearsoncorrm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c);
                else    _error_code = _i_smp_pearsoncorrm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pearsoncorrm' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void pearsoncorrm(double[,] x, int n, int m, out double[,] c)
    {
    _core_pearsoncorrm( x,  n,  m, out  c, alglibmode.serial);
    return;
    }
    public static void pearsoncorrm(double[,] x, out double[,] c)
    {
    int n;
    int m;
    
    
    n = ap.rows(x);
    m = ap.cols(x);
    
    _core_pearsoncorrm( x,  n,  m, out  c, alglibmode.serial);
    
    return;
    }
    public static void smp_pearsoncorrm(double[,] x, int n, int m, out double[,] c)
    {
    _core_pearsoncorrm( x,  n,  m, out  c, alglibmode.parallel);
    return;
    }
    public static void smp_pearsoncorrm(double[,] x, out double[,] c)
    {
    int n;
    int m;
    
    
    n = ap.rows(x);
    m = ap.cols(x);
    
    _core_pearsoncorrm( x,  n,  m, out  c, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spearmancorrm(double[,] x, int n, int m, out double[,] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spearmancorrm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c);
                else    _error_code = _i_smp_spearmancorrm(&_s_errormsg, &_d_x, &_d_n, &_d_m, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spearmancorrm' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void spearmancorrm(double[,] x, int n, int m, out double[,] c)
    {
    _core_spearmancorrm( x,  n,  m, out  c, alglibmode.serial);
    return;
    }
    public static void spearmancorrm(double[,] x, out double[,] c)
    {
    int n;
    int m;
    
    
    n = ap.rows(x);
    m = ap.cols(x);
    
    _core_spearmancorrm( x,  n,  m, out  c, alglibmode.serial);
    
    return;
    }
    public static void smp_spearmancorrm(double[,] x, int n, int m, out double[,] c)
    {
    _core_spearmancorrm( x,  n,  m, out  c, alglibmode.parallel);
    return;
    }
    public static void smp_spearmancorrm(double[,] x, out double[,] c)
    {
    int n;
    int m;
    
    
    n = ap.rows(x);
    m = ap.cols(x);
    
    _core_spearmancorrm( x,  n,  m, out  c, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_covm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_matrix _d_y = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m1 = new x_int(m1);
        x_int _d_m2 = new x_int(m2);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_attach_to_array(ref _d_y, _fp_y, ap.rows(y), ap.cols(y));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_covm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c);
                else    _error_code = _i_smp_covm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'covm2' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_y);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void covm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
    _core_covm2( x,  y,  n,  m1,  m2, out  c, alglibmode.serial);
    return;
    }
    public static void covm2(double[,] x, double[,] y, out double[,] c)
    {
    int n;
    int m1;
    int m2;
    
    if( (ap.rows(x)!=ap.rows(y)))
        throw new alglibexception("Error while calling 'covm2': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m1 = ap.cols(x);
    m2 = ap.cols(y);
    
    _core_covm2( x,  y,  n,  m1,  m2, out  c, alglibmode.serial);
    
    return;
    }
    public static void smp_covm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
    _core_covm2( x,  y,  n,  m1,  m2, out  c, alglibmode.parallel);
    return;
    }
    public static void smp_covm2(double[,] x, double[,] y, out double[,] c)
    {
    int n;
    int m1;
    int m2;
    
    if( (ap.rows(x)!=ap.rows(y)))
        throw new alglibexception("Error while calling 'covm2': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m1 = ap.cols(x);
    m2 = ap.cols(y);
    
    _core_covm2( x,  y,  n,  m1,  m2, out  c, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_pearsoncorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_matrix _d_y = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m1 = new x_int(m1);
        x_int _d_m2 = new x_int(m2);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_attach_to_array(ref _d_y, _fp_y, ap.rows(y), ap.cols(y));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_pearsoncorrm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c);
                else    _error_code = _i_smp_pearsoncorrm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pearsoncorrm2' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_y);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void pearsoncorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
    _core_pearsoncorrm2( x,  y,  n,  m1,  m2, out  c, alglibmode.serial);
    return;
    }
    public static void pearsoncorrm2(double[,] x, double[,] y, out double[,] c)
    {
    int n;
    int m1;
    int m2;
    
    if( (ap.rows(x)!=ap.rows(y)))
        throw new alglibexception("Error while calling 'pearsoncorrm2': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m1 = ap.cols(x);
    m2 = ap.cols(y);
    
    _core_pearsoncorrm2( x,  y,  n,  m1,  m2, out  c, alglibmode.serial);
    
    return;
    }
    public static void smp_pearsoncorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
    _core_pearsoncorrm2( x,  y,  n,  m1,  m2, out  c, alglibmode.parallel);
    return;
    }
    public static void smp_pearsoncorrm2(double[,] x, double[,] y, out double[,] c)
    {
    int n;
    int m1;
    int m2;
    
    if( (ap.rows(x)!=ap.rows(y)))
        throw new alglibexception("Error while calling 'pearsoncorrm2': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m1 = ap.cols(x);
    m2 = ap.cols(y);
    
    _core_pearsoncorrm2( x,  y,  n,  m1,  m2, out  c, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spearmancorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_matrix _d_y = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m1 = new x_int(m1);
        x_int _d_m2 = new x_int(m2);
        x_matrix _d_c = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_attach_to_array(ref _d_y, _fp_y, ap.rows(y), ap.cols(y));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spearmancorrm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c);
                else    _error_code = _i_smp_spearmancorrm2(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m1, &_d_m2, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spearmancorrm2' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_y);
            x_matrix_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void spearmancorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
    _core_spearmancorrm2( x,  y,  n,  m1,  m2, out  c, alglibmode.serial);
    return;
    }
    public static void spearmancorrm2(double[,] x, double[,] y, out double[,] c)
    {
    int n;
    int m1;
    int m2;
    
    if( (ap.rows(x)!=ap.rows(y)))
        throw new alglibexception("Error while calling 'spearmancorrm2': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m1 = ap.cols(x);
    m2 = ap.cols(y);
    
    _core_spearmancorrm2( x,  y,  n,  m1,  m2, out  c, alglibmode.serial);
    
    return;
    }
    public static void smp_spearmancorrm2(double[,] x, double[,] y, int n, int m1, int m2, out double[,] c)
    {
    _core_spearmancorrm2( x,  y,  n,  m1,  m2, out  c, alglibmode.parallel);
    return;
    }
    public static void smp_spearmancorrm2(double[,] x, double[,] y, out double[,] c)
    {
    int n;
    int m1;
    int m2;
    
    if( (ap.rows(x)!=ap.rows(y)))
        throw new alglibexception("Error while calling 'spearmancorrm2': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m1 = ap.cols(x);
    m2 = ap.cols(y);
    
    _core_spearmancorrm2( x,  y,  n,  m1,  m2, out  c, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_rankdata(ref double[,] xy, int npoints, int nfeatures, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nfeatures = new x_int(nfeatures);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rankdata(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures);
                else    _error_code = _i_smp_rankdata(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rankdata' call");
            }
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void rankdata(ref double[,] xy, int npoints, int nfeatures)
    {
    _core_rankdata(ref  xy,  npoints,  nfeatures, alglibmode.serial);
    return;
    }
    public static void rankdata(ref double[,] xy)
    {
    int npoints;
    int nfeatures;
    
    
    npoints = ap.rows(xy);
    nfeatures = ap.cols(xy);
    
    _core_rankdata(ref  xy,  npoints,  nfeatures, alglibmode.serial);
    
    return;
    }
    public static void smp_rankdata(ref double[,] xy, int npoints, int nfeatures)
    {
    _core_rankdata(ref  xy,  npoints,  nfeatures, alglibmode.parallel);
    return;
    }
    public static void smp_rankdata(ref double[,] xy)
    {
    int npoints;
    int nfeatures;
    
    
    npoints = ap.rows(xy);
    nfeatures = ap.cols(xy);
    
    _core_rankdata(ref  xy,  npoints,  nfeatures, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_rankdatacentered(ref double[,] xy, int npoints, int nfeatures, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nfeatures = new x_int(nfeatures);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rankdatacentered(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures);
                else    _error_code = _i_smp_rankdatacentered(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rankdatacentered' call");
            }
            if( _d_xy.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xy, ref xy);
            if( xy == null )
                xy = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void rankdatacentered(ref double[,] xy, int npoints, int nfeatures)
    {
    _core_rankdatacentered(ref  xy,  npoints,  nfeatures, alglibmode.serial);
    return;
    }
    public static void rankdatacentered(ref double[,] xy)
    {
    int npoints;
    int nfeatures;
    
    
    npoints = ap.rows(xy);
    nfeatures = ap.cols(xy);
    
    _core_rankdatacentered(ref  xy,  npoints,  nfeatures, alglibmode.serial);
    
    return;
    }
    public static void smp_rankdatacentered(ref double[,] xy, int npoints, int nfeatures)
    {
    _core_rankdatacentered(ref  xy,  npoints,  nfeatures, alglibmode.parallel);
    return;
    }
    public static void smp_rankdatacentered(ref double[,] xy)
    {
    int npoints;
    int nfeatures;
    
    
    npoints = ap.rows(xy);
    nfeatures = ap.cols(xy);
    
    _core_rankdatacentered(ref  xy,  npoints,  nfeatures, alglibmode.parallel);
    
    return;
    }
    private static unsafe double _core_pearsoncorrelation(double[] x, double[] y, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_pearsoncorrelation(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pearsoncorrelation' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    public static double pearsoncorrelation(double[] x, double[] y, int n)
    {
    double result = _core_pearsoncorrelation( x,  y,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_spearmanrankcorrelation(double[] x, double[] y, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_spearmanrankcorrelation(&_s_errormsg, &_d_result, &_d_x, &_d_y, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spearmanrankcorrelation' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        return result;
    }
    public static double spearmanrankcorrelation(double[] x, double[] y, int n)
    {
    double result = _core_spearmanrankcorrelation( x,  y,  n, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage bdss
    //
    
    private static unsafe void _core_dsoptimalsplit2(double[] a, int[] c, int n, out int info, out double threshold, out double pal, out double pbl, out double par, out double pbr, out double cve, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        double _d_threshold = 0;
        double _d_pal = 0;
        double _d_pbl = 0;
        double _d_par = 0;
        double _d_pbr = 0;
        double _d_cve = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_from_array(ref _d_c, c, X_CREATE);
                _error_code = _i_ser_dsoptimalsplit2(&_s_errormsg, &_d_a, &_d_c, &_d_n, &_d_info, &_d_threshold, &_d_pal, &_d_pbl, &_d_par, &_d_pbr, &_d_cve);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dsoptimalsplit2' call");
            }
            info = _d_info.intval;
            threshold = _d_threshold;
            pal = _d_pal;
            pbl = _d_pbl;
            par = _d_par;
            pbr = _d_pbr;
            cve = _d_cve;
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void dsoptimalsplit2(double[] a, int[] c, int n, out int info, out double threshold, out double pal, out double pbl, out double par, out double pbr, out double cve)
    {
    _core_dsoptimalsplit2( a,  c,  n, out  info, out  threshold, out  pal, out  pbl, out  par, out  pbr, out  cve, alglibmode.serial);
    return;
    }
    private static unsafe void _core_dsoptimalsplit2fast(ref double[] a, ref int[] c, ref int[] tiesbuf, ref int[] cntbuf, ref double[] bufr, ref int[] bufi, int n, int nc, double alpha, out int info, out double threshold, out double rms, out double cvrms, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_vector _d_c = new x_vector();
        x_vector _d_tiesbuf = new x_vector();
        x_vector _d_cntbuf = new x_vector();
        x_vector _d_bufr = new x_vector();
        x_vector _d_bufi = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_nc = new x_int(nc);
        double _d_alpha = alpha;
        x_int _d_info = new x_int();
        double _d_threshold = 0;
        double _d_rms = 0;
        double _d_cvrms = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_bufr = bufr){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_from_array(ref _d_c, c, X_CREATE);
                x_vector_from_array(ref _d_tiesbuf, tiesbuf, X_CREATE);
                x_vector_from_array(ref _d_cntbuf, cntbuf, X_CREATE);
                x_vector_attach_to_array(ref _d_bufr, _fp_bufr, ap.len(bufr));
                x_vector_from_array(ref _d_bufi, bufi, X_CREATE);
                _error_code = _i_ser_dsoptimalsplit2fast(&_s_errormsg, &_d_a, &_d_c, &_d_tiesbuf, &_d_cntbuf, &_d_bufr, &_d_bufi, &_d_n, &_d_nc, &_d_alpha, &_d_info, &_d_threshold, &_d_rms, &_d_cvrms);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dsoptimalsplit2fast' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
            x_vector_to_array(ref _d_c, ref c);
            x_vector_to_array(ref _d_tiesbuf, ref tiesbuf);
            x_vector_to_array(ref _d_cntbuf, ref cntbuf);
            if( _d_bufr.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_bufr, ref bufr);
            if( bufr == null )
                bufr = new double[0];
            x_vector_to_array(ref _d_bufi, ref bufi);
            info = _d_info.intval;
            threshold = _d_threshold;
            rms = _d_rms;
            cvrms = _d_cvrms;
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_c);
            x_vector_clear(ref _d_tiesbuf);
            x_vector_clear(ref _d_cntbuf);
            x_vector_clear(ref _d_bufr);
            x_vector_clear(ref _d_bufi);
        }
        // This function returns no value.
    }
    public static void dsoptimalsplit2fast(ref double[] a, ref int[] c, ref int[] tiesbuf, ref int[] cntbuf, ref double[] bufr, ref int[] bufi, int n, int nc, double alpha, out int info, out double threshold, out double rms, out double cvrms)
    {
    _core_dsoptimalsplit2fast(ref  a, ref  c, ref  tiesbuf, ref  cntbuf, ref  bufr, ref  bufi,  n,  nc,  alpha, out  info, out  threshold, out  rms, out  cvrms, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage clustering
    //
    

    public unsafe class clusterizerstate : alglibobject
    {
        public void *ptr;
        public clusterizerstate(void *x)
        {
            ptr = x;
        }
        ~clusterizerstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new clusterizerstate(null);
            return new clusterizerstate(_i_x_obj_copy_clusterizerstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_clusterizerstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_clusterizerstate(void *x);
    private static _d_x_obj_copy_clusterizerstate _i_x_obj_copy_clusterizerstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_clusterizerstate(void *x);
    private static _d_x_obj_free_clusterizerstate _i_x_obj_free_clusterizerstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_ahcreport
    {
        public x_int terminationtype;
        public x_int npoints;
        public x_vector p;
        public x_matrix z;
        public x_matrix pz;
        public x_matrix pm;
        public x_vector mergedist;
    }

    public class ahcreport : alglibobject
    {
        public int terminationtype;
        public int npoints;
        public int[] p;
        public int[,] z;
        public int[,] pz;
        public int[,] pm;
        public double[] mergedist;
        public override alglib.alglibobject make_copy()
        {
            ahcreport dst = new ahcreport();
            dst.terminationtype = terminationtype;
            dst.npoints = npoints;
            dst.p = (int[])p.Clone();        dst.z = (int[,])z.Clone();        dst.pz = (int[,])pz.Clone();        dst.pm = (int[,])pm.Clone();        dst.mergedist = (double[])mergedist.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_ahcreport_init(ref x_ahcreport x)
    {
        x.terminationtype.longval = 0;
        x.npoints.longval = 0;
        x_vector_create_empty(ref x.p, DT_INT);
        x_matrix_create_empty(ref x.z, DT_INT);
        x_matrix_create_empty(ref x.pz, DT_INT);
        x_matrix_create_empty(ref x.pm, DT_INT);
        x_vector_create_empty(ref x.mergedist, DT_REAL);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_ahcreport_clear(ref x_ahcreport x)
    {
        x_vector_clear(ref x.p);
        x_matrix_clear(ref x.z);
        x_matrix_clear(ref x.pz);
        x_matrix_clear(ref x.pm);
        x_vector_clear(ref x.mergedist);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_ahcreport_init_from(ref x_ahcreport x, ahcreport v)
    {
        x.terminationtype.longval = v.terminationtype;
        x.npoints.longval = v.npoints;
        x_vector_from_array(ref x.p, v.p, X_CREATE);
        x_matrix_from_array(ref x.z, v.z, X_CREATE);
        x_matrix_from_array(ref x.pz, v.pz, X_CREATE);
        x_matrix_from_array(ref x.pm, v.pm, X_CREATE);
        x_vector_from_array(ref x.mergedist, v.mergedist, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_ahcreport_to_record(ref x_ahcreport x, ref ahcreport v)
    {
        if( v==null )
            v = new ahcreport();
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.npoints = x.npoints.intval; // long is silently truncated to int
        x_vector_to_array(ref x.p, ref v.p);
        x_matrix_to_array(ref x.z, ref v.z);
        x_matrix_to_array(ref x.pz, ref v.pz);
        x_matrix_to_array(ref x.pm, ref v.pm);
        x_vector_to_array(ref x.mergedist, ref v.mergedist);
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_kmeansreport
    {
        public x_int npoints;
        public x_int nfeatures;
        public x_int terminationtype;
        public x_int iterationscount;
        public double energy;
        public x_int k;
        public x_matrix c;
        public x_vector cidx;
    }

    public class kmeansreport : alglibobject
    {
        public int npoints;
        public int nfeatures;
        public int terminationtype;
        public int iterationscount;
        public double energy;
        public int k;
        public double[,] c;
        public int[] cidx;
        public override alglib.alglibobject make_copy()
        {
            kmeansreport dst = new kmeansreport();
            dst.npoints = npoints;
            dst.nfeatures = nfeatures;
            dst.terminationtype = terminationtype;
            dst.iterationscount = iterationscount;
            dst.energy = energy;
            dst.k = k;
            dst.c = (double[,])c.Clone();        dst.cidx = (int[])cidx.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_kmeansreport_init(ref x_kmeansreport x)
    {
        x.npoints.longval = 0;
        x.nfeatures.longval = 0;
        x.terminationtype.longval = 0;
        x.iterationscount.longval = 0;
        x.energy = 0;
        x.k.longval = 0;
        x_matrix_create_empty(ref x.c, DT_REAL);
        x_vector_create_empty(ref x.cidx, DT_INT);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_kmeansreport_clear(ref x_kmeansreport x)
    {
        x_matrix_clear(ref x.c);
        x_vector_clear(ref x.cidx);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_kmeansreport_init_from(ref x_kmeansreport x, kmeansreport v)
    {
        x.npoints.longval = v.npoints;
        x.nfeatures.longval = v.nfeatures;
        x.terminationtype.longval = v.terminationtype;
        x.iterationscount.longval = v.iterationscount;
        x.energy = v.energy;
        x.k.longval = v.k;
        x_matrix_from_array(ref x.c, v.c, X_CREATE);
        x_vector_from_array(ref x.cidx, v.cidx, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_kmeansreport_to_record(ref x_kmeansreport x, ref kmeansreport v)
    {
        if( v==null )
            v = new kmeansreport();
        v.npoints = x.npoints.intval; // long is silently truncated to int
        v.nfeatures = x.nfeatures.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.energy = x.energy;
        v.k = x.k.intval; // long is silently truncated to int
        x_matrix_to_array(ref x.c, ref v.c);
        x_vector_to_array(ref x.cidx, ref v.cidx);
    }
    private static unsafe void _core_clusterizercreate(out clusterizerstate s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_clusterizercreate(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizercreate' call");
            }
            s = new clusterizerstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_clusterizerstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void clusterizercreate(out clusterizerstate s)
    {
    _core_clusterizercreate(out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_clusterizersetpoints(clusterizerstate s, double[,] xy, int npoints, int nfeatures, int disttype, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nfeatures = new x_int(nfeatures);
        x_int _d_disttype = new x_int(disttype);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_clusterizersetpoints(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints, &_d_nfeatures, &_d_disttype);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizersetpoints' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void clusterizersetpoints(clusterizerstate s, double[,] xy, int npoints, int nfeatures, int disttype)
    {
    _core_clusterizersetpoints( s,  xy,  npoints,  nfeatures,  disttype, alglibmode.serial);
    return;
    }
    public static void clusterizersetpoints(clusterizerstate s, double[,] xy, int disttype)
    {
    int npoints;
    int nfeatures;
    
    
    npoints = ap.rows(xy);
    nfeatures = ap.cols(xy);
    
    _core_clusterizersetpoints( s,  xy,  npoints,  nfeatures,  disttype, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_clusterizersetdistances(clusterizerstate s, double[,] d, int npoints, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_d = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_matrix_attach_to_array(ref _d_d, _fp_d, ap.rows(d), ap.cols(d));
                _error_code = _i_ser_clusterizersetdistances(&_s_errormsg, &_d_s, &_d_d, &_d_npoints, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizersetdistances' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_d);
        }
        // This function returns no value.
    }
    public static void clusterizersetdistances(clusterizerstate s, double[,] d, int npoints, bool isupper)
    {
    _core_clusterizersetdistances( s,  d,  npoints,  isupper, alglibmode.serial);
    return;
    }
    public static void clusterizersetdistances(clusterizerstate s, double[,] d, bool isupper)
    {
    int npoints;
    
    if( (ap.rows(d)!=ap.cols(d)))
        throw new alglibexception("Error while calling 'clusterizersetdistances': looks like one of arguments has wrong size");
    
    npoints = ap.rows(d);
    
    _core_clusterizersetdistances( s,  d,  npoints,  isupper, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_clusterizersetahcalgo(clusterizerstate s, int algo, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_algo = new x_int(algo);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_clusterizersetahcalgo(&_s_errormsg, &_d_s, &_d_algo);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizersetahcalgo' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void clusterizersetahcalgo(clusterizerstate s, int algo)
    {
    _core_clusterizersetahcalgo( s,  algo, alglibmode.serial);
    return;
    }
    private static unsafe void _core_clusterizersetkmeanslimits(clusterizerstate s, int restarts, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_clusterizersetkmeanslimits(&_s_errormsg, &_d_s, &_d_restarts, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizersetkmeanslimits' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void clusterizersetkmeanslimits(clusterizerstate s, int restarts, int maxits)
    {
    _core_clusterizersetkmeanslimits( s,  restarts,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_clusterizersetkmeansinit(clusterizerstate s, int initalgo, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_initalgo = new x_int(initalgo);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_clusterizersetkmeansinit(&_s_errormsg, &_d_s, &_d_initalgo);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizersetkmeansinit' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void clusterizersetkmeansinit(clusterizerstate s, int initalgo)
    {
    _core_clusterizersetkmeansinit( s,  initalgo, alglibmode.serial);
    return;
    }
    private static unsafe void _core_clusterizerrunahc(clusterizerstate s, out ahcreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_ahcreport _d_rep = new x_ahcreport();
        
        // Pack, call, unpack
        try
        {
            x_ahcreport_init(ref _d_rep);
            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_clusterizerrunahc(&_s_errormsg, &_d_s, &_d_rep);
            else    _error_code = _i_smp_clusterizerrunahc(&_s_errormsg, &_d_s, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizerrunahc' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_ahcreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_ahcreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void clusterizerrunahc(clusterizerstate s, out ahcreport rep)
    {
    _core_clusterizerrunahc( s, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_clusterizerrunahc(clusterizerstate s, out ahcreport rep)
    {
    _core_clusterizerrunahc( s, out  rep, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_clusterizerrunkmeans(clusterizerstate s, int k, out kmeansreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_k = new x_int(k);
        x_kmeansreport _d_rep = new x_kmeansreport();
        
        // Pack, call, unpack
        try
        {
            x_kmeansreport_init(ref _d_rep);
            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_clusterizerrunkmeans(&_s_errormsg, &_d_s, &_d_k, &_d_rep);
            else    _error_code = _i_smp_clusterizerrunkmeans(&_s_errormsg, &_d_s, &_d_k, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizerrunkmeans' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_kmeansreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_kmeansreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void clusterizerrunkmeans(clusterizerstate s, int k, out kmeansreport rep)
    {
    _core_clusterizerrunkmeans( s,  k, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_clusterizerrunkmeans(clusterizerstate s, int k, out kmeansreport rep)
    {
    _core_clusterizerrunkmeans( s,  k, out  rep, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_clusterizergetdistances(double[,] xy, int npoints, int nfeatures, int disttype, out double[,] d, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nfeatures = new x_int(nfeatures);
        x_int _d_disttype = new x_int(disttype);
        x_matrix _d_d = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_matrix_create_empty(ref _d_d, DT_REAL);
                d = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_clusterizergetdistances(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures, &_d_disttype, &_d_d);
                else    _error_code = _i_smp_clusterizergetdistances(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nfeatures, &_d_disttype, &_d_d);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizergetdistances' call");
            }
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_matrix_clear(ref _d_d);
        }
        // This function returns no value.
    }
    public static void clusterizergetdistances(double[,] xy, int npoints, int nfeatures, int disttype, out double[,] d)
    {
    _core_clusterizergetdistances( xy,  npoints,  nfeatures,  disttype, out  d, alglibmode.serial);
    return;
    }
    public static void smp_clusterizergetdistances(double[,] xy, int npoints, int nfeatures, int disttype, out double[,] d)
    {
    _core_clusterizergetdistances( xy,  npoints,  nfeatures,  disttype, out  d, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_clusterizergetkclusters(ahcreport rep, int k, out int[] cidx, out int[] cz, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_ahcreport _d_rep = new x_ahcreport();
        x_int _d_k = new x_int(k);
        x_vector _d_cidx = new x_vector();
        x_vector _d_cz = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_ahcreport_init_from(ref _d_rep, rep);
            x_vector_create_empty(ref _d_cidx, DT_INT);
            cidx = null;
            x_vector_create_empty(ref _d_cz, DT_INT);
            cz = null;
            _error_code = _i_ser_clusterizergetkclusters(&_s_errormsg, &_d_rep, &_d_k, &_d_cidx, &_d_cz);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizergetkclusters' call");
            }
            x_vector_to_array(ref _d_cidx, ref cidx);
            x_vector_to_array(ref _d_cz, ref cz);
        }
        finally
        {
            x_ahcreport_clear(ref _d_rep);
            x_vector_clear(ref _d_cidx);
            x_vector_clear(ref _d_cz);
        }
        // This function returns no value.
    }
    public static void clusterizergetkclusters(ahcreport rep, int k, out int[] cidx, out int[] cz)
    {
    _core_clusterizergetkclusters( rep,  k, out  cidx, out  cz, alglibmode.serial);
    return;
    }
    private static unsafe void _core_clusterizerseparatedbydist(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_ahcreport _d_rep = new x_ahcreport();
        double _d_r = r;
        x_int _d_k = new x_int();
        x_vector _d_cidx = new x_vector();
        x_vector _d_cz = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_ahcreport_init_from(ref _d_rep, rep);
            x_vector_create_empty(ref _d_cidx, DT_INT);
            cidx = null;
            x_vector_create_empty(ref _d_cz, DT_INT);
            cz = null;
            _error_code = _i_ser_clusterizerseparatedbydist(&_s_errormsg, &_d_rep, &_d_r, &_d_k, &_d_cidx, &_d_cz);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizerseparatedbydist' call");
            }
            k = _d_k.intval;
            x_vector_to_array(ref _d_cidx, ref cidx);
            x_vector_to_array(ref _d_cz, ref cz);
        }
        finally
        {
            x_ahcreport_clear(ref _d_rep);
            x_vector_clear(ref _d_cidx);
            x_vector_clear(ref _d_cz);
        }
        // This function returns no value.
    }
    public static void clusterizerseparatedbydist(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz)
    {
    _core_clusterizerseparatedbydist( rep,  r, out  k, out  cidx, out  cz, alglibmode.serial);
    return;
    }
    private static unsafe void _core_clusterizerseparatedbycorr(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_ahcreport _d_rep = new x_ahcreport();
        double _d_r = r;
        x_int _d_k = new x_int();
        x_vector _d_cidx = new x_vector();
        x_vector _d_cz = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_ahcreport_init_from(ref _d_rep, rep);
            x_vector_create_empty(ref _d_cidx, DT_INT);
            cidx = null;
            x_vector_create_empty(ref _d_cz, DT_INT);
            cz = null;
            _error_code = _i_ser_clusterizerseparatedbycorr(&_s_errormsg, &_d_rep, &_d_r, &_d_k, &_d_cidx, &_d_cz);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'clusterizerseparatedbycorr' call");
            }
            k = _d_k.intval;
            x_vector_to_array(ref _d_cidx, ref cidx);
            x_vector_to_array(ref _d_cz, ref cz);
        }
        finally
        {
            x_ahcreport_clear(ref _d_rep);
            x_vector_clear(ref _d_cidx);
            x_vector_clear(ref _d_cz);
        }
        // This function returns no value.
    }
    public static void clusterizerseparatedbycorr(ahcreport rep, double r, out int k, out int[] cidx, out int[] cz)
    {
    _core_clusterizerseparatedbycorr( rep,  r, out  k, out  cidx, out  cz, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage datacomp
    //
    
    private static unsafe void _core_kmeansgenerate(double[,] xy, int npoints, int nvars, int k, int restarts, out int info, out double[,] c, out int[] xyc, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_k = new x_int(k);
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_matrix _d_c = new x_matrix();
        x_vector _d_xyc = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_matrix_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_vector_create_empty(ref _d_xyc, DT_INT);
                xyc = null;
                _error_code = _i_ser_kmeansgenerate(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_k, &_d_restarts, &_d_info, &_d_c, &_d_xyc);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'kmeansgenerate' call");
            }
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
            x_vector_to_array(ref _d_xyc, ref xyc);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_xyc);
        }
        // This function returns no value.
    }
    public static void kmeansgenerate(double[,] xy, int npoints, int nvars, int k, int restarts, out int info, out double[,] c, out int[] xyc)
    {
    _core_kmeansgenerate( xy,  npoints,  nvars,  k,  restarts, out  info, out  c, out  xyc, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage dforest
    //
    

    public unsafe class decisionforest : alglibobject
    {
        public void *ptr;
        public decisionforest(void *x)
        {
            ptr = x;
        }
        ~decisionforest()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new decisionforest(null);
            return new decisionforest(_i_x_obj_copy_decisionforest(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_decisionforest(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_decisionforest(void *x);
    private static _d_x_obj_copy_decisionforest _i_x_obj_copy_decisionforest = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_decisionforest(void *x);
    private static _d_x_obj_free_decisionforest _i_x_obj_free_decisionforest = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_dfreport
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double oobrelclserror;
        public double oobavgce;
        public double oobrmserror;
        public double oobavgerror;
        public double oobavgrelerror;
    }

    public class dfreport : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double oobrelclserror;
        public double oobavgce;
        public double oobrmserror;
        public double oobavgerror;
        public double oobavgrelerror;
        public override alglib.alglibobject make_copy()
        {
            dfreport dst = new dfreport();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.oobrelclserror = oobrelclserror;
            dst.oobavgce = oobavgce;
            dst.oobrmserror = oobrmserror;
            dst.oobavgerror = oobavgerror;
            dst.oobavgrelerror = oobavgrelerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_dfreport_init(ref x_dfreport x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.oobrelclserror = 0;
        x.oobavgce = 0;
        x.oobrmserror = 0;
        x.oobavgerror = 0;
        x.oobavgrelerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_dfreport_clear(ref x_dfreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_dfreport_init_from(ref x_dfreport x, dfreport v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.oobrelclserror = v.oobrelclserror;
        x.oobavgce = v.oobavgce;
        x.oobrmserror = v.oobrmserror;
        x.oobavgerror = v.oobavgerror;
        x.oobavgrelerror = v.oobavgrelerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_dfreport_to_record(ref x_dfreport x, ref dfreport v)
    {
        if( v==null )
            v = new dfreport();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.oobrelclserror = x.oobrelclserror;
        v.oobavgce = x.oobavgce;
        v.oobrmserror = x.oobrmserror;
        v.oobavgerror = x.oobavgerror;
        v.oobavgrelerror = x.oobavgrelerror;
    }
    public static unsafe void dfserialize(decisionforest obj, out string s_out)
    {
        byte *_error_msg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        int _error_code = _i_x_dfserialize(&_error_msg, &_x, &_out);
        if( _error_code!=X_OK )
            throw new alglibexception(_error_code==X_ASSERTION_FAILED
                ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                : "ALGLIB: unknown error during dfserialize() call");
        s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        x_free((IntPtr)_out);
    }
    
    public static unsafe void dfunserialize(string s_in, out decisionforest obj)
    {
        byte *_error_msg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            int _error_code = _i_x_dfunserialize(&_error_msg, &_in, &_x);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                    : "ALGLIB: unknown error during dfunserialize() call");
            obj = new decisionforest(_x);
        }
    }
    private static unsafe void _core_dfbuildrandomdecisionforest(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, double r, out int info, out decisionforest df, out dfreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_ntrees = new x_int(ntrees);
        double _d_r = r;
        x_int _d_info = new x_int();
        void *_d_df = null;
        df = null;
        x_dfreport _d_rep = new x_dfreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_dfreport_init(ref _d_rep);
                _error_code = _i_ser_dfbuildrandomdecisionforest(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_ntrees, &_d_r, &_d_info, &_d_df, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfbuildrandomdecisionforest' call");
            }
            info = _d_info.intval;
            df = new decisionforest(_d_df);
            rep = null;
            x_dfreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_df!=null && df==null)
                _i_x_obj_free_decisionforest(_d_df); // on exception clean up X objects which were not attached to C# objects
            x_dfreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void dfbuildrandomdecisionforest(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, double r, out int info, out decisionforest df, out dfreport rep)
    {
    _core_dfbuildrandomdecisionforest( xy,  npoints,  nvars,  nclasses,  ntrees,  r, out  info, out  df, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_dfbuildrandomdecisionforestx1(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, int nrndvars, double r, out int info, out decisionforest df, out dfreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_ntrees = new x_int(ntrees);
        x_int _d_nrndvars = new x_int(nrndvars);
        double _d_r = r;
        x_int _d_info = new x_int();
        void *_d_df = null;
        df = null;
        x_dfreport _d_rep = new x_dfreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_dfreport_init(ref _d_rep);
                _error_code = _i_ser_dfbuildrandomdecisionforestx1(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_ntrees, &_d_nrndvars, &_d_r, &_d_info, &_d_df, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfbuildrandomdecisionforestx1' call");
            }
            info = _d_info.intval;
            df = new decisionforest(_d_df);
            rep = null;
            x_dfreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_df!=null && df==null)
                _i_x_obj_free_decisionforest(_d_df); // on exception clean up X objects which were not attached to C# objects
            x_dfreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void dfbuildrandomdecisionforestx1(double[,] xy, int npoints, int nvars, int nclasses, int ntrees, int nrndvars, double r, out int info, out decisionforest df, out dfreport rep)
    {
    _core_dfbuildrandomdecisionforestx1( xy,  npoints,  nvars,  nclasses,  ntrees,  nrndvars,  r, out  info, out  df, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_dfprocess(decisionforest df, double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_df = df.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_dfprocess(&_s_errormsg, &_d_df, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfprocess' call");
            }
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void dfprocess(decisionforest df, double[] x, ref double[] y)
    {
    _core_dfprocess( df,  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_dfprocessi(decisionforest df, double[] x, out double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_df = df.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_ser_dfprocessi(&_s_errormsg, &_d_df, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfprocessi' call");
            }
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void dfprocessi(decisionforest df, double[] x, out double[] y)
    {
    _core_dfprocessi( df,  x, out  y, alglibmode.serial);
    return;
    }
    private static unsafe double _core_dfrelclserror(decisionforest df, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_dfrelclserror(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfrelclserror' call");
            }
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double dfrelclserror(decisionforest df, double[,] xy, int npoints)
    {
    double result = _core_dfrelclserror( df,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_dfavgce(decisionforest df, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_dfavgce(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfavgce' call");
            }
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double dfavgce(decisionforest df, double[,] xy, int npoints)
    {
    double result = _core_dfavgce( df,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_dfrmserror(decisionforest df, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_dfrmserror(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfrmserror' call");
            }
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double dfrmserror(decisionforest df, double[,] xy, int npoints)
    {
    double result = _core_dfrmserror( df,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_dfavgerror(decisionforest df, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_dfavgerror(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfavgerror' call");
            }
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double dfavgerror(decisionforest df, double[,] xy, int npoints)
    {
    double result = _core_dfavgerror( df,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_dfavgrelerror(decisionforest df, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_df = df.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_dfavgrelerror(&_s_errormsg, &_d_result, &_d_df, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dfavgrelerror' call");
            }
            result = _d_result;
            ap.assert(df.ptr==_d_df, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double dfavgrelerror(decisionforest df, double[,] xy, int npoints)
    {
    double result = _core_dfavgrelerror( df,  xy,  npoints, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage gammafunc
    //
    
    private static unsafe double _core_gammafunction(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_gammafunction(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gammafunction' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double gammafunction(double x)
    {
    double result = _core_gammafunction( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_lngamma(double x, out double sgngam, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        double _d_sgngam = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lngamma(&_s_errormsg, &_d_result, &_d_x, &_d_sgngam);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lngamma' call");
            }
            result = _d_result;
            sgngam = _d_sgngam;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double lngamma(double x, out double sgngam)
    {
    double result = _core_lngamma( x, out  sgngam, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage normaldistr
    //
    
    private static unsafe double _core_errorfunction(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_errorfunction(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'errorfunction' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double errorfunction(double x)
    {
    double result = _core_errorfunction( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_errorfunctionc(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_errorfunctionc(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'errorfunctionc' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double errorfunctionc(double x)
    {
    double result = _core_errorfunctionc( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_normaldistribution(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_normaldistribution(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'normaldistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double normaldistribution(double x)
    {
    double result = _core_normaldistribution( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_inverf(double e, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_e = e;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_inverf(&_s_errormsg, &_d_result, &_d_e);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'inverf' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double inverf(double e)
    {
    double result = _core_inverf( e, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_invnormaldistribution(double y0, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_y0 = y0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_invnormaldistribution(&_s_errormsg, &_d_result, &_d_y0);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'invnormaldistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double invnormaldistribution(double y0)
    {
    double result = _core_invnormaldistribution( y0, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage igammaf
    //
    
    private static unsafe double _core_incompletegamma(double a, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_incompletegamma(&_s_errormsg, &_d_result, &_d_a, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'incompletegamma' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double incompletegamma(double a, double x)
    {
    double result = _core_incompletegamma( a,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_incompletegammac(double a, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_incompletegammac(&_s_errormsg, &_d_result, &_d_a, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'incompletegammac' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double incompletegammac(double a, double x)
    {
    double result = _core_incompletegammac( a,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_invincompletegammac(double a, double y0, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_y0 = y0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_invincompletegammac(&_s_errormsg, &_d_result, &_d_a, &_d_y0);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'invincompletegammac' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double invincompletegammac(double a, double y0)
    {
    double result = _core_invincompletegammac( a,  y0, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage ortfac
    //
    
    private static unsafe void _core_rmatrixqr(ref double[,] a, int m, int n, out double[] tau, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_REAL);
                tau = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixqr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau);
                else    _error_code = _i_smp_rmatrixqr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixqr' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    public static void rmatrixqr(ref double[,] a, int m, int n, out double[] tau)
    {
    _core_rmatrixqr(ref  a,  m,  n, out  tau, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixqr(ref double[,] a, int m, int n, out double[] tau)
    {
    _core_rmatrixqr(ref  a,  m,  n, out  tau, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixlq(ref double[,] a, int m, int n, out double[] tau, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_REAL);
                tau = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixlq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau);
                else    _error_code = _i_smp_rmatrixlq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlq' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    public static void rmatrixlq(ref double[,] a, int m, int n, out double[] tau)
    {
    _core_rmatrixlq(ref  a,  m,  n, out  tau, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixlq(ref double[,] a, int m, int n, out double[] tau)
    {
    _core_rmatrixlq(ref  a,  m,  n, out  tau, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixqr(ref complex[,] a, int m, int n, out complex[] tau, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_COMPLEX);
                tau = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixqr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau);
                else    _error_code = _i_smp_cmatrixqr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixqr' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    public static void cmatrixqr(ref complex[,] a, int m, int n, out complex[] tau)
    {
    _core_cmatrixqr(ref  a,  m,  n, out  tau, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixqr(ref complex[,] a, int m, int n, out complex[] tau)
    {
    _core_cmatrixqr(ref  a,  m,  n, out  tau, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixlq(ref complex[,] a, int m, int n, out complex[] tau, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_COMPLEX);
                tau = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixlq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau);
                else    _error_code = _i_smp_cmatrixlq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlq' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    public static void cmatrixlq(ref complex[,] a, int m, int n, out complex[] tau)
    {
    _core_cmatrixlq(ref  a,  m,  n, out  tau, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixlq(ref complex[,] a, int m, int n, out complex[] tau)
    {
    _core_cmatrixlq(ref  a,  m,  n, out  tau, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixqrunpackq(double[,] a, int m, int n, double[] tau, int qcolumns, out double[,] q, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_int _d_qcolumns = new x_int(qcolumns);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixqrunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qcolumns, &_d_q);
                else    _error_code = _i_smp_rmatrixqrunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qcolumns, &_d_q);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixqrunpackq' call");
            }
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    public static void rmatrixqrunpackq(double[,] a, int m, int n, double[] tau, int qcolumns, out double[,] q)
    {
    _core_rmatrixqrunpackq( a,  m,  n,  tau,  qcolumns, out  q, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixqrunpackq(double[,] a, int m, int n, double[] tau, int qcolumns, out double[,] q)
    {
    _core_rmatrixqrunpackq( a,  m,  n,  tau,  qcolumns, out  q, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixqrunpackr(double[,] a, int m, int n, out double[,] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_r = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_ser_rmatrixqrunpackr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixqrunpackr' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void rmatrixqrunpackr(double[,] a, int m, int n, out double[,] r)
    {
    _core_rmatrixqrunpackr( a,  m,  n, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixlqunpackq(double[,] a, int m, int n, double[] tau, int qrows, out double[,] q, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_int _d_qrows = new x_int(qrows);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixlqunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qrows, &_d_q);
                else    _error_code = _i_smp_rmatrixlqunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qrows, &_d_q);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlqunpackq' call");
            }
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    public static void rmatrixlqunpackq(double[,] a, int m, int n, double[] tau, int qrows, out double[,] q)
    {
    _core_rmatrixlqunpackq( a,  m,  n,  tau,  qrows, out  q, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixlqunpackq(double[,] a, int m, int n, double[] tau, int qrows, out double[,] q)
    {
    _core_rmatrixlqunpackq( a,  m,  n,  tau,  qrows, out  q, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixlqunpackl(double[,] a, int m, int n, out double[,] l, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_l = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_l, DT_REAL);
                l = null;
                _error_code = _i_ser_rmatrixlqunpackl(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_l);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlqunpackl' call");
            }
            if( _d_l.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_l, ref l);
            if( l == null )
                l = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_l);
        }
        // This function returns no value.
    }
    public static void rmatrixlqunpackl(double[,] a, int m, int n, out double[,] l)
    {
    _core_rmatrixlqunpackl( a,  m,  n, out  l, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixqrunpackq(complex[,] a, int m, int n, complex[] tau, int qcolumns, out complex[,] q, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_int _d_qcolumns = new x_int(qcolumns);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_COMPLEX);
                q = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixqrunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qcolumns, &_d_q);
                else    _error_code = _i_smp_cmatrixqrunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qcolumns, &_d_q);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixqrunpackq' call");
            }
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    public static void cmatrixqrunpackq(complex[,] a, int m, int n, complex[] tau, int qcolumns, out complex[,] q)
    {
    _core_cmatrixqrunpackq( a,  m,  n,  tau,  qcolumns, out  q, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixqrunpackq(complex[,] a, int m, int n, complex[] tau, int qcolumns, out complex[,] q)
    {
    _core_cmatrixqrunpackq( a,  m,  n,  tau,  qcolumns, out  q, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixqrunpackr(complex[,] a, int m, int n, out complex[,] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_r = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_ser_cmatrixqrunpackr(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixqrunpackr' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void cmatrixqrunpackr(complex[,] a, int m, int n, out complex[,] r)
    {
    _core_cmatrixqrunpackr( a,  m,  n, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixlqunpackq(complex[,] a, int m, int n, complex[] tau, int qrows, out complex[,] q, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_int _d_qrows = new x_int(qrows);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_COMPLEX);
                q = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixlqunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qrows, &_d_q);
                else    _error_code = _i_smp_cmatrixlqunpackq(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tau, &_d_qrows, &_d_q);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlqunpackq' call");
            }
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    public static void cmatrixlqunpackq(complex[,] a, int m, int n, complex[] tau, int qrows, out complex[,] q)
    {
    _core_cmatrixlqunpackq( a,  m,  n,  tau,  qrows, out  q, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixlqunpackq(complex[,] a, int m, int n, complex[] tau, int qrows, out complex[,] q)
    {
    _core_cmatrixlqunpackq( a,  m,  n,  tau,  qrows, out  q, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixlqunpackl(complex[,] a, int m, int n, out complex[,] l, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_matrix _d_l = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_l, DT_COMPLEX);
                l = null;
                _error_code = _i_ser_cmatrixlqunpackl(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_l);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlqunpackl' call");
            }
            if( _d_l.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_l, ref l);
            if( l == null )
                l = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_l);
        }
        // This function returns no value.
    }
    public static void cmatrixlqunpackl(complex[,] a, int m, int n, out complex[,] l)
    {
    _core_cmatrixlqunpackl( a,  m,  n, out  l, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixbd(ref double[,] a, int m, int n, out double[] tauq, out double[] taup, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tauq = new x_vector();
        x_vector _d_taup = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tauq, DT_REAL);
                tauq = null;
                x_vector_create_empty(ref _d_taup, DT_REAL);
                taup = null;
                _error_code = _i_ser_rmatrixbd(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_tauq, &_d_taup);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixbd' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tauq.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tauq, ref tauq);
            if( tauq == null )
                tauq = new double[0];
            if( _d_taup.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_taup, ref taup);
            if( taup == null )
                taup = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tauq);
            x_vector_clear(ref _d_taup);
        }
        // This function returns no value.
    }
    public static void rmatrixbd(ref double[,] a, int m, int n, out double[] tauq, out double[] taup)
    {
    _core_rmatrixbd(ref  a,  m,  n, out  tauq, out  taup, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixbdunpackq(double[,] qp, int m, int n, double[] tauq, int qcolumns, out double[,] q, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_qp = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tauq = new x_vector();
        x_int _d_qcolumns = new x_int(qcolumns);
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_qp = qp, _fp_tauq = tauq){
                x_matrix_attach_to_array(ref _d_qp, _fp_qp, ap.rows(qp), ap.cols(qp));
                x_vector_attach_to_array(ref _d_tauq, _fp_tauq, ap.len(tauq));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                _error_code = _i_ser_rmatrixbdunpackq(&_s_errormsg, &_d_qp, &_d_m, &_d_n, &_d_tauq, &_d_qcolumns, &_d_q);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixbdunpackq' call");
            }
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_qp);
            x_vector_clear(ref _d_tauq);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    public static void rmatrixbdunpackq(double[,] qp, int m, int n, double[] tauq, int qcolumns, out double[,] q)
    {
    _core_rmatrixbdunpackq( qp,  m,  n,  tauq,  qcolumns, out  q, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixbdmultiplybyq(double[,] qp, int m, int n, double[] tauq, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_qp = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_tauq = new x_vector();
        x_matrix _d_z = new x_matrix();
        x_int _d_zrows = new x_int(zrows);
        x_int _d_zcolumns = new x_int(zcolumns);
        byte _d_fromtheright = (byte)(fromtheright ? 1 : 0);
        byte _d_dotranspose = (byte)(dotranspose ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_qp = qp, _fp_tauq = tauq, _fp_z = z){
                x_matrix_attach_to_array(ref _d_qp, _fp_qp, ap.rows(qp), ap.cols(qp));
                x_vector_attach_to_array(ref _d_tauq, _fp_tauq, ap.len(tauq));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_ser_rmatrixbdmultiplybyq(&_s_errormsg, &_d_qp, &_d_m, &_d_n, &_d_tauq, &_d_z, &_d_zrows, &_d_zcolumns, &_d_fromtheright, &_d_dotranspose);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixbdmultiplybyq' call");
            }
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_qp);
            x_vector_clear(ref _d_tauq);
            x_matrix_clear(ref _d_z);
        }
        // This function returns no value.
    }
    public static void rmatrixbdmultiplybyq(double[,] qp, int m, int n, double[] tauq, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose)
    {
    _core_rmatrixbdmultiplybyq( qp,  m,  n,  tauq, ref  z,  zrows,  zcolumns,  fromtheright,  dotranspose, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixbdunpackpt(double[,] qp, int m, int n, double[] taup, int ptrows, out double[,] pt, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_qp = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_taup = new x_vector();
        x_int _d_ptrows = new x_int(ptrows);
        x_matrix _d_pt = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_qp = qp, _fp_taup = taup){
                x_matrix_attach_to_array(ref _d_qp, _fp_qp, ap.rows(qp), ap.cols(qp));
                x_vector_attach_to_array(ref _d_taup, _fp_taup, ap.len(taup));
                x_matrix_create_empty(ref _d_pt, DT_REAL);
                pt = null;
                _error_code = _i_ser_rmatrixbdunpackpt(&_s_errormsg, &_d_qp, &_d_m, &_d_n, &_d_taup, &_d_ptrows, &_d_pt);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixbdunpackpt' call");
            }
            if( _d_pt.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_pt, ref pt);
            if( pt == null )
                pt = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_qp);
            x_vector_clear(ref _d_taup);
            x_matrix_clear(ref _d_pt);
        }
        // This function returns no value.
    }
    public static void rmatrixbdunpackpt(double[,] qp, int m, int n, double[] taup, int ptrows, out double[,] pt)
    {
    _core_rmatrixbdunpackpt( qp,  m,  n,  taup,  ptrows, out  pt, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixbdmultiplybyp(double[,] qp, int m, int n, double[] taup, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_qp = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_taup = new x_vector();
        x_matrix _d_z = new x_matrix();
        x_int _d_zrows = new x_int(zrows);
        x_int _d_zcolumns = new x_int(zcolumns);
        byte _d_fromtheright = (byte)(fromtheright ? 1 : 0);
        byte _d_dotranspose = (byte)(dotranspose ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_qp = qp, _fp_taup = taup, _fp_z = z){
                x_matrix_attach_to_array(ref _d_qp, _fp_qp, ap.rows(qp), ap.cols(qp));
                x_vector_attach_to_array(ref _d_taup, _fp_taup, ap.len(taup));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_ser_rmatrixbdmultiplybyp(&_s_errormsg, &_d_qp, &_d_m, &_d_n, &_d_taup, &_d_z, &_d_zrows, &_d_zcolumns, &_d_fromtheright, &_d_dotranspose);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixbdmultiplybyp' call");
            }
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_qp);
            x_vector_clear(ref _d_taup);
            x_matrix_clear(ref _d_z);
        }
        // This function returns no value.
    }
    public static void rmatrixbdmultiplybyp(double[,] qp, int m, int n, double[] taup, ref double[,] z, int zrows, int zcolumns, bool fromtheright, bool dotranspose)
    {
    _core_rmatrixbdmultiplybyp( qp,  m,  n,  taup, ref  z,  zrows,  zcolumns,  fromtheright,  dotranspose, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixbdunpackdiagonals(double[,] b, int m, int n, out bool isupper, out double[] d, out double[] e, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_vector_create_empty(ref _d_e, DT_REAL);
                e = null;
                _error_code = _i_ser_rmatrixbdunpackdiagonals(&_s_errormsg, &_d_b, &_d_m, &_d_n, &_d_isupper, &_d_d, &_d_e);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixbdunpackdiagonals' call");
            }
            isupper = _d_isupper!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_e.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_e, ref e);
            if( e == null )
                e = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_b);
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
        }
        // This function returns no value.
    }
    public static void rmatrixbdunpackdiagonals(double[,] b, int m, int n, out bool isupper, out double[] d, out double[] e)
    {
    _core_rmatrixbdunpackdiagonals( b,  m,  n, out  isupper, out  d, out  e, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixhessenberg(ref double[,] a, int n, out double[] tau, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_REAL);
                tau = null;
                _error_code = _i_ser_rmatrixhessenberg(&_s_errormsg, &_d_a, &_d_n, &_d_tau);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixhessenberg' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
        }
        // This function returns no value.
    }
    public static void rmatrixhessenberg(ref double[,] a, int n, out double[] tau)
    {
    _core_rmatrixhessenberg(ref  a,  n, out  tau, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixhessenbergunpackq(double[,] a, int n, double[] tau, out double[,] q, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_tau = new x_vector();
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                _error_code = _i_ser_rmatrixhessenbergunpackq(&_s_errormsg, &_d_a, &_d_n, &_d_tau, &_d_q);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixhessenbergunpackq' call");
            }
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    public static void rmatrixhessenbergunpackq(double[,] a, int n, double[] tau, out double[,] q)
    {
    _core_rmatrixhessenbergunpackq( a,  n,  tau, out  q, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixhessenbergunpackh(double[,] a, int n, out double[,] h, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_h = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_h, DT_REAL);
                h = null;
                _error_code = _i_ser_rmatrixhessenbergunpackh(&_s_errormsg, &_d_a, &_d_n, &_d_h);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixhessenbergunpackh' call");
            }
            if( _d_h.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_h, ref h);
            if( h == null )
                h = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_h);
        }
        // This function returns no value.
    }
    public static void rmatrixhessenbergunpackh(double[,] a, int n, out double[,] h)
    {
    _core_rmatrixhessenbergunpackh( a,  n, out  h, alglibmode.serial);
    return;
    }
    private static unsafe void _core_smatrixtd(ref double[,] a, int n, bool isupper, out double[] tau, out double[] d, out double[] e, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_tau = new x_vector();
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_REAL);
                tau = null;
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_vector_create_empty(ref _d_e, DT_REAL);
                e = null;
                _error_code = _i_ser_smatrixtd(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_tau, &_d_d, &_d_e);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixtd' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new double[0];
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_e.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_e, ref e);
            if( e == null )
                e = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
        }
        // This function returns no value.
    }
    public static void smatrixtd(ref double[,] a, int n, bool isupper, out double[] tau, out double[] d, out double[] e)
    {
    _core_smatrixtd(ref  a,  n,  isupper, out  tau, out  d, out  e, alglibmode.serial);
    return;
    }
    private static unsafe void _core_smatrixtdunpackq(double[,] a, int n, bool isupper, double[] tau, out double[,] q, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_tau = new x_vector();
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_REAL);
                q = null;
                _error_code = _i_ser_smatrixtdunpackq(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_tau, &_d_q);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixtdunpackq' call");
            }
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    public static void smatrixtdunpackq(double[,] a, int n, bool isupper, double[] tau, out double[,] q)
    {
    _core_smatrixtdunpackq( a,  n,  isupper,  tau, out  q, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hmatrixtd(ref complex[,] a, int n, bool isupper, out complex[] tau, out double[] d, out double[] e, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_tau = new x_vector();
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_tau, DT_COMPLEX);
                tau = null;
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_vector_create_empty(ref _d_e, DT_REAL);
                e = null;
                _error_code = _i_ser_hmatrixtd(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_tau, &_d_d, &_d_e);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hmatrixtd' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            if( _d_tau.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_tau, ref tau);
            if( tau == null )
                tau = new alglib.complex[0];
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_e.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_e, ref e);
            if( e == null )
                e = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
        }
        // This function returns no value.
    }
    public static void hmatrixtd(ref complex[,] a, int n, bool isupper, out complex[] tau, out double[] d, out double[] e)
    {
    _core_hmatrixtd(ref  a,  n,  isupper, out  tau, out  d, out  e, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hmatrixtdunpackq(complex[,] a, int n, bool isupper, complex[] tau, out complex[,] q, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_tau = new x_vector();
        x_matrix _d_q = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_tau = tau){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_tau, _fp_tau, ap.len(tau));
                x_matrix_create_empty(ref _d_q, DT_COMPLEX);
                q = null;
                _error_code = _i_ser_hmatrixtdunpackq(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_tau, &_d_q);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hmatrixtdunpackq' call");
            }
            if( _d_q.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_q, ref q);
            if( q == null )
                q = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_tau);
            x_matrix_clear(ref _d_q);
        }
        // This function returns no value.
    }
    public static void hmatrixtdunpackq(complex[,] a, int n, bool isupper, complex[] tau, out complex[,] q)
    {
    _core_hmatrixtdunpackq( a,  n,  isupper,  tau, out  q, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage bdsvd
    //
    
    private static unsafe bool _core_rmatrixbdsvd(ref double[] d, double[] e, int n, bool isupper, bool isfractionalaccuracyrequired, ref double[,] u, int nru, ref double[,] c, int ncc, ref double[,] vt, int ncvt, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isfractionalaccuracyrequired = (byte)(isfractionalaccuracyrequired ? 1 : 0);
        x_matrix _d_u = new x_matrix();
        x_int _d_nru = new x_int(nru);
        x_matrix _d_c = new x_matrix();
        x_int _d_ncc = new x_int(ncc);
        x_matrix _d_vt = new x_matrix();
        x_int _d_ncvt = new x_int(ncvt);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d, _fp_e = e, _fp_u = u, _fp_c = c, _fp_vt = vt){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                x_vector_attach_to_array(ref _d_e, _fp_e, ap.len(e));
                x_matrix_attach_to_array(ref _d_u, _fp_u, ap.rows(u), ap.cols(u));
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_matrix_attach_to_array(ref _d_vt, _fp_vt, ap.rows(vt), ap.cols(vt));
                _error_code = _i_ser_rmatrixbdsvd(&_s_errormsg, &_d_result, &_d_d, &_d_e, &_d_n, &_d_isupper, &_d_isfractionalaccuracyrequired, &_d_u, &_d_nru, &_d_c, &_d_ncc, &_d_vt, &_d_ncvt);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixbdsvd' call");
            }
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_u.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_u, ref u);
            if( u == null )
                u = new double[0,0];
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0,0];
            if( _d_vt.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_vt, ref vt);
            if( vt == null )
                vt = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
            x_matrix_clear(ref _d_u);
            x_matrix_clear(ref _d_c);
            x_matrix_clear(ref _d_vt);
        }
        return result;
    }
    public static bool rmatrixbdsvd(ref double[] d, double[] e, int n, bool isupper, bool isfractionalaccuracyrequired, ref double[,] u, int nru, ref double[,] c, int ncc, ref double[,] vt, int ncvt)
    {
    bool result = _core_rmatrixbdsvd(ref  d,  e,  n,  isupper,  isfractionalaccuracyrequired, ref  u,  nru, ref  c,  ncc, ref  vt,  ncvt, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage svd
    //
    
    private static unsafe bool _core_rmatrixsvd(double[,] a, int m, int n, int uneeded, int vtneeded, int additionalmemory, out double[] w, out double[,] u, out double[,] vt, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_uneeded = new x_int(uneeded);
        x_int _d_vtneeded = new x_int(vtneeded);
        x_int _d_additionalmemory = new x_int(additionalmemory);
        x_vector _d_w = new x_vector();
        x_matrix _d_u = new x_matrix();
        x_matrix _d_vt = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_u, DT_REAL);
                u = null;
                x_matrix_create_empty(ref _d_vt, DT_REAL);
                vt = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixsvd(&_s_errormsg, &_d_result, &_d_a, &_d_m, &_d_n, &_d_uneeded, &_d_vtneeded, &_d_additionalmemory, &_d_w, &_d_u, &_d_vt);
                else    _error_code = _i_smp_rmatrixsvd(&_s_errormsg, &_d_result, &_d_a, &_d_m, &_d_n, &_d_uneeded, &_d_vtneeded, &_d_additionalmemory, &_d_w, &_d_u, &_d_vt);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixsvd' call");
            }
            result = _d_result!=0;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_u.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_u, ref u);
            if( u == null )
                u = new double[0,0];
            if( _d_vt.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_vt, ref vt);
            if( vt == null )
                vt = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_u);
            x_matrix_clear(ref _d_vt);
        }
        return result;
    }
    public static bool rmatrixsvd(double[,] a, int m, int n, int uneeded, int vtneeded, int additionalmemory, out double[] w, out double[,] u, out double[,] vt)
    {
    bool result = _core_rmatrixsvd( a,  m,  n,  uneeded,  vtneeded,  additionalmemory, out  w, out  u, out  vt, alglibmode.serial);
    return result;
    }
    public static bool smp_rmatrixsvd(double[,] a, int m, int n, int uneeded, int vtneeded, int additionalmemory, out double[] w, out double[,] u, out double[,] vt)
    {
    bool result = _core_rmatrixsvd( a,  m,  n,  uneeded,  vtneeded,  additionalmemory, out  w, out  u, out  vt, alglibmode.parallel);
    return result;
    }
    
    
    //
    // Subpackage linreg
    //
    

    public unsafe class linearmodel : alglibobject
    {
        public void *ptr;
        public linearmodel(void *x)
        {
            ptr = x;
        }
        ~linearmodel()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new linearmodel(null);
            return new linearmodel(_i_x_obj_copy_linearmodel(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_linearmodel(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_linearmodel(void *x);
    private static _d_x_obj_copy_linearmodel _i_x_obj_copy_linearmodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_linearmodel(void *x);
    private static _d_x_obj_free_linearmodel _i_x_obj_free_linearmodel = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_lrreport
    {
        public x_matrix c;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double cvrmserror;
        public double cvavgerror;
        public double cvavgrelerror;
        public x_int ncvdefects;
        public x_vector cvdefects;
    }

    public class lrreport : alglibobject
    {
        public double[,] c;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double cvrmserror;
        public double cvavgerror;
        public double cvavgrelerror;
        public int ncvdefects;
        public int[] cvdefects;
        public override alglib.alglibobject make_copy()
        {
            lrreport dst = new lrreport();
            dst.c = (double[,])c.Clone();        dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.cvrmserror = cvrmserror;
            dst.cvavgerror = cvavgerror;
            dst.cvavgrelerror = cvavgrelerror;
            dst.ncvdefects = ncvdefects;
            dst.cvdefects = (int[])cvdefects.Clone();        return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_lrreport_init(ref x_lrreport x)
    {
        x_matrix_create_empty(ref x.c, DT_REAL);
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.cvrmserror = 0;
        x.cvavgerror = 0;
        x.cvavgrelerror = 0;
        x.ncvdefects.longval = 0;
        x_vector_create_empty(ref x.cvdefects, DT_INT);
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_lrreport_clear(ref x_lrreport x)
    {
        x_matrix_clear(ref x.c);
        x_vector_clear(ref x.cvdefects);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_lrreport_init_from(ref x_lrreport x, lrreport v)
    {
        x_matrix_from_array(ref x.c, v.c, X_CREATE);
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.cvrmserror = v.cvrmserror;
        x.cvavgerror = v.cvavgerror;
        x.cvavgrelerror = v.cvavgrelerror;
        x.ncvdefects.longval = v.ncvdefects;
        x_vector_from_array(ref x.cvdefects, v.cvdefects, X_CREATE);
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_lrreport_to_record(ref x_lrreport x, ref lrreport v)
    {
        if( v==null )
            v = new lrreport();
        x_matrix_to_array(ref x.c, ref v.c);
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.cvrmserror = x.cvrmserror;
        v.cvavgerror = x.cvavgerror;
        v.cvavgrelerror = x.cvavgrelerror;
        v.ncvdefects = x.ncvdefects.intval; // long is silently truncated to int
        x_vector_to_array(ref x.cvdefects, ref v.cvdefects);
    }
    private static unsafe void _core_lrbuild(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_lrreport _d_ar = new x_lrreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_lrreport_init(ref _d_ar);
                _error_code = _i_ser_lrbuild(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_info, &_d_lm, &_d_ar);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lrbuild' call");
            }
            info = _d_info.intval;
            lm = new linearmodel(_d_lm);
            ar = null;
            x_lrreport_to_record(ref _d_ar, ref ar);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_lrreport_clear(ref _d_ar);
        }
        // This function returns no value.
    }
    public static void lrbuild(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar)
    {
    _core_lrbuild( xy,  npoints,  nvars, out  info, out  lm, out  ar, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lrbuilds(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_vector _d_s = new x_vector();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_lrreport _d_ar = new x_lrreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_s = s){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                x_lrreport_init(ref _d_ar);
                _error_code = _i_ser_lrbuilds(&_s_errormsg, &_d_xy, &_d_s, &_d_npoints, &_d_nvars, &_d_info, &_d_lm, &_d_ar);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lrbuilds' call");
            }
            info = _d_info.intval;
            lm = new linearmodel(_d_lm);
            ar = null;
            x_lrreport_to_record(ref _d_ar, ref ar);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_s);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_lrreport_clear(ref _d_ar);
        }
        // This function returns no value.
    }
    public static void lrbuilds(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar)
    {
    _core_lrbuilds( xy,  s,  npoints,  nvars, out  info, out  lm, out  ar, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lrbuildzs(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_vector _d_s = new x_vector();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_lrreport _d_ar = new x_lrreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_s = s){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                x_lrreport_init(ref _d_ar);
                _error_code = _i_ser_lrbuildzs(&_s_errormsg, &_d_xy, &_d_s, &_d_npoints, &_d_nvars, &_d_info, &_d_lm, &_d_ar);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lrbuildzs' call");
            }
            info = _d_info.intval;
            lm = new linearmodel(_d_lm);
            ar = null;
            x_lrreport_to_record(ref _d_ar, ref ar);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_s);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_lrreport_clear(ref _d_ar);
        }
        // This function returns no value.
    }
    public static void lrbuildzs(double[,] xy, double[] s, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar)
    {
    _core_lrbuildzs( xy,  s,  npoints,  nvars, out  info, out  lm, out  ar, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lrbuildz(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_lrreport _d_ar = new x_lrreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_lrreport_init(ref _d_ar);
                _error_code = _i_ser_lrbuildz(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_info, &_d_lm, &_d_ar);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lrbuildz' call");
            }
            info = _d_info.intval;
            lm = new linearmodel(_d_lm);
            ar = null;
            x_lrreport_to_record(ref _d_ar, ref ar);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_lrreport_clear(ref _d_ar);
        }
        // This function returns no value.
    }
    public static void lrbuildz(double[,] xy, int npoints, int nvars, out int info, out linearmodel lm, out lrreport ar)
    {
    _core_lrbuildz( xy,  npoints,  nvars, out  info, out  lm, out  ar, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lrunpack(linearmodel lm, out double[] v, out int nvars, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_lm = lm.ptr;
        x_vector _d_v = new x_vector();
        x_int _d_nvars = new x_int();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_v, DT_REAL);
            v = null;
            _error_code = _i_ser_lrunpack(&_s_errormsg, &_d_lm, &_d_v, &_d_nvars);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lrunpack' call");
            }
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0];
            nvars = _d_nvars.intval;
        }
        finally
        {
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    public static void lrunpack(linearmodel lm, out double[] v, out int nvars)
    {
    _core_lrunpack( lm, out  v, out  nvars, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lrpack(double[] v, int nvars, out linearmodel lm, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_v = new x_vector();
        x_int _d_nvars = new x_int(nvars);
        void *_d_lm = null;
        lm = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_v = v){
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_ser_lrpack(&_s_errormsg, &_d_v, &_d_nvars, &_d_lm);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lrpack' call");
            }
            lm = new linearmodel(_d_lm);
        }
        finally
        {
            x_vector_clear(ref _d_v);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_linearmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void lrpack(double[] v, int nvars, out linearmodel lm)
    {
    _core_lrpack( v,  nvars, out  lm, alglibmode.serial);
    return;
    }
    private static unsafe double _core_lrprocess(linearmodel lm, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_lrprocess(&_s_errormsg, &_d_result, &_d_lm, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lrprocess' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double lrprocess(linearmodel lm, double[] x)
    {
    double result = _core_lrprocess( lm,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_lrrmserror(linearmodel lm, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_lrrmserror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lrrmserror' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double lrrmserror(linearmodel lm, double[,] xy, int npoints)
    {
    double result = _core_lrrmserror( lm,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_lravgerror(linearmodel lm, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_lravgerror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lravgerror' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double lravgerror(linearmodel lm, double[,] xy, int npoints)
    {
    double result = _core_lravgerror( lm,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_lravgrelerror(linearmodel lm, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_lravgrelerror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lravgrelerror' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double lravgrelerror(linearmodel lm, double[,] xy, int npoints)
    {
    double result = _core_lravgrelerror( lm,  xy,  npoints, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage filters
    //
    
    private static unsafe void _core_filtersma(ref double[] x, int n, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_filtersma(&_s_errormsg, &_d_x, &_d_n, &_d_k);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'filtersma' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void filtersma(ref double[] x, int n, int k)
    {
    _core_filtersma(ref  x,  n,  k, alglibmode.serial);
    return;
    }
    public static void filtersma(ref double[] x, int k)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_filtersma(ref  x,  n,  k, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_filterema(ref double[] x, int n, double alpha, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_filterema(&_s_errormsg, &_d_x, &_d_n, &_d_alpha);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'filterema' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void filterema(ref double[] x, int n, double alpha)
    {
    _core_filterema(ref  x,  n,  alpha, alglibmode.serial);
    return;
    }
    public static void filterema(ref double[] x, double alpha)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_filterema(ref  x,  n,  alpha, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_filterlrma(ref double[] x, int n, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_filterlrma(&_s_errormsg, &_d_x, &_d_n, &_d_k);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'filterlrma' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void filterlrma(ref double[] x, int n, int k)
    {
    _core_filterlrma(ref  x,  n,  k, alglibmode.serial);
    return;
    }
    public static void filterlrma(ref double[] x, int k)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_filterlrma(ref  x,  n,  k, alglibmode.serial);
    
    return;
    }
    
    
    //
    // Subpackage evd
    //
    
    private static unsafe bool _core_smatrixevd(double[,] a, int n, int zneeded, bool isupper, out double[] d, out double[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_d = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                _error_code = _i_ser_smatrixevd(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_d, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixevd' call");
            }
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_d);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool smatrixevd(double[,] a, int n, int zneeded, bool isupper, out double[] d, out double[,] z)
    {
    bool result = _core_smatrixevd( a,  n,  zneeded,  isupper, out  d, out  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_smatrixevdr(double[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out double[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        double _d_b1 = b1;
        double _d_b2 = b2;
        x_int _d_m = new x_int();
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                _error_code = _i_ser_smatrixevdr(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_b1, &_d_b2, &_d_m, &_d_w, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixevdr' call");
            }
            result = _d_result!=0;
            m = _d_m.intval;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool smatrixevdr(double[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out double[,] z)
    {
    bool result = _core_smatrixevdr( a,  n,  zneeded,  isupper,  b1,  b2, out  m, out  w, out  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_smatrixevdi(double[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out double[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_i1 = new x_int(i1);
        x_int _d_i2 = new x_int(i2);
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                _error_code = _i_ser_smatrixevdi(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_i1, &_d_i2, &_d_w, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixevdi' call");
            }
            result = _d_result!=0;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool smatrixevdi(double[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out double[,] z)
    {
    bool result = _core_smatrixevdi( a,  n,  zneeded,  isupper,  i1,  i2, out  w, out  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_hmatrixevd(complex[,] a, int n, int zneeded, bool isupper, out double[] d, out complex[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_d = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_matrix_create_empty(ref _d_z, DT_COMPLEX);
                z = null;
                _error_code = _i_ser_hmatrixevd(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_d, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hmatrixevd' call");
            }
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_d);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool hmatrixevd(complex[,] a, int n, int zneeded, bool isupper, out double[] d, out complex[,] z)
    {
    bool result = _core_hmatrixevd( a,  n,  zneeded,  isupper, out  d, out  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_hmatrixevdr(complex[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out complex[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        double _d_b1 = b1;
        double _d_b2 = b2;
        x_int _d_m = new x_int();
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_COMPLEX);
                z = null;
                _error_code = _i_ser_hmatrixevdr(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_b1, &_d_b2, &_d_m, &_d_w, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hmatrixevdr' call");
            }
            result = _d_result!=0;
            m = _d_m.intval;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool hmatrixevdr(complex[,] a, int n, int zneeded, bool isupper, double b1, double b2, out int m, out double[] w, out complex[,] z)
    {
    bool result = _core_hmatrixevdr( a,  n,  zneeded,  isupper,  b1,  b2, out  m, out  w, out  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_hmatrixevdi(complex[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out complex[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_i1 = new x_int(i1);
        x_int _d_i2 = new x_int(i2);
        x_vector _d_w = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                x_matrix_create_empty(ref _d_z, DT_COMPLEX);
                z = null;
                _error_code = _i_ser_hmatrixevdi(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_zneeded, &_d_isupper, &_d_i1, &_d_i2, &_d_w, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hmatrixevdi' call");
            }
            result = _d_result!=0;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool hmatrixevdi(complex[,] a, int n, int zneeded, bool isupper, int i1, int i2, out double[] w, out complex[,] z)
    {
    bool result = _core_hmatrixevdi( a,  n,  zneeded,  isupper,  i1,  i2, out  w, out  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_smatrixtdevd(ref double[] d, double[] e, int n, int zneeded, ref double[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d, _fp_e = e, _fp_z = z){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                x_vector_attach_to_array(ref _d_e, _fp_e, ap.len(e));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_ser_smatrixtdevd(&_s_errormsg, &_d_result, &_d_d, &_d_e, &_d_n, &_d_zneeded, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixtdevd' call");
            }
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool smatrixtdevd(ref double[] d, double[] e, int n, int zneeded, ref double[,] z)
    {
    bool result = _core_smatrixtdevd(ref  d,  e,  n,  zneeded, ref  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_smatrixtdevdr(ref double[] d, double[] e, int n, int zneeded, double a, double b, out int m, ref double[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        double _d_a = a;
        double _d_b = b;
        x_int _d_m = new x_int();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d, _fp_e = e, _fp_z = z){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                x_vector_attach_to_array(ref _d_e, _fp_e, ap.len(e));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_ser_smatrixtdevdr(&_s_errormsg, &_d_result, &_d_d, &_d_e, &_d_n, &_d_zneeded, &_d_a, &_d_b, &_d_m, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixtdevdr' call");
            }
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            m = _d_m.intval;
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool smatrixtdevdr(ref double[] d, double[] e, int n, int zneeded, double a, double b, out int m, ref double[,] z)
    {
    bool result = _core_smatrixtdevdr(ref  d,  e,  n,  zneeded,  a,  b, out  m, ref  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_smatrixtdevdi(ref double[] d, double[] e, int n, int zneeded, int i1, int i2, ref double[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_vector _d_d = new x_vector();
        x_vector _d_e = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_zneeded = new x_int(zneeded);
        x_int _d_i1 = new x_int(i1);
        x_int _d_i2 = new x_int(i2);
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d, _fp_e = e, _fp_z = z){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                x_vector_attach_to_array(ref _d_e, _fp_e, ap.len(e));
                x_matrix_attach_to_array(ref _d_z, _fp_z, ap.rows(z), ap.cols(z));
                _error_code = _i_ser_smatrixtdevdi(&_s_errormsg, &_d_result, &_d_d, &_d_e, &_d_n, &_d_zneeded, &_d_i1, &_d_i2, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixtdevdi' call");
            }
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_e);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool smatrixtdevdi(ref double[] d, double[] e, int n, int zneeded, int i1, int i2, ref double[,] z)
    {
    bool result = _core_smatrixtdevdi(ref  d,  e,  n,  zneeded,  i1,  i2, ref  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_rmatrixevd(double[,] a, int n, int vneeded, out double[] wr, out double[] wi, out double[,] vl, out double[,] vr, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_vneeded = new x_int(vneeded);
        x_vector _d_wr = new x_vector();
        x_vector _d_wi = new x_vector();
        x_matrix _d_vl = new x_matrix();
        x_matrix _d_vr = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_wr, DT_REAL);
                wr = null;
                x_vector_create_empty(ref _d_wi, DT_REAL);
                wi = null;
                x_matrix_create_empty(ref _d_vl, DT_REAL);
                vl = null;
                x_matrix_create_empty(ref _d_vr, DT_REAL);
                vr = null;
                _error_code = _i_ser_rmatrixevd(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_vneeded, &_d_wr, &_d_wi, &_d_vl, &_d_vr);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixevd' call");
            }
            result = _d_result!=0;
            if( _d_wr.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wr, ref wr);
            if( wr == null )
                wr = new double[0];
            if( _d_wi.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wi, ref wi);
            if( wi == null )
                wi = new double[0];
            if( _d_vl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_vl, ref vl);
            if( vl == null )
                vl = new double[0,0];
            if( _d_vr.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_vr, ref vr);
            if( vr == null )
                vr = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_wr);
            x_vector_clear(ref _d_wi);
            x_matrix_clear(ref _d_vl);
            x_matrix_clear(ref _d_vr);
        }
        return result;
    }
    public static bool rmatrixevd(double[,] a, int n, int vneeded, out double[] wr, out double[] wi, out double[,] vl, out double[,] vr)
    {
    bool result = _core_rmatrixevd( a,  n,  vneeded, out  wr, out  wi, out  vl, out  vr, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage matgen
    //
    
    private static unsafe void _core_rmatrixrndorthogonal(int n, out double[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_ser_rmatrixrndorthogonal(&_s_errormsg, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixrndorthogonal' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void rmatrixrndorthogonal(int n, out double[,] a)
    {
    _core_rmatrixrndorthogonal( n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixrndcond(int n, double c, out double[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_ser_rmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixrndcond' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void rmatrixrndcond(int n, double c, out double[,] a)
    {
    _core_rmatrixrndcond( n,  c, out  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixrndorthogonal(int n, out complex[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_ser_cmatrixrndorthogonal(&_s_errormsg, &_d_n, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixrndorthogonal' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void cmatrixrndorthogonal(int n, out complex[,] a)
    {
    _core_cmatrixrndorthogonal( n, out  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixrndcond(int n, double c, out complex[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_ser_cmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixrndcond' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void cmatrixrndcond(int n, double c, out complex[,] a)
    {
    _core_cmatrixrndcond( n,  c, out  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_smatrixrndcond(int n, double c, out double[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_ser_smatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixrndcond' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void smatrixrndcond(int n, double c, out double[,] a)
    {
    _core_smatrixrndcond( n,  c, out  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spdmatrixrndcond(int n, double c, out double[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_ser_spdmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixrndcond' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void spdmatrixrndcond(int n, double c, out double[,] a)
    {
    _core_spdmatrixrndcond( n,  c, out  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hmatrixrndcond(int n, double c, out complex[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_ser_hmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hmatrixrndcond' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void hmatrixrndcond(int n, double c, out complex[,] a)
    {
    _core_hmatrixrndcond( n,  c, out  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hpdmatrixrndcond(int n, double c, out complex[,] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_c = c;
        x_matrix _d_a = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_COMPLEX);
            a = null;
            _error_code = _i_ser_hpdmatrixrndcond(&_s_errormsg, &_d_n, &_d_c, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixrndcond' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void hpdmatrixrndcond(int n, double c, out complex[,] a)
    {
    _core_hpdmatrixrndcond( n,  c, out  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixrndorthogonalfromtheright(ref double[,] a, int m, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_rmatrixrndorthogonalfromtheright(&_s_errormsg, &_d_a, &_d_m, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixrndorthogonalfromtheright' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void rmatrixrndorthogonalfromtheright(ref double[,] a, int m, int n)
    {
    _core_rmatrixrndorthogonalfromtheright(ref  a,  m,  n, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixrndorthogonalfromtheleft(ref double[,] a, int m, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_rmatrixrndorthogonalfromtheleft(&_s_errormsg, &_d_a, &_d_m, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixrndorthogonalfromtheleft' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void rmatrixrndorthogonalfromtheleft(ref double[,] a, int m, int n)
    {
    _core_rmatrixrndorthogonalfromtheleft(ref  a,  m,  n, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixrndorthogonalfromtheright(ref complex[,] a, int m, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_cmatrixrndorthogonalfromtheright(&_s_errormsg, &_d_a, &_d_m, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixrndorthogonalfromtheright' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void cmatrixrndorthogonalfromtheright(ref complex[,] a, int m, int n)
    {
    _core_cmatrixrndorthogonalfromtheright(ref  a,  m,  n, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixrndorthogonalfromtheleft(ref complex[,] a, int m, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_cmatrixrndorthogonalfromtheleft(&_s_errormsg, &_d_a, &_d_m, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixrndorthogonalfromtheleft' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void cmatrixrndorthogonalfromtheleft(ref complex[,] a, int m, int n)
    {
    _core_cmatrixrndorthogonalfromtheleft(ref  a,  m,  n, alglibmode.serial);
    return;
    }
    private static unsafe void _core_smatrixrndmultiply(ref double[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_smatrixrndmultiply(&_s_errormsg, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixrndmultiply' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void smatrixrndmultiply(ref double[,] a, int n)
    {
    _core_smatrixrndmultiply(ref  a,  n, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hmatrixrndmultiply(ref complex[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_hmatrixrndmultiply(&_s_errormsg, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hmatrixrndmultiply' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void hmatrixrndmultiply(ref complex[,] a, int n)
    {
    _core_hmatrixrndmultiply(ref  a,  n, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage sparse
    //
    

    public unsafe class sparsematrix : alglibobject
    {
        public void *ptr;
        public sparsematrix(void *x)
        {
            ptr = x;
        }
        ~sparsematrix()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new sparsematrix(null);
            return new sparsematrix(_i_x_obj_copy_sparsematrix(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_sparsematrix(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_sparsematrix(void *x);
    private static _d_x_obj_copy_sparsematrix _i_x_obj_copy_sparsematrix = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_sparsematrix(void *x);
    private static _d_x_obj_free_sparsematrix _i_x_obj_free_sparsematrix = null;

    public unsafe class sparsebuffers : alglibobject
    {
        public void *ptr;
        public sparsebuffers(void *x)
        {
            ptr = x;
        }
        ~sparsebuffers()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new sparsebuffers(null);
            return new sparsebuffers(_i_x_obj_copy_sparsebuffers(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_sparsebuffers(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_sparsebuffers(void *x);
    private static _d_x_obj_copy_sparsebuffers _i_x_obj_copy_sparsebuffers = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_sparsebuffers(void *x);
    private static _d_x_obj_free_sparsebuffers _i_x_obj_free_sparsebuffers = null;
    private static unsafe void _core_sparsecreate(int m, int n, int k, out sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecreate(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecreate' call");
            }
            s = new sparsematrix(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void sparsecreate(int m, int n, int k, out sparsematrix s)
    {
    _core_sparsecreate( m,  n,  k, out  s, alglibmode.serial);
    return;
    }
    public static void sparsecreate(int m, int n, out sparsematrix s)
    {
    int k;
    
    
    k = 0;
    
    _core_sparsecreate( m,  n,  k, out  s, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_sparsecreatebuf(int m, int n, int k, sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_k = new x_int(k);
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecreatebuf(&_s_errormsg, &_d_m, &_d_n, &_d_k, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecreatebuf' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparsecreatebuf(int m, int n, int k, sparsematrix s)
    {
    _core_sparsecreatebuf( m,  n,  k,  s, alglibmode.serial);
    return;
    }
    public static void sparsecreatebuf(int m, int n, sparsematrix s)
    {
    int k;
    
    
    k = 0;
    
    _core_sparsecreatebuf( m,  n,  k,  s, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_sparsecreatecrs(int m, int n, int[] ner, out sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_ner = new x_vector();
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_ner, ner, X_CREATE);
            _error_code = _i_ser_sparsecreatecrs(&_s_errormsg, &_d_m, &_d_n, &_d_ner, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecreatecrs' call");
            }
            s = new sparsematrix(_d_s);
        }
        finally
        {
            x_vector_clear(ref _d_ner);
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void sparsecreatecrs(int m, int n, int[] ner, out sparsematrix s)
    {
    _core_sparsecreatecrs( m,  n,  ner, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecreatecrsbuf(int m, int n, int[] ner, sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_ner = new x_vector();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_ner, ner, X_CREATE);
            _error_code = _i_ser_sparsecreatecrsbuf(&_s_errormsg, &_d_m, &_d_n, &_d_ner, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecreatecrsbuf' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_ner);
        }
        // This function returns no value.
    }
    public static void sparsecreatecrsbuf(int m, int n, int[] ner, sparsematrix s)
    {
    _core_sparsecreatecrsbuf( m,  n,  ner,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecreatesks(int m, int n, int[] d, int[] u, out sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_d = new x_vector();
        x_vector _d_u = new x_vector();
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_d, d, X_CREATE);
            x_vector_from_array(ref _d_u, u, X_CREATE);
            _error_code = _i_ser_sparsecreatesks(&_s_errormsg, &_d_m, &_d_n, &_d_d, &_d_u, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecreatesks' call");
            }
            s = new sparsematrix(_d_s);
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_u);
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void sparsecreatesks(int m, int n, int[] d, int[] u, out sparsematrix s)
    {
    _core_sparsecreatesks( m,  n,  d,  u, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecreatesksbuf(int m, int n, int[] d, int[] u, sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_d = new x_vector();
        x_vector _d_u = new x_vector();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_d, d, X_CREATE);
            x_vector_from_array(ref _d_u, u, X_CREATE);
            _error_code = _i_ser_sparsecreatesksbuf(&_s_errormsg, &_d_m, &_d_n, &_d_d, &_d_u, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecreatesksbuf' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
            x_vector_clear(ref _d_u);
        }
        // This function returns no value.
    }
    public static void sparsecreatesksbuf(int m, int n, int[] d, int[] u, sparsematrix s)
    {
    _core_sparsecreatesksbuf( m,  n,  d,  u,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopy(sparsematrix s0, out sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopy(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopy' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void sparsecopy(sparsematrix s0, out sparsematrix s1)
    {
    _core_sparsecopy( s0, out  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopybuf(sparsematrix s0, sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopybuf(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopybuf' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparsecopybuf(sparsematrix s0, sparsematrix s1)
    {
    _core_sparsecopybuf( s0,  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparseswap(sparsematrix s0, sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseswap(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseswap' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparseswap(sparsematrix s0, sparsematrix s1)
    {
    _core_sparseswap( s0,  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparseadd(sparsematrix s, int i, int j, double v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseadd(&_s_errormsg, &_d_s, &_d_i, &_d_j, &_d_v);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseadd' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparseadd(sparsematrix s, int i, int j, double v)
    {
    _core_sparseadd( s,  i,  j,  v, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparseset(sparsematrix s, int i, int j, double v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseset(&_s_errormsg, &_d_s, &_d_i, &_d_j, &_d_v);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseset' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparseset(sparsematrix s, int i, int j, double v)
    {
    _core_sparseset( s,  i,  j,  v, alglibmode.serial);
    return;
    }
    private static unsafe double _core_sparseget(sparsematrix s, int i, int j, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseget(&_s_errormsg, &_d_result, &_d_s, &_d_i, &_d_j);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseget' call");
            }
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double sparseget(sparsematrix s, int i, int j)
    {
    double result = _core_sparseget( s,  i,  j, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_sparsegetdiagonal(sparsematrix s, int i, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsegetdiagonal(&_s_errormsg, &_d_result, &_d_s, &_d_i);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsegetdiagonal' call");
            }
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double sparsegetdiagonal(sparsematrix s, int i)
    {
    double result = _core_sparsegetdiagonal( s,  i, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_sparsemv(sparsematrix s, double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_sparsemv(&_s_errormsg, &_d_s, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsemv' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void sparsemv(sparsematrix s, double[] x, ref double[] y)
    {
    _core_sparsemv( s,  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsemtv(sparsematrix s, double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_sparsemtv(&_s_errormsg, &_d_s, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsemtv' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void sparsemtv(sparsematrix s, double[] x, ref double[] y)
    {
    _core_sparsemtv( s,  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsemv2(sparsematrix s, double[] x, ref double[] y0, ref double[] y1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y0 = new x_vector();
        x_vector _d_y1 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y0 = y0, _fp_y1 = y1){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y0, _fp_y0, ap.len(y0));
                x_vector_attach_to_array(ref _d_y1, _fp_y1, ap.len(y1));
                _error_code = _i_ser_sparsemv2(&_s_errormsg, &_d_s, &_d_x, &_d_y0, &_d_y1);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsemv2' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y0.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y0, ref y0);
            if( y0 == null )
                y0 = new double[0];
            if( _d_y1.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y1, ref y1);
            if( y1 == null )
                y1 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y0);
            x_vector_clear(ref _d_y1);
        }
        // This function returns no value.
    }
    public static void sparsemv2(sparsematrix s, double[] x, ref double[] y0, ref double[] y1)
    {
    _core_sparsemv2( s,  x, ref  y0, ref  y1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsesmv(sparsematrix s, bool isupper, double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_sparsesmv(&_s_errormsg, &_d_s, &_d_isupper, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsesmv' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void sparsesmv(sparsematrix s, bool isupper, double[] x, ref double[] y)
    {
    _core_sparsesmv( s,  isupper,  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe double _core_sparsevsmv(sparsematrix s, bool isupper, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_sparsevsmv(&_s_errormsg, &_d_result, &_d_s, &_d_isupper, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsevsmv' call");
            }
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double sparsevsmv(sparsematrix s, bool isupper, double[] x)
    {
    double result = _core_sparsevsmv( s,  isupper,  x, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_sparsemm(sparsematrix s, double[,] a, int k, ref double[,] b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_k = new x_int(k);
        x_matrix _d_b = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_ser_sparsemm(&_s_errormsg, &_d_s, &_d_a, &_d_k, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsemm' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void sparsemm(sparsematrix s, double[,] a, int k, ref double[,] b)
    {
    _core_sparsemm( s,  a,  k, ref  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsemtm(sparsematrix s, double[,] a, int k, ref double[,] b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_k = new x_int(k);
        x_matrix _d_b = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_ser_sparsemtm(&_s_errormsg, &_d_s, &_d_a, &_d_k, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsemtm' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void sparsemtm(sparsematrix s, double[,] a, int k, ref double[,] b)
    {
    _core_sparsemtm( s,  a,  k, ref  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsemm2(sparsematrix s, double[,] a, int k, ref double[,] b0, ref double[,] b1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_k = new x_int(k);
        x_matrix _d_b0 = new x_matrix();
        x_matrix _d_b1 = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b0 = b0, _fp_b1 = b1){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b0, _fp_b0, ap.rows(b0), ap.cols(b0));
                x_matrix_attach_to_array(ref _d_b1, _fp_b1, ap.rows(b1), ap.cols(b1));
                _error_code = _i_ser_sparsemm2(&_s_errormsg, &_d_s, &_d_a, &_d_k, &_d_b0, &_d_b1);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsemm2' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_b0.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b0, ref b0);
            if( b0 == null )
                b0 = new double[0,0];
            if( _d_b1.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b1, ref b1);
            if( b1 == null )
                b1 = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b0);
            x_matrix_clear(ref _d_b1);
        }
        // This function returns no value.
    }
    public static void sparsemm2(sparsematrix s, double[,] a, int k, ref double[,] b0, ref double[,] b1)
    {
    _core_sparsemm2( s,  a,  k, ref  b0, ref  b1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsesmm(sparsematrix s, bool isupper, double[,] a, int k, ref double[,] b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_a = new x_matrix();
        x_int _d_k = new x_int(k);
        x_matrix _d_b = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                _error_code = _i_ser_sparsesmm(&_s_errormsg, &_d_s, &_d_isupper, &_d_a, &_d_k, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsesmm' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void sparsesmm(sparsematrix s, bool isupper, double[,] a, int k, ref double[,] b)
    {
    _core_sparsesmm( s,  isupper,  a,  k, ref  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsetrmv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_sparsetrmv(&_s_errormsg, &_d_s, &_d_isupper, &_d_isunit, &_d_optype, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsetrmv' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void sparsetrmv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x, ref double[] y)
    {
    _core_sparsetrmv( s,  isupper,  isunit,  optype, ref  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsetrsv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_optype = new x_int(optype);
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_sparsetrsv(&_s_errormsg, &_d_s, &_d_isupper, &_d_isunit, &_d_optype, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsetrsv' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void sparsetrsv(sparsematrix s, bool isupper, bool isunit, int optype, ref double[] x)
    {
    _core_sparsetrsv( s,  isupper,  isunit,  optype, ref  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparseresizematrix(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseresizematrix(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseresizematrix' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparseresizematrix(sparsematrix s)
    {
    _core_sparseresizematrix( s, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_sparseenumerate(sparsematrix s, ref int t0, ref int t1, out int i, out int j, out double v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        x_int _d_t0 = new x_int(t0);
        x_int _d_t1 = new x_int(t1);
        x_int _d_i = new x_int();
        x_int _d_j = new x_int();
        double _d_v = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseenumerate(&_s_errormsg, &_d_result, &_d_s, &_d_t0, &_d_t1, &_d_i, &_d_j, &_d_v);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseenumerate' call");
            }
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            t0 = _d_t0.intval;
            t1 = _d_t1.intval;
            i = _d_i.intval;
            j = _d_j.intval;
            v = _d_v;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool sparseenumerate(sparsematrix s, ref int t0, ref int t1, out int i, out int j, out double v)
    {
    bool result = _core_sparseenumerate( s, ref  t0, ref  t1, out  i, out  j, out  v, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_sparserewriteexisting(sparsematrix s, int i, int j, double v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparserewriteexisting(&_s_errormsg, &_d_result, &_d_s, &_d_i, &_d_j, &_d_v);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparserewriteexisting' call");
            }
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool sparserewriteexisting(sparsematrix s, int i, int j, double v)
    {
    bool result = _core_sparserewriteexisting( s,  i,  j,  v, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_sparsegetrow(sparsematrix s, int i, ref double[] irow, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_vector _d_irow = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_irow = irow){
                x_vector_attach_to_array(ref _d_irow, _fp_irow, ap.len(irow));
                _error_code = _i_ser_sparsegetrow(&_s_errormsg, &_d_s, &_d_i, &_d_irow);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsegetrow' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_irow.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_irow, ref irow);
            if( irow == null )
                irow = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_irow);
        }
        // This function returns no value.
    }
    public static void sparsegetrow(sparsematrix s, int i, ref double[] irow)
    {
    _core_sparsegetrow( s,  i, ref  irow, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsegetcompressedrow(sparsematrix s, int i, ref int[] colidx, ref double[] vals, out int nzcnt, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_vector _d_colidx = new x_vector();
        x_vector _d_vals = new x_vector();
        x_int _d_nzcnt = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_vals = vals){
                x_vector_from_array(ref _d_colidx, colidx, X_CREATE);
                x_vector_attach_to_array(ref _d_vals, _fp_vals, ap.len(vals));
                _error_code = _i_ser_sparsegetcompressedrow(&_s_errormsg, &_d_s, &_d_i, &_d_colidx, &_d_vals, &_d_nzcnt);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsegetcompressedrow' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            x_vector_to_array(ref _d_colidx, ref colidx);
            if( _d_vals.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_vals, ref vals);
            if( vals == null )
                vals = new double[0];
            nzcnt = _d_nzcnt.intval;
        }
        finally
        {
            x_vector_clear(ref _d_colidx);
            x_vector_clear(ref _d_vals);
        }
        // This function returns no value.
    }
    public static void sparsegetcompressedrow(sparsematrix s, int i, ref int[] colidx, ref double[] vals, out int nzcnt)
    {
    _core_sparsegetcompressedrow( s,  i, ref  colidx, ref  vals, out  nzcnt, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsetransposesks(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsetransposesks(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsetransposesks' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparsetransposesks(sparsematrix s)
    {
    _core_sparsetransposesks( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparseconvertto(sparsematrix s0, int fmt, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        x_int _d_fmt = new x_int(fmt);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseconvertto(&_s_errormsg, &_d_s0, &_d_fmt);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseconvertto' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparseconvertto(sparsematrix s0, int fmt)
    {
    _core_sparseconvertto( s0,  fmt, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopytobuf(sparsematrix s0, int fmt, sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        x_int _d_fmt = new x_int(fmt);
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopytobuf(&_s_errormsg, &_d_s0, &_d_fmt, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopytobuf' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparsecopytobuf(sparsematrix s0, int fmt, sparsematrix s1)
    {
    _core_sparsecopytobuf( s0,  fmt,  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparseconverttohash(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseconverttohash(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseconverttohash' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparseconverttohash(sparsematrix s)
    {
    _core_sparseconverttohash( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopytohash(sparsematrix s0, out sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopytohash(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopytohash' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void sparsecopytohash(sparsematrix s0, out sparsematrix s1)
    {
    _core_sparsecopytohash( s0, out  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopytohashbuf(sparsematrix s0, sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopytohashbuf(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopytohashbuf' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparsecopytohashbuf(sparsematrix s0, sparsematrix s1)
    {
    _core_sparsecopytohashbuf( s0,  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparseconverttocrs(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseconverttocrs(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseconverttocrs' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparseconverttocrs(sparsematrix s)
    {
    _core_sparseconverttocrs( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopytocrs(sparsematrix s0, out sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopytocrs(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopytocrs' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void sparsecopytocrs(sparsematrix s0, out sparsematrix s1)
    {
    _core_sparsecopytocrs( s0, out  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopytocrsbuf(sparsematrix s0, sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopytocrsbuf(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopytocrsbuf' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparsecopytocrsbuf(sparsematrix s0, sparsematrix s1)
    {
    _core_sparsecopytocrsbuf( s0,  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparseconverttosks(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseconverttosks(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseconverttosks' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparseconverttosks(sparsematrix s)
    {
    _core_sparseconverttosks( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopytosks(sparsematrix s0, out sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = null;
        s1 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopytosks(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopytosks' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            s1 = new sparsematrix(_d_s1);
        }
        finally
        {
            if( _d_s1!=null && s1==null)
                _i_x_obj_free_sparsematrix(_d_s1); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void sparsecopytosks(sparsematrix s0, out sparsematrix s1)
    {
    _core_sparsecopytosks( s0, out  s1, alglibmode.serial);
    return;
    }
    private static unsafe void _core_sparsecopytosksbuf(sparsematrix s0, sparsematrix s1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s0 = s0.ptr;
        void *_d_s1 = s1.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecopytosksbuf(&_s_errormsg, &_d_s0, &_d_s1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecopytosksbuf' call");
            }
            ap.assert(s0.ptr==_d_s0, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(s1.ptr==_d_s1, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sparsecopytosksbuf(sparsematrix s0, sparsematrix s1)
    {
    _core_sparsecopytosksbuf( s0,  s1, alglibmode.serial);
    return;
    }
    private static unsafe int _core_sparsegetmatrixtype(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsegetmatrixtype(&_s_errormsg, &_d_result, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsegetmatrixtype' call");
            }
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int sparsegetmatrixtype(sparsematrix s)
    {
    int result = _core_sparsegetmatrixtype( s, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_sparseishash(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseishash(&_s_errormsg, &_d_result, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseishash' call");
            }
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool sparseishash(sparsematrix s)
    {
    bool result = _core_sparseishash( s, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_sparseiscrs(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseiscrs(&_s_errormsg, &_d_result, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseiscrs' call");
            }
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool sparseiscrs(sparsematrix s)
    {
    bool result = _core_sparseiscrs( s, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_sparseissks(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparseissks(&_s_errormsg, &_d_result, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparseissks' call");
            }
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool sparseissks(sparsematrix s)
    {
    bool result = _core_sparseissks( s, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_sparsefree(out sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsefree(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsefree' call");
            }
            s = new sparsematrix(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_sparsematrix(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void sparsefree(out sparsematrix s)
    {
    _core_sparsefree(out  s, alglibmode.serial);
    return;
    }
    private static unsafe int _core_sparsegetnrows(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsegetnrows(&_s_errormsg, &_d_result, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsegetnrows' call");
            }
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int sparsegetnrows(sparsematrix s)
    {
    int result = _core_sparsegetnrows( s, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_sparsegetncols(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsegetncols(&_s_errormsg, &_d_result, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsegetncols' call");
            }
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int sparsegetncols(sparsematrix s)
    {
    int result = _core_sparsegetncols( s, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_sparsegetuppercount(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsegetuppercount(&_s_errormsg, &_d_result, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsegetuppercount' call");
            }
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int sparsegetuppercount(sparsematrix s)
    {
    int result = _core_sparsegetuppercount( s, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_sparsegetlowercount(sparsematrix s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsegetlowercount(&_s_errormsg, &_d_result, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsegetlowercount' call");
            }
            result = _d_result.intval;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int sparsegetlowercount(sparsematrix s)
    {
    int result = _core_sparsegetlowercount( s, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage trfac
    //
    
    private static unsafe void _core_rmatrixlu(ref double[,] a, int m, int n, out int[] pivots, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_pivots = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_pivots, DT_INT);
                pivots = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixlu(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_pivots);
                else    _error_code = _i_smp_rmatrixlu(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_pivots);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlu' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            x_vector_to_array(ref _d_pivots, ref pivots);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
        }
        // This function returns no value.
    }
    public static void rmatrixlu(ref double[,] a, int m, int n, out int[] pivots)
    {
    _core_rmatrixlu(ref  a,  m,  n, out  pivots, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixlu(ref double[,] a, int m, int n, out int[] pivots)
    {
    _core_rmatrixlu(ref  a,  m,  n, out  pivots, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixlu(ref complex[,] a, int m, int n, out int[] pivots, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_vector _d_pivots = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_create_empty(ref _d_pivots, DT_INT);
                pivots = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixlu(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_pivots);
                else    _error_code = _i_smp_cmatrixlu(&_s_errormsg, &_d_a, &_d_m, &_d_n, &_d_pivots);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlu' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            x_vector_to_array(ref _d_pivots, ref pivots);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
        }
        // This function returns no value.
    }
    public static void cmatrixlu(ref complex[,] a, int m, int n, out int[] pivots)
    {
    _core_cmatrixlu(ref  a,  m,  n, out  pivots, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixlu(ref complex[,] a, int m, int n, out int[] pivots)
    {
    _core_cmatrixlu(ref  a,  m,  n, out  pivots, alglibmode.parallel);
    return;
    }
    private static unsafe bool _core_hpdmatrixcholesky(ref complex[,] a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixcholesky(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
                else    _error_code = _i_smp_hpdmatrixcholesky(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixcholesky' call");
            }
            result = _d_result!=0;
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static bool hpdmatrixcholesky(ref complex[,] a, int n, bool isupper)
    {
    bool result = _core_hpdmatrixcholesky(ref  a,  n,  isupper, alglibmode.serial);
    return result;
    }
    public static bool smp_hpdmatrixcholesky(ref complex[,] a, int n, bool isupper)
    {
    bool result = _core_hpdmatrixcholesky(ref  a,  n,  isupper, alglibmode.parallel);
    return result;
    }
    private static unsafe bool _core_spdmatrixcholesky(ref double[,] a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixcholesky(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
                else    _error_code = _i_smp_spdmatrixcholesky(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholesky' call");
            }
            result = _d_result!=0;
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static bool spdmatrixcholesky(ref double[,] a, int n, bool isupper)
    {
    bool result = _core_spdmatrixcholesky(ref  a,  n,  isupper, alglibmode.serial);
    return result;
    }
    public static bool smp_spdmatrixcholesky(ref double[,] a, int n, bool isupper)
    {
    bool result = _core_spdmatrixcholesky(ref  a,  n,  isupper, alglibmode.parallel);
    return result;
    }
    private static unsafe void _core_spdmatrixcholeskyupdateadd1(ref double[,] a, int n, bool isupper, double[] u, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_u = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_u = u){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                _error_code = _i_ser_spdmatrixcholeskyupdateadd1(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_u);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskyupdateadd1' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskyupdateadd1(ref double[,] a, int n, bool isupper, double[] u)
    {
    _core_spdmatrixcholeskyupdateadd1(ref  a,  n,  isupper,  u, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spdmatrixcholeskyupdatefix(ref double[,] a, int n, bool isupper, bool[] fix, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_fix = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){fixed(bool* _fp_fix = fix){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_fix, _fp_fix, ap.len(fix));
                _error_code = _i_ser_spdmatrixcholeskyupdatefix(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_fix);
            }}
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskyupdatefix' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_fix);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskyupdatefix(ref double[,] a, int n, bool isupper, bool[] fix)
    {
    _core_spdmatrixcholeskyupdatefix(ref  a,  n,  isupper,  fix, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spdmatrixcholeskyupdateadd1buf(ref double[,] a, int n, bool isupper, double[] u, ref double[] bufr, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_u = new x_vector();
        x_vector _d_bufr = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_u = u, _fp_bufr = bufr){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_bufr, _fp_bufr, ap.len(bufr));
                _error_code = _i_ser_spdmatrixcholeskyupdateadd1buf(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_u, &_d_bufr);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskyupdateadd1buf' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_bufr.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_bufr, ref bufr);
            if( bufr == null )
                bufr = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_bufr);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskyupdateadd1buf(ref double[,] a, int n, bool isupper, double[] u, ref double[] bufr)
    {
    _core_spdmatrixcholeskyupdateadd1buf(ref  a,  n,  isupper,  u, ref  bufr, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spdmatrixcholeskyupdatefixbuf(ref double[,] a, int n, bool isupper, bool[] fix, ref double[] bufr, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_fix = new x_vector();
        x_vector _d_bufr = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_bufr = bufr){fixed(bool* _fp_fix = fix){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_fix, _fp_fix, ap.len(fix));
                x_vector_attach_to_array(ref _d_bufr, _fp_bufr, ap.len(bufr));
                _error_code = _i_ser_spdmatrixcholeskyupdatefixbuf(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_fix, &_d_bufr);
            }}
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskyupdatefixbuf' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_bufr.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_bufr, ref bufr);
            if( bufr == null )
                bufr = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_fix);
            x_vector_clear(ref _d_bufr);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskyupdatefixbuf(ref double[,] a, int n, bool isupper, bool[] fix, ref double[] bufr)
    {
    _core_spdmatrixcholeskyupdatefixbuf(ref  a,  n,  isupper,  fix, ref  bufr, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_sparsecholeskyskyline(sparsematrix a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_a = a.ptr;
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sparsecholeskyskyline(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sparsecholeskyskyline' call");
            }
            result = _d_result!=0;
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool sparsecholeskyskyline(sparsematrix a, int n, bool isupper)
    {
    bool result = _core_sparsecholeskyskyline( a,  n,  isupper, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage rcond
    //
    
    private static unsafe double _core_rmatrixrcond1(double[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_rmatrixrcond1(&_s_errormsg, &_d_result, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixrcond1' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double rmatrixrcond1(double[,] a, int n)
    {
    double result = _core_rmatrixrcond1( a,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_rmatrixrcondinf(double[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_rmatrixrcondinf(&_s_errormsg, &_d_result, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixrcondinf' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double rmatrixrcondinf(double[,] a, int n)
    {
    double result = _core_rmatrixrcondinf( a,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_spdmatrixrcond(double[,] a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_spdmatrixrcond(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixrcond' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double spdmatrixrcond(double[,] a, int n, bool isupper)
    {
    double result = _core_spdmatrixrcond( a,  n,  isupper, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_rmatrixtrrcond1(double[,] a, int n, bool isupper, bool isunit, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_rmatrixtrrcond1(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, &_d_isunit);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixtrrcond1' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double rmatrixtrrcond1(double[,] a, int n, bool isupper, bool isunit)
    {
    double result = _core_rmatrixtrrcond1( a,  n,  isupper,  isunit, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_rmatrixtrrcondinf(double[,] a, int n, bool isupper, bool isunit, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_rmatrixtrrcondinf(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, &_d_isunit);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixtrrcondinf' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double rmatrixtrrcondinf(double[,] a, int n, bool isupper, bool isunit)
    {
    double result = _core_rmatrixtrrcondinf( a,  n,  isupper,  isunit, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_hpdmatrixrcond(complex[,] a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_hpdmatrixrcond(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixrcond' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double hpdmatrixrcond(complex[,] a, int n, bool isupper)
    {
    double result = _core_hpdmatrixrcond( a,  n,  isupper, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_cmatrixrcond1(complex[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_cmatrixrcond1(&_s_errormsg, &_d_result, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixrcond1' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double cmatrixrcond1(complex[,] a, int n)
    {
    double result = _core_cmatrixrcond1( a,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_cmatrixrcondinf(complex[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_cmatrixrcondinf(&_s_errormsg, &_d_result, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixrcondinf' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double cmatrixrcondinf(complex[,] a, int n)
    {
    double result = _core_cmatrixrcondinf( a,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_rmatrixlurcond1(double[,] lua, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_lua = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                _error_code = _i_ser_rmatrixlurcond1(&_s_errormsg, &_d_result, &_d_lua, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlurcond1' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
        }
        return result;
    }
    public static double rmatrixlurcond1(double[,] lua, int n)
    {
    double result = _core_rmatrixlurcond1( lua,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_rmatrixlurcondinf(double[,] lua, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_lua = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                _error_code = _i_ser_rmatrixlurcondinf(&_s_errormsg, &_d_result, &_d_lua, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlurcondinf' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
        }
        return result;
    }
    public static double rmatrixlurcondinf(double[,] lua, int n)
    {
    double result = _core_rmatrixlurcondinf( lua,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_spdmatrixcholeskyrcond(double[,] a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_spdmatrixcholeskyrcond(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskyrcond' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double spdmatrixcholeskyrcond(double[,] a, int n, bool isupper)
    {
    double result = _core_spdmatrixcholeskyrcond( a,  n,  isupper, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_hpdmatrixcholeskyrcond(complex[,] a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_hpdmatrixcholeskyrcond(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixcholeskyrcond' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double hpdmatrixcholeskyrcond(complex[,] a, int n, bool isupper)
    {
    double result = _core_hpdmatrixcholeskyrcond( a,  n,  isupper, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_cmatrixlurcond1(complex[,] lua, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_lua = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                _error_code = _i_ser_cmatrixlurcond1(&_s_errormsg, &_d_result, &_d_lua, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlurcond1' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
        }
        return result;
    }
    public static double cmatrixlurcond1(complex[,] lua, int n)
    {
    double result = _core_cmatrixlurcond1( lua,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_cmatrixlurcondinf(complex[,] lua, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_lua = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                _error_code = _i_ser_cmatrixlurcondinf(&_s_errormsg, &_d_result, &_d_lua, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlurcondinf' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
        }
        return result;
    }
    public static double cmatrixlurcondinf(complex[,] lua, int n)
    {
    double result = _core_cmatrixlurcondinf( lua,  n, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_cmatrixtrrcond1(complex[,] a, int n, bool isupper, bool isunit, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_cmatrixtrrcond1(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, &_d_isunit);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixtrrcond1' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double cmatrixtrrcond1(complex[,] a, int n, bool isupper, bool isunit)
    {
    double result = _core_cmatrixtrrcond1( a,  n,  isupper,  isunit, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_cmatrixtrrcondinf(complex[,] a, int n, bool isupper, bool isunit, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_cmatrixtrrcondinf(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper, &_d_isunit);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixtrrcondinf' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double cmatrixtrrcondinf(complex[,] a, int n, bool isupper, bool isunit)
    {
    double result = _core_cmatrixtrrcondinf( a,  n,  isupper,  isunit, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage matinv
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_matinvreport
    {
        public double r1;
        public double rinf;
    }

    public class matinvreport : alglibobject
    {
        public double r1;
        public double rinf;
        public override alglib.alglibobject make_copy()
        {
            matinvreport dst = new matinvreport();
            dst.r1 = r1;
            dst.rinf = rinf;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_matinvreport_init(ref x_matinvreport x)
    {
        x.r1 = 0;
        x.rinf = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_matinvreport_clear(ref x_matinvreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_matinvreport_init_from(ref x_matinvreport x, matinvreport v)
    {
        x.r1 = v.r1;
        x.rinf = v.rinf;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_matinvreport_to_record(ref x_matinvreport x, ref matinvreport v)
    {
        if( v==null )
            v = new matinvreport();
        v.r1 = x.r1;
        v.rinf = x.rinf;
    }
    private static unsafe void _core_rmatrixluinverse(ref double[,] a, int[] pivots, int n, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_vector _d_pivots = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_pivots, pivots, X_CREATE);
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixluinverse(&_s_errormsg, &_d_a, &_d_pivots, &_d_n, &_d_info, &_d_rep);
                else    _error_code = _i_smp_rmatrixluinverse(&_s_errormsg, &_d_a, &_d_pivots, &_d_n, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixluinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void rmatrixluinverse(ref double[,] a, int[] pivots, int n, out int info, out matinvreport rep)
    {
    _core_rmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void rmatrixluinverse(ref double[,] a, int[] pivots, out int info, out matinvreport rep)
    {
    int n;
    
    if( (ap.cols(a)!=ap.rows(a)) || (ap.cols(a)!=ap.len(pivots)))
        throw new alglibexception("Error while calling 'rmatrixluinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    
    _core_rmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_rmatrixluinverse(ref double[,] a, int[] pivots, int n, out int info, out matinvreport rep)
    {
    _core_rmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_rmatrixluinverse(ref double[,] a, int[] pivots, out int info, out matinvreport rep)
    {
    int n;
    
    if( (ap.cols(a)!=ap.rows(a)) || (ap.cols(a)!=ap.len(pivots)))
        throw new alglibexception("Error while calling 'rmatrixluinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    
    _core_rmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_rmatrixinverse(ref double[,] a, int n, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_info, &_d_rep);
                else    _error_code = _i_smp_rmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void rmatrixinverse(ref double[,] a, int n, out int info, out matinvreport rep)
    {
    _core_rmatrixinverse(ref  a,  n, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void rmatrixinverse(ref double[,] a, out int info, out matinvreport rep)
    {
    int n;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'rmatrixinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    
    _core_rmatrixinverse(ref  a,  n, out  info, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_rmatrixinverse(ref double[,] a, int n, out int info, out matinvreport rep)
    {
    _core_rmatrixinverse(ref  a,  n, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_rmatrixinverse(ref double[,] a, out int info, out matinvreport rep)
    {
    int n;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'rmatrixinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    
    _core_rmatrixinverse(ref  a,  n, out  info, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_cmatrixluinverse(ref complex[,] a, int[] pivots, int n, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_vector _d_pivots = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_pivots, pivots, X_CREATE);
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixluinverse(&_s_errormsg, &_d_a, &_d_pivots, &_d_n, &_d_info, &_d_rep);
                else    _error_code = _i_smp_cmatrixluinverse(&_s_errormsg, &_d_a, &_d_pivots, &_d_n, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixluinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void cmatrixluinverse(ref complex[,] a, int[] pivots, int n, out int info, out matinvreport rep)
    {
    _core_cmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void cmatrixluinverse(ref complex[,] a, int[] pivots, out int info, out matinvreport rep)
    {
    int n;
    
    if( (ap.cols(a)!=ap.rows(a)) || (ap.cols(a)!=ap.len(pivots)))
        throw new alglibexception("Error while calling 'cmatrixluinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    
    _core_cmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_cmatrixluinverse(ref complex[,] a, int[] pivots, int n, out int info, out matinvreport rep)
    {
    _core_cmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_cmatrixluinverse(ref complex[,] a, int[] pivots, out int info, out matinvreport rep)
    {
    int n;
    
    if( (ap.cols(a)!=ap.rows(a)) || (ap.cols(a)!=ap.len(pivots)))
        throw new alglibexception("Error while calling 'cmatrixluinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    
    _core_cmatrixluinverse(ref  a,  pivots,  n, out  info, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_cmatrixinverse(ref complex[,] a, int n, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_info, &_d_rep);
                else    _error_code = _i_smp_cmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void cmatrixinverse(ref complex[,] a, int n, out int info, out matinvreport rep)
    {
    _core_cmatrixinverse(ref  a,  n, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void cmatrixinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
    int n;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'cmatrixinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    
    _core_cmatrixinverse(ref  a,  n, out  info, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_cmatrixinverse(ref complex[,] a, int n, out int info, out matinvreport rep)
    {
    _core_cmatrixinverse(ref  a,  n, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_cmatrixinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
    int n;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'cmatrixinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    
    _core_cmatrixinverse(ref  a,  n, out  info, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spdmatrixcholeskyinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixcholeskyinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep);
                else    _error_code = _i_smp_spdmatrixcholeskyinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskyinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskyinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
    _core_spdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void spdmatrixcholeskyinverse(ref double[,] a, out int info, out matinvreport rep)
    {
    int n;
    bool isupper;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'spdmatrixcholeskyinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isupper = false;
    
    _core_spdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_spdmatrixcholeskyinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
    _core_spdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_spdmatrixcholeskyinverse(ref double[,] a, out int info, out matinvreport rep)
    {
    int n;
    bool isupper;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'spdmatrixcholeskyinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isupper = false;
    
    _core_spdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spdmatrixinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep);
                else    _error_code = _i_smp_spdmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void spdmatrixinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
    _core_spdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void spdmatrixinverse(ref double[,] a, out int info, out matinvreport rep)
    {
    int n;
    bool isupper;
    
    if( !alglib.ap.issymmetric(a) )
        throw new alglibexception("'a' parameter is not symmetric matrix");
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'spdmatrixinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isupper = false;
    
    _core_spdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.serial);
    if( !alglib.ap.forcesymmetric(a) )
        throw new alglibexception("Internal error while forcing symmetric properties for 'a' parameter");
    
    return;
    }
    public static void smp_spdmatrixinverse(ref double[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
    _core_spdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_spdmatrixinverse(ref double[,] a, out int info, out matinvreport rep)
    {
    int n;
    bool isupper;
    
    if( !alglib.ap.issymmetric(a) )
        throw new alglibexception("'a' parameter is not symmetric matrix");
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'spdmatrixinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isupper = false;
    
    _core_spdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.parallel);
    if( !alglib.ap.forcesymmetric(a) )
        throw new alglibexception("Internal error while forcing symmetric properties for 'a' parameter");
    
    return;
    }
    private static unsafe void _core_hpdmatrixcholeskyinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixcholeskyinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep);
                else    _error_code = _i_smp_hpdmatrixcholeskyinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixcholeskyinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void hpdmatrixcholeskyinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
    _core_hpdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void hpdmatrixcholeskyinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
    int n;
    bool isupper;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'hpdmatrixcholeskyinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isupper = false;
    
    _core_hpdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_hpdmatrixcholeskyinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
    _core_hpdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_hpdmatrixcholeskyinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
    int n;
    bool isupper;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'hpdmatrixcholeskyinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isupper = false;
    
    _core_hpdmatrixcholeskyinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_hpdmatrixinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep);
                else    _error_code = _i_smp_hpdmatrixinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void hpdmatrixinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
    _core_hpdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void hpdmatrixinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
    int n;
    bool isupper;
    
    if( !alglib.ap.ishermitian(a) )
        throw new alglibexception("'a' parameter is not hermitian matrix");
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'hpdmatrixinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isupper = false;
    
    _core_hpdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.serial);
    if( !alglib.ap.forcehermitian(a) )
        throw new alglibexception("Internal error while forcing hermitian properties for 'a' parameter");
    
    return;
    }
    public static void smp_hpdmatrixinverse(ref complex[,] a, int n, bool isupper, out int info, out matinvreport rep)
    {
    _core_hpdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_hpdmatrixinverse(ref complex[,] a, out int info, out matinvreport rep)
    {
    int n;
    bool isupper;
    
    if( !alglib.ap.ishermitian(a) )
        throw new alglibexception("'a' parameter is not hermitian matrix");
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'hpdmatrixinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isupper = false;
    
    _core_hpdmatrixinverse(ref  a,  n,  isupper, out  info, out  rep, alglibmode.parallel);
    if( !alglib.ap.forcehermitian(a) )
        throw new alglibexception("Internal error while forcing hermitian properties for 'a' parameter");
    
    return;
    }
    private static unsafe void _core_rmatrixtrinverse(ref double[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixtrinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_isunit, &_d_info, &_d_rep);
                else    _error_code = _i_smp_rmatrixtrinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_isunit, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixtrinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void rmatrixtrinverse(ref double[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep)
    {
    _core_rmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void rmatrixtrinverse(ref double[,] a, bool isupper, out int info, out matinvreport rep)
    {
    int n;
    bool isunit;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'rmatrixtrinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isunit = false;
    
    _core_rmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_rmatrixtrinverse(ref double[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep)
    {
    _core_rmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_rmatrixtrinverse(ref double[,] a, bool isupper, out int info, out matinvreport rep)
    {
    int n;
    bool isunit;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'rmatrixtrinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isunit = false;
    
    _core_rmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_cmatrixtrinverse(ref complex[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        byte _d_isunit = (byte)(isunit ? 1 : 0);
        x_int _d_info = new x_int();
        x_matinvreport _d_rep = new x_matinvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matinvreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixtrinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_isunit, &_d_info, &_d_rep);
                else    _error_code = _i_smp_cmatrixtrinverse(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_isunit, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixtrinverse' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0,0];
            info = _d_info.intval;
            rep = null;
            x_matinvreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matinvreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void cmatrixtrinverse(ref complex[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep)
    {
    _core_cmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, alglibmode.serial);
    return;
    }
    public static void cmatrixtrinverse(ref complex[,] a, bool isupper, out int info, out matinvreport rep)
    {
    int n;
    bool isunit;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'cmatrixtrinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isunit = false;
    
    _core_cmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_cmatrixtrinverse(ref complex[,] a, int n, bool isupper, bool isunit, out int info, out matinvreport rep)
    {
    _core_cmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_cmatrixtrinverse(ref complex[,] a, bool isupper, out int info, out matinvreport rep)
    {
    int n;
    bool isunit;
    
    if( (ap.cols(a)!=ap.rows(a)))
        throw new alglibexception("Error while calling 'cmatrixtrinverse': looks like one of arguments has wrong size");
    
    n = ap.cols(a);
    isunit = false;
    
    _core_cmatrixtrinverse(ref  a,  n,  isupper,  isunit, out  info, out  rep, alglibmode.parallel);
    
    return;
    }
    
    
    //
    // Subpackage lda
    //
    
    private static unsafe void _core_fisherlda(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_info = new x_int();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_ser_fisherlda(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_info, &_d_w);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fisherlda' call");
            }
            info = _d_info.intval;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void fisherlda(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[] w)
    {
    _core_fisherlda( xy,  npoints,  nvars,  nclasses, out  info, out  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_fisherldan(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[,] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_info = new x_int();
        x_matrix _d_w = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_matrix_create_empty(ref _d_w, DT_REAL);
                w = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_fisherldan(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_info, &_d_w);
                else    _error_code = _i_smp_fisherldan(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_info, &_d_w);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fisherldan' call");
            }
            info = _d_info.intval;
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_matrix_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void fisherldan(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[,] w)
    {
    _core_fisherldan( xy,  npoints,  nvars,  nclasses, out  info, out  w, alglibmode.serial);
    return;
    }
    public static void smp_fisherldan(double[,] xy, int npoints, int nvars, int nclasses, out int info, out double[,] w)
    {
    _core_fisherldan( xy,  npoints,  nvars,  nclasses, out  info, out  w, alglibmode.parallel);
    return;
    }
    
    
    //
    // Subpackage mlpbase
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_modelerrors
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
    }

    public class modelerrors : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public override alglib.alglibobject make_copy()
        {
            modelerrors dst = new modelerrors();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_modelerrors_init(ref x_modelerrors x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_modelerrors_clear(ref x_modelerrors x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_modelerrors_init_from(ref x_modelerrors x, modelerrors v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_modelerrors_to_record(ref x_modelerrors x, ref modelerrors v)
    {
        if( v==null )
            v = new modelerrors();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
    }

    public unsafe class multilayerperceptron : alglibobject
    {
        public void *ptr;
        public multilayerperceptron(void *x)
        {
            ptr = x;
        }
        ~multilayerperceptron()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new multilayerperceptron(null);
            return new multilayerperceptron(_i_x_obj_copy_multilayerperceptron(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_multilayerperceptron(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_multilayerperceptron(void *x);
    private static _d_x_obj_copy_multilayerperceptron _i_x_obj_copy_multilayerperceptron = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_multilayerperceptron(void *x);
    private static _d_x_obj_free_multilayerperceptron _i_x_obj_free_multilayerperceptron = null;
    public static unsafe void mlpserialize(multilayerperceptron obj, out string s_out)
    {
        byte *_error_msg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        int _error_code = _i_x_mlpserialize(&_error_msg, &_x, &_out);
        if( _error_code!=X_OK )
            throw new alglibexception(_error_code==X_ASSERTION_FAILED
                ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                : "ALGLIB: unknown error during mlpserialize() call");
        s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        x_free((IntPtr)_out);
    }
    
    public static unsafe void mlpunserialize(string s_in, out multilayerperceptron obj)
    {
        byte *_error_msg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            int _error_code = _i_x_mlpunserialize(&_error_msg, &_in, &_x);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                    : "ALGLIB: unknown error during mlpunserialize() call");
            obj = new multilayerperceptron(_x);
        }
    }
    private static unsafe void _core_mlpcreate0(int nin, int nout, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreate0(&_s_errormsg, &_d_nin, &_d_nout, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreate0' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreate0(int nin, int nout, out multilayerperceptron network)
    {
    _core_mlpcreate0( nin,  nout, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreate1(int nin, int nhid, int nout, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreate1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreate1' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreate1(int nin, int nhid, int nout, out multilayerperceptron network)
    {
    _core_mlpcreate1( nin,  nhid,  nout, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreate2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreate2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreate2' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreate2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network)
    {
    _core_mlpcreate2( nin,  nhid1,  nhid2,  nout, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreateb0(int nin, int nout, double b, double d, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreateb0(&_s_errormsg, &_d_nin, &_d_nout, &_d_b, &_d_d, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreateb0' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreateb0(int nin, int nout, double b, double d, out multilayerperceptron network)
    {
    _core_mlpcreateb0( nin,  nout,  b,  d, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreateb1(int nin, int nhid, int nout, double b, double d, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreateb1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_b, &_d_d, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreateb1' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreateb1(int nin, int nhid, int nout, double b, double d, out multilayerperceptron network)
    {
    _core_mlpcreateb1( nin,  nhid,  nout,  b,  d, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreateb2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_b, &_d_d, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreateb2' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, out multilayerperceptron network)
    {
    _core_mlpcreateb2( nin,  nhid1,  nhid2,  nout,  b,  d, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreater0(int nin, int nout, double a, double b, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreater0(&_s_errormsg, &_d_nin, &_d_nout, &_d_a, &_d_b, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreater0' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreater0(int nin, int nout, double a, double b, out multilayerperceptron network)
    {
    _core_mlpcreater0( nin,  nout,  a,  b, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreater1(int nin, int nhid, int nout, double a, double b, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreater1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_a, &_d_b, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreater1' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreater1(int nin, int nhid, int nout, double a, double b, out multilayerperceptron network)
    {
    _core_mlpcreater1( nin,  nhid,  nout,  a,  b, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreater2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_a, &_d_b, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreater2' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, out multilayerperceptron network)
    {
    _core_mlpcreater2( nin,  nhid1,  nhid2,  nout,  a,  b, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreatec0(int nin, int nout, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreatec0(&_s_errormsg, &_d_nin, &_d_nout, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreatec0' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreatec0(int nin, int nout, out multilayerperceptron network)
    {
    _core_mlpcreatec0( nin,  nout, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreatec1(int nin, int nhid, int nout, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreatec1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreatec1' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreatec1(int nin, int nhid, int nout, out multilayerperceptron network)
    {
    _core_mlpcreatec1( nin,  nhid,  nout, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreatec2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        void *_d_network = null;
        network = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreatec2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreatec2' call");
            }
            network = new multilayerperceptron(_d_network);
        }
        finally
        {
            if( _d_network!=null && network==null)
                _i_x_obj_free_multilayerperceptron(_d_network); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreatec2(int nin, int nhid1, int nhid2, int nout, out multilayerperceptron network)
    {
    _core_mlpcreatec2( nin,  nhid1,  nhid2,  nout, out  network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcopy(multilayerperceptron network1, out multilayerperceptron network2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network1 = network1.ptr;
        void *_d_network2 = null;
        network2 = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcopy(&_s_errormsg, &_d_network1, &_d_network2);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcopy' call");
            }
            ap.assert(network1.ptr==_d_network1, "ALGLIB: internal error (reference changed for non-out X-object)");
            network2 = new multilayerperceptron(_d_network2);
        }
        finally
        {
            if( _d_network2!=null && network2==null)
                _i_x_obj_free_multilayerperceptron(_d_network2); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcopy(multilayerperceptron network1, out multilayerperceptron network2)
    {
    _core_mlpcopy( network1, out  network2, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcopytunableparameters(multilayerperceptron network1, multilayerperceptron network2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network1 = network1.ptr;
        void *_d_network2 = network2.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcopytunableparameters(&_s_errormsg, &_d_network1, &_d_network2);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcopytunableparameters' call");
            }
            ap.assert(network1.ptr==_d_network1, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network2.ptr==_d_network2, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpcopytunableparameters(multilayerperceptron network1, multilayerperceptron network2)
    {
    _core_mlpcopytunableparameters( network1,  network2, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlprandomize(multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlprandomize(&_s_errormsg, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlprandomize' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlprandomize(multilayerperceptron network)
    {
    _core_mlprandomize( network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlprandomizefull(multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlprandomizefull(&_s_errormsg, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlprandomizefull' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlprandomizefull(multilayerperceptron network)
    {
    _core_mlprandomizefull( network, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpinitpreprocessor(multilayerperceptron network, double[,] xy, int ssize, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mlpinitpreprocessor(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpinitpreprocessor' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void mlpinitpreprocessor(multilayerperceptron network, double[,] xy, int ssize)
    {
    _core_mlpinitpreprocessor( network,  xy,  ssize, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpproperties(multilayerperceptron network, out int nin, out int nout, out int wcount, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_nin = new x_int();
        x_int _d_nout = new x_int();
        x_int _d_wcount = new x_int();
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpproperties(&_s_errormsg, &_d_network, &_d_nin, &_d_nout, &_d_wcount);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpproperties' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            nin = _d_nin.intval;
            nout = _d_nout.intval;
            wcount = _d_wcount.intval;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpproperties(multilayerperceptron network, out int nin, out int nout, out int wcount)
    {
    _core_mlpproperties( network, out  nin, out  nout, out  wcount, alglibmode.serial);
    return;
    }
    private static unsafe int _core_mlpgetinputscount(multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetinputscount(&_s_errormsg, &_d_result, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetinputscount' call");
            }
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int mlpgetinputscount(multilayerperceptron network)
    {
    int result = _core_mlpgetinputscount( network, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_mlpgetoutputscount(multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetoutputscount(&_s_errormsg, &_d_result, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetoutputscount' call");
            }
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int mlpgetoutputscount(multilayerperceptron network)
    {
    int result = _core_mlpgetoutputscount( network, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_mlpgetweightscount(multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetweightscount(&_s_errormsg, &_d_result, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetweightscount' call");
            }
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int mlpgetweightscount(multilayerperceptron network)
    {
    int result = _core_mlpgetweightscount( network, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_mlpissoftmax(multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpissoftmax(&_s_errormsg, &_d_result, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpissoftmax' call");
            }
            result = _d_result!=0;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool mlpissoftmax(multilayerperceptron network)
    {
    bool result = _core_mlpissoftmax( network, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_mlpgetlayerscount(multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetlayerscount(&_s_errormsg, &_d_result, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetlayerscount' call");
            }
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int mlpgetlayerscount(multilayerperceptron network)
    {
    int result = _core_mlpgetlayerscount( network, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_mlpgetlayersize(multilayerperceptron network, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetlayersize(&_s_errormsg, &_d_result, &_d_network, &_d_k);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetlayersize' call");
            }
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static int mlpgetlayersize(multilayerperceptron network, int k)
    {
    int result = _core_mlpgetlayersize( network,  k, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_mlpgetinputscaling(multilayerperceptron network, int i, out double mean, out double sigma, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_i = new x_int(i);
        double _d_mean = 0;
        double _d_sigma = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetinputscaling(&_s_errormsg, &_d_network, &_d_i, &_d_mean, &_d_sigma);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetinputscaling' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            mean = _d_mean;
            sigma = _d_sigma;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpgetinputscaling(multilayerperceptron network, int i, out double mean, out double sigma)
    {
    _core_mlpgetinputscaling( network,  i, out  mean, out  sigma, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpgetoutputscaling(multilayerperceptron network, int i, out double mean, out double sigma, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_i = new x_int(i);
        double _d_mean = 0;
        double _d_sigma = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetoutputscaling(&_s_errormsg, &_d_network, &_d_i, &_d_mean, &_d_sigma);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetoutputscaling' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            mean = _d_mean;
            sigma = _d_sigma;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpgetoutputscaling(multilayerperceptron network, int i, out double mean, out double sigma)
    {
    _core_mlpgetoutputscaling( network,  i, out  mean, out  sigma, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpgetneuroninfo(multilayerperceptron network, int k, int i, out int fkind, out double threshold, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_k = new x_int(k);
        x_int _d_i = new x_int(i);
        x_int _d_fkind = new x_int();
        double _d_threshold = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetneuroninfo(&_s_errormsg, &_d_network, &_d_k, &_d_i, &_d_fkind, &_d_threshold);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetneuroninfo' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            fkind = _d_fkind.intval;
            threshold = _d_threshold;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpgetneuroninfo(multilayerperceptron network, int k, int i, out int fkind, out double threshold)
    {
    _core_mlpgetneuroninfo( network,  k,  i, out  fkind, out  threshold, alglibmode.serial);
    return;
    }
    private static unsafe double _core_mlpgetweight(multilayerperceptron network, int k0, int i0, int k1, int i1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_int _d_k0 = new x_int(k0);
        x_int _d_i0 = new x_int(i0);
        x_int _d_k1 = new x_int(k1);
        x_int _d_i1 = new x_int(i1);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpgetweight(&_s_errormsg, &_d_result, &_d_network, &_d_k0, &_d_i0, &_d_k1, &_d_i1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgetweight' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double mlpgetweight(multilayerperceptron network, int k0, int i0, int k1, int i1)
    {
    double result = _core_mlpgetweight( network,  k0,  i0,  k1,  i1, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_mlpsetinputscaling(multilayerperceptron network, int i, double mean, double sigma, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_i = new x_int(i);
        double _d_mean = mean;
        double _d_sigma = sigma;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpsetinputscaling(&_s_errormsg, &_d_network, &_d_i, &_d_mean, &_d_sigma);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetinputscaling' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpsetinputscaling(multilayerperceptron network, int i, double mean, double sigma)
    {
    _core_mlpsetinputscaling( network,  i,  mean,  sigma, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpsetoutputscaling(multilayerperceptron network, int i, double mean, double sigma, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_i = new x_int(i);
        double _d_mean = mean;
        double _d_sigma = sigma;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpsetoutputscaling(&_s_errormsg, &_d_network, &_d_i, &_d_mean, &_d_sigma);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetoutputscaling' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpsetoutputscaling(multilayerperceptron network, int i, double mean, double sigma)
    {
    _core_mlpsetoutputscaling( network,  i,  mean,  sigma, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpsetneuroninfo(multilayerperceptron network, int k, int i, int fkind, double threshold, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_k = new x_int(k);
        x_int _d_i = new x_int(i);
        x_int _d_fkind = new x_int(fkind);
        double _d_threshold = threshold;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpsetneuroninfo(&_s_errormsg, &_d_network, &_d_k, &_d_i, &_d_fkind, &_d_threshold);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetneuroninfo' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpsetneuroninfo(multilayerperceptron network, int k, int i, int fkind, double threshold)
    {
    _core_mlpsetneuroninfo( network,  k,  i,  fkind,  threshold, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpsetweight(multilayerperceptron network, int k0, int i0, int k1, int i1, double w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_k0 = new x_int(k0);
        x_int _d_i0 = new x_int(i0);
        x_int _d_k1 = new x_int(k1);
        x_int _d_i1 = new x_int(i1);
        double _d_w = w;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpsetweight(&_s_errormsg, &_d_network, &_d_k0, &_d_i0, &_d_k1, &_d_i1, &_d_w);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetweight' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpsetweight(multilayerperceptron network, int k0, int i0, int k1, int i1, double w)
    {
    _core_mlpsetweight( network,  k0,  i0,  k1,  i1,  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpactivationfunction(double net, int k, out double f, out double df, out double d2f, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_net = net;
        x_int _d_k = new x_int(k);
        double _d_f = 0;
        double _d_df = 0;
        double _d_d2f = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpactivationfunction(&_s_errormsg, &_d_net, &_d_k, &_d_f, &_d_df, &_d_d2f);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpactivationfunction' call");
            }
            f = _d_f;
            df = _d_df;
            d2f = _d_d2f;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpactivationfunction(double net, int k, out double f, out double df, out double d2f)
    {
    _core_mlpactivationfunction( net,  k, out  f, out  df, out  d2f, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpprocess(multilayerperceptron network, double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_mlpprocess(&_s_errormsg, &_d_network, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpprocess' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void mlpprocess(multilayerperceptron network, double[] x, ref double[] y)
    {
    _core_mlpprocess( network,  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpprocessi(multilayerperceptron network, double[] x, out double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_ser_mlpprocessi(&_s_errormsg, &_d_network, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpprocessi' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void mlpprocessi(multilayerperceptron network, double[] x, out double[] y)
    {
    _core_mlpprocessi( network,  x, out  y, alglibmode.serial);
    return;
    }
    private static unsafe double _core_mlperror(multilayerperceptron network, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlperror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
                else    _error_code = _i_smp_mlperror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlperror' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlperror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlperror( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlperror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlperror( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlperrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlperrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            else    _error_code = _i_smp_mlperrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlperrorsparse' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double mlperrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlperrorsparse( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlperrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlperrorsparse( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlperrorn(multilayerperceptron network, double[,] xy, int ssize, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mlperrorn(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_ssize);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlperrorn' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlperrorn(multilayerperceptron network, double[,] xy, int ssize)
    {
    double result = _core_mlperrorn( network,  xy,  ssize, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_mlpclserror(multilayerperceptron network, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpclserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
                else    _error_code = _i_smp_mlpclserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpclserror' call");
            }
            result = _d_result.intval;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static int mlpclserror(multilayerperceptron network, double[,] xy, int npoints)
    {
    int result = _core_mlpclserror( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static int smp_mlpclserror(multilayerperceptron network, double[,] xy, int npoints)
    {
    int result = _core_mlpclserror( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlprelclserror(multilayerperceptron network, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlprelclserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
                else    _error_code = _i_smp_mlprelclserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlprelclserror' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlprelclserror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlprelclserror( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlprelclserror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlprelclserror( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlprelclserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlprelclserrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            else    _error_code = _i_smp_mlprelclserrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlprelclserrorsparse' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double mlprelclserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlprelclserrorsparse( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlprelclserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlprelclserrorsparse( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlpavgce(multilayerperceptron network, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpavgce(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
                else    _error_code = _i_smp_mlpavgce(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpavgce' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlpavgce(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlpavgce( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlpavgce(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlpavgce( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlpavgcesparse(multilayerperceptron network, sparsematrix xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlpavgcesparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            else    _error_code = _i_smp_mlpavgcesparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpavgcesparse' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double mlpavgcesparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlpavgcesparse( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlpavgcesparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlpavgcesparse( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlprmserror(multilayerperceptron network, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlprmserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
                else    _error_code = _i_smp_mlprmserror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlprmserror' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlprmserror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlprmserror( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlprmserror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlprmserror( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlprmserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlprmserrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            else    _error_code = _i_smp_mlprmserrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlprmserrorsparse' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double mlprmserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlprmserrorsparse( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlprmserrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlprmserrorsparse( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlpavgerror(multilayerperceptron network, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpavgerror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
                else    _error_code = _i_smp_mlpavgerror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpavgerror' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlpavgerror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlpavgerror( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlpavgerror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlpavgerror( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlpavgerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlpavgerrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            else    _error_code = _i_smp_mlpavgerrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpavgerrorsparse' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double mlpavgerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlpavgerrorsparse( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlpavgerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlpavgerrorsparse( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlpavgrelerror(multilayerperceptron network, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpavgrelerror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
                else    _error_code = _i_smp_mlpavgrelerror(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpavgrelerror' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlpavgrelerror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlpavgrelerror( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlpavgrelerror(multilayerperceptron network, double[,] xy, int npoints)
    {
    double result = _core_mlpavgrelerror( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlpavgrelerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlpavgrelerrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            else    _error_code = _i_smp_mlpavgrelerrorsparse(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_npoints);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpavgrelerrorsparse' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double mlpavgrelerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlpavgrelerrorsparse( network,  xy,  npoints, alglibmode.serial);
    return result;
    }
    public static double smp_mlpavgrelerrorsparse(multilayerperceptron network, sparsematrix xy, int npoints)
    {
    double result = _core_mlpavgrelerrorsparse( network,  xy,  npoints, alglibmode.parallel);
    return result;
    }
    private static unsafe void _core_mlpgrad(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_desiredy = new x_vector();
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_desiredy = desiredy, _fp_grad = grad){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_desiredy, _fp_desiredy, ap.len(desiredy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_ser_mlpgrad(&_s_errormsg, &_d_network, &_d_x, &_d_desiredy, &_d_e, &_d_grad);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgrad' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_desiredy);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    public static void mlpgrad(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad)
    {
    _core_mlpgrad( network,  x,  desiredy, out  e, ref  grad, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpgradn(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_desiredy = new x_vector();
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_desiredy = desiredy, _fp_grad = grad){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_desiredy, _fp_desiredy, ap.len(desiredy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_ser_mlpgradn(&_s_errormsg, &_d_network, &_d_x, &_d_desiredy, &_d_e, &_d_grad);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgradn' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_desiredy);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    public static void mlpgradn(multilayerperceptron network, double[] x, double[] desiredy, out double e, ref double[] grad)
    {
    _core_mlpgradn( network,  x,  desiredy, out  e, ref  grad, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpgradbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpgradbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad);
                else    _error_code = _i_smp_mlpgradbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgradbatch' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    public static void mlpgradbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad)
    {
    _core_mlpgradbatch( network,  xy,  ssize, out  e, ref  grad, alglibmode.serial);
    return;
    }
    public static void smp_mlpgradbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad)
    {
    _core_mlpgradbatch( network,  xy,  ssize, out  e, ref  grad, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_mlpgradbatchsparse(multilayerperceptron network, sparsematrix xy, int ssize, out double e, ref double[] grad, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_grad = grad){
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpgradbatchsparse(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad);
                else    _error_code = _i_smp_mlpgradbatchsparse(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgradbatchsparse' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    public static void mlpgradbatchsparse(multilayerperceptron network, sparsematrix xy, int ssize, out double e, ref double[] grad)
    {
    _core_mlpgradbatchsparse( network,  xy,  ssize, out  e, ref  grad, alglibmode.serial);
    return;
    }
    public static void smp_mlpgradbatchsparse(multilayerperceptron network, sparsematrix xy, int ssize, out double e, ref double[] grad)
    {
    _core_mlpgradbatchsparse( network,  xy,  ssize, out  e, ref  grad, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_mlpgradbatchsubset(multilayerperceptron network, double[,] xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_idx = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_from_array(ref _d_idx, idx, X_CREATE);
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpgradbatchsubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_idx, &_d_subsetsize, &_d_e, &_d_grad);
                else    _error_code = _i_smp_mlpgradbatchsubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_idx, &_d_subsetsize, &_d_e, &_d_grad);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgradbatchsubset' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_idx);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    public static void mlpgradbatchsubset(multilayerperceptron network, double[,] xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad)
    {
    _core_mlpgradbatchsubset( network,  xy,  setsize,  idx,  subsetsize, out  e, ref  grad, alglibmode.serial);
    return;
    }
    public static void smp_mlpgradbatchsubset(multilayerperceptron network, double[,] xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad)
    {
    _core_mlpgradbatchsubset( network,  xy,  setsize,  idx,  subsetsize, out  e, ref  grad, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_mlpgradbatchsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_idx = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_grad = grad){
                x_vector_from_array(ref _d_idx, idx, X_CREATE);
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpgradbatchsparsesubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_idx, &_d_subsetsize, &_d_e, &_d_grad);
                else    _error_code = _i_smp_mlpgradbatchsparsesubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_idx, &_d_subsetsize, &_d_e, &_d_grad);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgradbatchsparsesubset' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_idx);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    public static void mlpgradbatchsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad)
    {
    _core_mlpgradbatchsparsesubset( network,  xy,  setsize,  idx,  subsetsize, out  e, ref  grad, alglibmode.serial);
    return;
    }
    public static void smp_mlpgradbatchsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] idx, int subsetsize, out double e, ref double[] grad)
    {
    _core_mlpgradbatchsparsesubset( network,  xy,  setsize,  idx,  subsetsize, out  e, ref  grad, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_mlpgradnbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                _error_code = _i_ser_mlpgradnbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpgradnbatch' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_grad);
        }
        // This function returns no value.
    }
    public static void mlpgradnbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad)
    {
    _core_mlpgradnbatch( network,  xy,  ssize, out  e, ref  grad, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlphessiannbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        x_matrix _d_h = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad, _fp_h = h){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                x_matrix_attach_to_array(ref _d_h, _fp_h, ap.rows(h), ap.cols(h));
                _error_code = _i_ser_mlphessiannbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad, &_d_h);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlphessiannbatch' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
            if( _d_h.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_h, ref h);
            if( h == null )
                h = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_grad);
            x_matrix_clear(ref _d_h);
        }
        // This function returns no value.
    }
    public static void mlphessiannbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h)
    {
    _core_mlphessiannbatch( network,  xy,  ssize, out  e, ref  grad, ref  h, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlphessianbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        double _d_e = 0;
        x_vector _d_grad = new x_vector();
        x_matrix _d_h = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy, _fp_grad = grad, _fp_h = h){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_attach_to_array(ref _d_grad, _fp_grad, ap.len(grad));
                x_matrix_attach_to_array(ref _d_h, _fp_h, ap.rows(h), ap.cols(h));
                _error_code = _i_ser_mlphessianbatch(&_s_errormsg, &_d_network, &_d_xy, &_d_ssize, &_d_e, &_d_grad, &_d_h);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlphessianbatch' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            e = _d_e;
            if( _d_grad.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_grad, ref grad);
            if( grad == null )
                grad = new double[0];
            if( _d_h.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_h, ref h);
            if( h == null )
                h = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_grad);
            x_matrix_clear(ref _d_h);
        }
        // This function returns no value.
    }
    public static void mlphessianbatch(multilayerperceptron network, double[,] xy, int ssize, out double e, ref double[] grad, ref double[,] h)
    {
    _core_mlphessianbatch( network,  xy,  ssize, out  e, ref  grad, ref  h, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpallerrorssubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, out modelerrors rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_subset = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        x_modelerrors _d_rep = new x_modelerrors();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_from_array(ref _d_subset, subset, X_CREATE);
                x_modelerrors_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlpallerrorssubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize, &_d_rep);
                else    _error_code = _i_smp_mlpallerrorssubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpallerrorssubset' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_modelerrors_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_subset);
            x_modelerrors_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlpallerrorssubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, out modelerrors rep)
    {
    _core_mlpallerrorssubset( network,  xy,  setsize,  subset,  subsetsize, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_mlpallerrorssubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, out modelerrors rep)
    {
    _core_mlpallerrorssubset( network,  xy,  setsize,  subset,  subsetsize, out  rep, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_mlpallerrorssparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, out modelerrors rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_subset = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        x_modelerrors _d_rep = new x_modelerrors();
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_subset, subset, X_CREATE);
            x_modelerrors_init(ref _d_rep);
            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlpallerrorssparsesubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize, &_d_rep);
            else    _error_code = _i_smp_mlpallerrorssparsesubset(&_s_errormsg, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpallerrorssparsesubset' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_modelerrors_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_subset);
            x_modelerrors_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlpallerrorssparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, out modelerrors rep)
    {
    _core_mlpallerrorssparsesubset( network,  xy,  setsize,  subset,  subsetsize, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_mlpallerrorssparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, out modelerrors rep)
    {
    _core_mlpallerrorssparsesubset( network,  xy,  setsize,  subset,  subsetsize, out  rep, alglibmode.parallel);
    return;
    }
    private static unsafe double _core_mlperrorsubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_subset = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_vector_from_array(ref _d_subset, subset, X_CREATE);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_mlperrorsubset(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize);
                else    _error_code = _i_smp_mlperrorsubset(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlperrorsubset' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_vector_clear(ref _d_subset);
        }
        return result;
    }
    public static double mlperrorsubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize)
    {
    double result = _core_mlperrorsubset( network,  xy,  setsize,  subset,  subsetsize, alglibmode.serial);
    return result;
    }
    public static double smp_mlperrorsubset(multilayerperceptron network, double[,] xy, int setsize, int[] subset, int subsetsize)
    {
    double result = _core_mlperrorsubset( network,  xy,  setsize,  subset,  subsetsize, alglibmode.parallel);
    return result;
    }
    private static unsafe double _core_mlperrorsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_network = network.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_setsize = new x_int(setsize);
        x_vector _d_subset = new x_vector();
        x_int _d_subsetsize = new x_int(subsetsize);
        
        // Pack, call, unpack
        try
        {
            x_vector_from_array(ref _d_subset, subset, X_CREATE);
            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlperrorsparsesubset(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize);
            else    _error_code = _i_smp_mlperrorsparsesubset(&_s_errormsg, &_d_result, &_d_network, &_d_xy, &_d_setsize, &_d_subset, &_d_subsetsize);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlperrorsparsesubset' call");
            }
            result = _d_result;
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_subset);
        }
        return result;
    }
    public static double mlperrorsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize)
    {
    double result = _core_mlperrorsparsesubset( network,  xy,  setsize,  subset,  subsetsize, alglibmode.serial);
    return result;
    }
    public static double smp_mlperrorsparsesubset(multilayerperceptron network, sparsematrix xy, int setsize, int[] subset, int subsetsize)
    {
    double result = _core_mlperrorsparsesubset( network,  xy,  setsize,  subset,  subsetsize, alglibmode.parallel);
    return result;
    }
    
    
    //
    // Subpackage densesolver
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_densesolverreport
    {
        public double r1;
        public double rinf;
    }

    public class densesolverreport : alglibobject
    {
        public double r1;
        public double rinf;
        public override alglib.alglibobject make_copy()
        {
            densesolverreport dst = new densesolverreport();
            dst.r1 = r1;
            dst.rinf = rinf;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_densesolverreport_init(ref x_densesolverreport x)
    {
        x.r1 = 0;
        x.rinf = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_densesolverreport_clear(ref x_densesolverreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_densesolverreport_init_from(ref x_densesolverreport x, densesolverreport v)
    {
        x.r1 = v.r1;
        x.rinf = v.rinf;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_densesolverreport_to_record(ref x_densesolverreport x, ref densesolverreport v)
    {
        if( v==null )
            v = new densesolverreport();
        v.r1 = x.r1;
        v.rinf = x.rinf;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_densesolverlsreport
    {
        public double r2;
        public x_matrix cx;
        public x_int n;
        public x_int k;
    }

    public class densesolverlsreport : alglibobject
    {
        public double r2;
        public double[,] cx;
        public int n;
        public int k;
        public override alglib.alglibobject make_copy()
        {
            densesolverlsreport dst = new densesolverlsreport();
            dst.r2 = r2;
            dst.cx = (double[,])cx.Clone();        dst.n = n;
            dst.k = k;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_densesolverlsreport_init(ref x_densesolverlsreport x)
    {
        x.r2 = 0;
        x_matrix_create_empty(ref x.cx, DT_REAL);
        x.n.longval = 0;
        x.k.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_densesolverlsreport_clear(ref x_densesolverlsreport x)
    {
        x_matrix_clear(ref x.cx);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_densesolverlsreport_init_from(ref x_densesolverlsreport x, densesolverlsreport v)
    {
        x.r2 = v.r2;
        x_matrix_from_array(ref x.cx, v.cx, X_CREATE);
        x.n.longval = v.n;
        x.k.longval = v.k;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_densesolverlsreport_to_record(ref x_densesolverlsreport x, ref densesolverlsreport v)
    {
        if( v==null )
            v = new densesolverlsreport();
        v.r2 = x.r2;
        x_matrix_to_array(ref x.cx, ref v.cx);
        v.n = x.n.intval; // long is silently truncated to int
        v.k = x.k.intval; // long is silently truncated to int
    }
    private static unsafe void _core_rmatrixsolve(double[,] a, int n, double[] b, out int info, out densesolverreport rep, out double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_rmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixsolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixsolve(double[,] a, int n, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
    _core_rmatrixsolve( a,  n,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixsolve(double[,] a, int n, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
    _core_rmatrixsolve( a,  n,  b, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixsolvefast(double[,] a, int n, ref double[] b, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info);
                else    _error_code = _i_smp_rmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixsolvefast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void rmatrixsolvefast(double[,] a, int n, ref double[] b, out int info)
    {
    _core_rmatrixsolvefast( a,  n, ref  b, out  info, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixsolvefast(double[,] a, int n, ref double[] b, out int info)
    {
    _core_rmatrixsolvefast( a,  n, ref  b, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixsolvem(double[,] a, int n, double[,] b, int m, bool rfs, out int info, out densesolverreport rep, out double[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        byte _d_rfs = (byte)(rfs ? 1 : 0);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_rfs, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_rmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_rfs, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixsolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixsolvem(double[,] a, int n, double[,] b, int m, bool rfs, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_rmatrixsolvem( a,  n,  b,  m,  rfs, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixsolvem(double[,] a, int n, double[,] b, int m, bool rfs, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_rmatrixsolvem( a,  n,  b,  m,  rfs, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixsolvemfast(double[,] a, int n, ref double[,] b, int m, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_info);
                else    _error_code = _i_smp_rmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixsolvemfast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void rmatrixsolvemfast(double[,] a, int n, ref double[,] b, int m, out int info)
    {
    _core_rmatrixsolvemfast( a,  n, ref  b,  m, out  info, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixsolvemfast(double[,] a, int n, ref double[,] b, int m, out int info)
    {
    _core_rmatrixsolvemfast( a,  n, ref  b,  m, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixlusolve(double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_ser_rmatrixlusolve(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlusolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixlusolve(double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
    _core_rmatrixlusolve( lua,  p,  n,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixlusolvefast(double[,] lua, int[] p, int n, ref double[] b, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_ser_rmatrixlusolvefast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlusolvefast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void rmatrixlusolvefast(double[,] lua, int[] p, int n, ref double[] b, out int info)
    {
    _core_rmatrixlusolvefast( lua,  p,  n, ref  b, out  info, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixlusolvem(double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixlusolvem(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_rmatrixlusolvem(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlusolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixlusolvem(double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_rmatrixlusolvem( lua,  p,  n,  b,  m, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixlusolvem(double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_rmatrixlusolvem( lua,  p,  n,  b,  m, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixlusolvemfast(double[,] lua, int[] p, int n, ref double[,] b, int m, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixlusolvemfast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info);
                else    _error_code = _i_smp_rmatrixlusolvemfast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixlusolvemfast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void rmatrixlusolvemfast(double[,] lua, int[] p, int n, ref double[,] b, int m, out int info)
    {
    _core_rmatrixlusolvemfast( lua,  p,  n, ref  b,  m, out  info, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixlusolvemfast(double[,] lua, int[] p, int n, ref double[,] b, int m, out int info)
    {
    _core_rmatrixlusolvemfast( lua,  p,  n, ref  b,  m, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_rmatrixmixedsolve(double[,] a, double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_ser_rmatrixmixedsolve(&_s_errormsg, &_d_a, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixmixedsolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixmixedsolve(double[,] a, double[,] lua, int[] p, int n, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
    _core_rmatrixmixedsolve( a,  lua,  p,  n,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixmixedsolvem(double[,] a, double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_ser_rmatrixmixedsolvem(&_s_errormsg, &_d_a, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixmixedsolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixmixedsolvem(double[,] a, double[,] lua, int[] p, int n, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_rmatrixmixedsolvem( a,  lua,  p,  n,  b,  m, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixsolvem(complex[,] a, int n, complex[,] b, int m, bool rfs, out int info, out densesolverreport rep, out complex[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        byte _d_rfs = (byte)(rfs ? 1 : 0);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_rfs, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_cmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_rfs, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixsolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void cmatrixsolvem(complex[,] a, int n, complex[,] b, int m, bool rfs, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_cmatrixsolvem( a,  n,  b,  m,  rfs, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixsolvem(complex[,] a, int n, complex[,] b, int m, bool rfs, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_cmatrixsolvem( a,  n,  b,  m,  rfs, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixsolvemfast(complex[,] a, int n, ref complex[,] b, int m, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_info);
                else    _error_code = _i_smp_cmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_m, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixsolvemfast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void cmatrixsolvemfast(complex[,] a, int n, ref complex[,] b, int m, out int info)
    {
    _core_cmatrixsolvemfast( a,  n, ref  b,  m, out  info, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixsolvemfast(complex[,] a, int n, ref complex[,] b, int m, out int info)
    {
    _core_cmatrixsolvemfast( a,  n, ref  b,  m, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixsolve(complex[,] a, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_cmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixsolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void cmatrixsolve(complex[,] a, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
    _core_cmatrixsolve( a,  n,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixsolve(complex[,] a, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
    _core_cmatrixsolve( a,  n,  b, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixsolvefast(complex[,] a, int n, ref complex[] b, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info);
                else    _error_code = _i_smp_cmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_b, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixsolvefast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void cmatrixsolvefast(complex[,] a, int n, ref complex[] b, out int info)
    {
    _core_cmatrixsolvefast( a,  n, ref  b, out  info, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixsolvefast(complex[,] a, int n, ref complex[] b, out int info)
    {
    _core_cmatrixsolvefast( a,  n, ref  b, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixlusolvem(complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixlusolvem(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_cmatrixlusolvem(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlusolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void cmatrixlusolvem(complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_cmatrixlusolvem( lua,  p,  n,  b,  m, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixlusolvem(complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_cmatrixlusolvem( lua,  p,  n,  b,  m, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixlusolvemfast(complex[,] lua, int[] p, int n, ref complex[,] b, int m, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_cmatrixlusolvemfast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info);
                else    _error_code = _i_smp_cmatrixlusolvemfast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlusolvemfast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void cmatrixlusolvemfast(complex[,] lua, int[] p, int n, ref complex[,] b, int m, out int info)
    {
    _core_cmatrixlusolvemfast( lua,  p,  n, ref  b,  m, out  info, alglibmode.serial);
    return;
    }
    public static void smp_cmatrixlusolvemfast(complex[,] lua, int[] p, int n, ref complex[,] b, int m, out int info)
    {
    _core_cmatrixlusolvemfast( lua,  p,  n, ref  b,  m, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_cmatrixlusolve(complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_ser_cmatrixlusolve(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlusolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void cmatrixlusolve(complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
    _core_cmatrixlusolve( lua,  p,  n,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixlusolvefast(complex[,] lua, int[] p, int n, ref complex[] b, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_ser_cmatrixlusolvefast(&_s_errormsg, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixlusolvefast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void cmatrixlusolvefast(complex[,] lua, int[] p, int n, ref complex[] b, out int info)
    {
    _core_cmatrixlusolvefast( lua,  p,  n, ref  b, out  info, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixmixedsolvem(complex[,] a, complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_ser_cmatrixmixedsolvem(&_s_errormsg, &_d_a, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixmixedsolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void cmatrixmixedsolvem(complex[,] a, complex[,] lua, int[] p, int n, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_cmatrixmixedsolvem( a,  lua,  p,  n,  b,  m, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_cmatrixmixedsolve(complex[,] a, complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_matrix _d_lua = new x_matrix();
        x_vector _d_p = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_lua = lua, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_lua, _fp_lua, ap.rows(lua), ap.cols(lua));
                x_vector_from_array(ref _d_p, p, X_CREATE);
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_ser_cmatrixmixedsolve(&_s_errormsg, &_d_a, &_d_lua, &_d_p, &_d_n, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixmixedsolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_lua);
            x_vector_clear(ref _d_p);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void cmatrixmixedsolve(complex[,] a, complex[,] lua, int[] p, int n, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
    _core_cmatrixmixedsolve( a,  lua,  p,  n,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spdmatrixsolvem(double[,] a, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_spdmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixsolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void spdmatrixsolvem(double[,] a, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_spdmatrixsolvem( a,  n,  isupper,  b,  m, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_spdmatrixsolvem(double[,] a, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_spdmatrixsolvem( a,  n,  isupper,  b,  m, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_spdmatrixsolvemfast(double[,] a, int n, bool isupper, ref double[,] b, int m, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info);
                else    _error_code = _i_smp_spdmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixsolvemfast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void spdmatrixsolvemfast(double[,] a, int n, bool isupper, ref double[,] b, int m, out int info)
    {
    _core_spdmatrixsolvemfast( a,  n,  isupper, ref  b,  m, out  info, alglibmode.serial);
    return;
    }
    public static void smp_spdmatrixsolvemfast(double[,] a, int n, bool isupper, ref double[,] b, int m, out int info)
    {
    _core_spdmatrixsolvemfast( a,  n,  isupper, ref  b,  m, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_spdmatrixsolve(double[,] a, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_spdmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixsolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void spdmatrixsolve(double[,] a, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
    _core_spdmatrixsolve( a,  n,  isupper,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_spdmatrixsolve(double[,] a, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
    _core_spdmatrixsolve( a,  n,  isupper,  b, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_spdmatrixsolvefast(double[,] a, int n, bool isupper, ref double[] b, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info);
                else    _error_code = _i_smp_spdmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixsolvefast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void spdmatrixsolvefast(double[,] a, int n, bool isupper, ref double[] b, out int info)
    {
    _core_spdmatrixsolvefast( a,  n,  isupper, ref  b, out  info, alglibmode.serial);
    return;
    }
    public static void smp_spdmatrixsolvefast(double[,] a, int n, bool isupper, ref double[] b, out int info)
    {
    _core_spdmatrixsolvefast( a,  n,  isupper, ref  b, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_spdmatrixcholeskysolvem(double[,] cha, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_REAL);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixcholeskysolvem(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_spdmatrixcholeskysolvem(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskysolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskysolvem(double[,] cha, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_spdmatrixcholeskysolvem( cha,  n,  isupper,  b,  m, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_spdmatrixcholeskysolvem(double[,] cha, int n, bool isupper, double[,] b, int m, out int info, out densesolverreport rep, out double[,] x)
    {
    _core_spdmatrixcholeskysolvem( cha,  n,  isupper,  b,  m, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_spdmatrixcholeskysolvemfast(double[,] cha, int n, bool isupper, ref double[,] b, int m, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spdmatrixcholeskysolvemfast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info);
                else    _error_code = _i_smp_spdmatrixcholeskysolvemfast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskysolvemfast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskysolvemfast(double[,] cha, int n, bool isupper, ref double[,] b, int m, out int info)
    {
    _core_spdmatrixcholeskysolvemfast( cha,  n,  isupper, ref  b,  m, out  info, alglibmode.serial);
    return;
    }
    public static void smp_spdmatrixcholeskysolvemfast(double[,] cha, int n, bool isupper, ref double[,] b, int m, out int info)
    {
    _core_spdmatrixcholeskysolvemfast( cha,  n,  isupper, ref  b,  m, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_spdmatrixcholeskysolve(double[,] cha, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                _error_code = _i_ser_spdmatrixcholeskysolve(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskysolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskysolve(double[,] cha, int n, bool isupper, double[] b, out int info, out densesolverreport rep, out double[] x)
    {
    _core_spdmatrixcholeskysolve( cha,  n,  isupper,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spdmatrixcholeskysolvefast(double[,] cha, int n, bool isupper, ref double[] b, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_ser_spdmatrixcholeskysolvefast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskysolvefast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void spdmatrixcholeskysolvefast(double[,] cha, int n, bool isupper, ref double[] b, out int info)
    {
    _core_spdmatrixcholeskysolvefast( cha,  n,  isupper, ref  b, out  info, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hpdmatrixsolvem(complex[,] a, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_hpdmatrixsolvem(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixsolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void hpdmatrixsolvem(complex[,] a, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_hpdmatrixsolvem( a,  n,  isupper,  b,  m, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_hpdmatrixsolvem(complex[,] a, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_hpdmatrixsolvem( a,  n,  isupper,  b,  m, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_hpdmatrixsolvemfast(complex[,] a, int n, bool isupper, ref complex[,] b, int m, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info);
                else    _error_code = _i_smp_hpdmatrixsolvemfast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixsolvemfast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void hpdmatrixsolvemfast(complex[,] a, int n, bool isupper, ref complex[,] b, int m, out int info)
    {
    _core_hpdmatrixsolvemfast( a,  n,  isupper, ref  b,  m, out  info, alglibmode.serial);
    return;
    }
    public static void smp_hpdmatrixsolvemfast(complex[,] a, int n, bool isupper, ref complex[,] b, int m, out int info)
    {
    _core_hpdmatrixsolvemfast( a,  n,  isupper, ref  b,  m, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_hpdmatrixsolve(complex[,] a, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_hpdmatrixsolve(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixsolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void hpdmatrixsolve(complex[,] a, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
    _core_hpdmatrixsolve( a,  n,  isupper,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_hpdmatrixsolve(complex[,] a, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
    _core_hpdmatrixsolve( a,  n,  isupper,  b, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_hpdmatrixsolvefast(complex[,] a, int n, bool isupper, ref complex[] b, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info);
                else    _error_code = _i_smp_hpdmatrixsolvefast(&_s_errormsg, &_d_a, &_d_n, &_d_isupper, &_d_b, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixsolvefast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void hpdmatrixsolvefast(complex[,] a, int n, bool isupper, ref complex[] b, out int info)
    {
    _core_hpdmatrixsolvefast( a,  n,  isupper, ref  b, out  info, alglibmode.serial);
    return;
    }
    public static void smp_hpdmatrixsolvefast(complex[,] a, int n, bool isupper, ref complex[] b, out int info)
    {
    _core_hpdmatrixsolvefast( a,  n,  isupper, ref  b, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_hpdmatrixcholeskysolvem(complex[,] cha, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_matrix _d_x = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_densesolverreport_init(ref _d_rep);
                x_matrix_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixcholeskysolvem(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_hpdmatrixcholeskysolvem(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixcholeskysolvem' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_matrix_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_matrix_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void hpdmatrixcholeskysolvem(complex[,] cha, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_hpdmatrixcholeskysolvem( cha,  n,  isupper,  b,  m, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_hpdmatrixcholeskysolvem(complex[,] cha, int n, bool isupper, complex[,] b, int m, out int info, out densesolverreport rep, out complex[,] x)
    {
    _core_hpdmatrixcholeskysolvem( cha,  n,  isupper,  b,  m, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_hpdmatrixcholeskysolvemfast(complex[,] cha, int n, bool isupper, ref complex[,] b, int m, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_hpdmatrixcholeskysolvemfast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info);
                else    _error_code = _i_smp_hpdmatrixcholeskysolvemfast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_m, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixcholeskysolvemfast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0,0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void hpdmatrixcholeskysolvemfast(complex[,] cha, int n, bool isupper, ref complex[,] b, int m, out int info)
    {
    _core_hpdmatrixcholeskysolvemfast( cha,  n,  isupper, ref  b,  m, out  info, alglibmode.serial);
    return;
    }
    public static void smp_hpdmatrixcholeskysolvemfast(complex[,] cha, int n, bool isupper, ref complex[,] b, int m, out int info)
    {
    _core_hpdmatrixcholeskysolvemfast( cha,  n,  isupper, ref  b,  m, out  info, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_hpdmatrixcholeskysolve(complex[,] cha, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        x_densesolverreport _d_rep = new x_densesolverreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                _error_code = _i_ser_hpdmatrixcholeskysolve(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixcholeskysolve' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_vector_clear(ref _d_b);
            x_densesolverreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void hpdmatrixcholeskysolve(complex[,] cha, int n, bool isupper, complex[] b, out int info, out densesolverreport rep, out complex[] x)
    {
    _core_hpdmatrixcholeskysolve( cha,  n,  isupper,  b, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hpdmatrixcholeskysolvefast(complex[,] cha, int n, bool isupper, ref complex[] b, out int info, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_cha = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        x_int _d_info = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_cha = cha, _fp_b = b){
                x_matrix_attach_to_array(ref _d_cha, _fp_cha, ap.rows(cha), ap.cols(cha));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_ser_hpdmatrixcholeskysolvefast(&_s_errormsg, &_d_cha, &_d_n, &_d_isupper, &_d_b, &_d_info);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hpdmatrixcholeskysolvefast' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new alglib.complex[0];
            info = _d_info.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_cha);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void hpdmatrixcholeskysolvefast(complex[,] cha, int n, bool isupper, ref complex[] b, out int info)
    {
    _core_hpdmatrixcholeskysolvefast( cha,  n,  isupper, ref  b, out  info, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixsolvels(double[,] a, int nrows, int ncols, double[] b, double threshold, out int info, out densesolverlsreport rep, out double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_nrows = new x_int(nrows);
        x_int _d_ncols = new x_int(ncols);
        x_vector _d_b = new x_vector();
        double _d_threshold = threshold;
        x_int _d_info = new x_int();
        x_densesolverlsreport _d_rep = new x_densesolverlsreport();
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_densesolverlsreport_init(ref _d_rep);
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_rmatrixsolvels(&_s_errormsg, &_d_a, &_d_nrows, &_d_ncols, &_d_b, &_d_threshold, &_d_info, &_d_rep, &_d_x);
                else    _error_code = _i_smp_rmatrixsolvels(&_s_errormsg, &_d_a, &_d_nrows, &_d_ncols, &_d_b, &_d_threshold, &_d_info, &_d_rep, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixsolvels' call");
            }
            info = _d_info.intval;
            rep = null;
            x_densesolverlsreport_to_record(ref _d_rep, ref rep);
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_densesolverlsreport_clear(ref _d_rep);
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void rmatrixsolvels(double[,] a, int nrows, int ncols, double[] b, double threshold, out int info, out densesolverlsreport rep, out double[] x)
    {
    _core_rmatrixsolvels( a,  nrows,  ncols,  b,  threshold, out  info, out  rep, out  x, alglibmode.serial);
    return;
    }
    public static void smp_rmatrixsolvels(double[,] a, int nrows, int ncols, double[] b, double threshold, out int info, out densesolverlsreport rep, out double[] x)
    {
    _core_rmatrixsolvels( a,  nrows,  ncols,  b,  threshold, out  info, out  rep, out  x, alglibmode.parallel);
    return;
    }
    
    
    //
    // Subpackage logit
    //
    

    public unsafe class logitmodel : alglibobject
    {
        public void *ptr;
        public logitmodel(void *x)
        {
            ptr = x;
        }
        ~logitmodel()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new logitmodel(null);
            return new logitmodel(_i_x_obj_copy_logitmodel(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_logitmodel(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_logitmodel(void *x);
    private static _d_x_obj_copy_logitmodel _i_x_obj_copy_logitmodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_logitmodel(void *x);
    private static _d_x_obj_free_logitmodel _i_x_obj_free_logitmodel = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mnlreport
    {
        public x_int ngrad;
        public x_int nhess;
    }

    public class mnlreport : alglibobject
    {
        public int ngrad;
        public int nhess;
        public override alglib.alglibobject make_copy()
        {
            mnlreport dst = new mnlreport();
            dst.ngrad = ngrad;
            dst.nhess = nhess;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mnlreport_init(ref x_mnlreport x)
    {
        x.ngrad.longval = 0;
        x.nhess.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mnlreport_clear(ref x_mnlreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mnlreport_init_from(ref x_mnlreport x, mnlreport v)
    {
        x.ngrad.longval = v.ngrad;
        x.nhess.longval = v.nhess;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mnlreport_to_record(ref x_mnlreport x, ref mnlreport v)
    {
        if( v==null )
            v = new mnlreport();
        v.ngrad = x.ngrad.intval; // long is silently truncated to int
        v.nhess = x.nhess.intval; // long is silently truncated to int
    }
    private static unsafe void _core_mnltrainh(double[,] xy, int npoints, int nvars, int nclasses, out int info, out logitmodel lm, out mnlreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        x_int _d_info = new x_int();
        void *_d_lm = null;
        lm = null;
        x_mnlreport _d_rep = new x_mnlreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mnlreport_init(ref _d_rep);
                _error_code = _i_ser_mnltrainh(&_s_errormsg, &_d_xy, &_d_npoints, &_d_nvars, &_d_nclasses, &_d_info, &_d_lm, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnltrainh' call");
            }
            info = _d_info.intval;
            lm = new logitmodel(_d_lm);
            rep = null;
            x_mnlreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_logitmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
            x_mnlreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mnltrainh(double[,] xy, int npoints, int nvars, int nclasses, out int info, out logitmodel lm, out mnlreport rep)
    {
    _core_mnltrainh( xy,  npoints,  nvars,  nclasses, out  info, out  lm, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mnlprocess(logitmodel lm, double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_lm = lm.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_mnlprocess(&_s_errormsg, &_d_lm, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlprocess' call");
            }
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void mnlprocess(logitmodel lm, double[] x, ref double[] y)
    {
    _core_mnlprocess( lm,  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mnlprocessi(logitmodel lm, double[] x, out double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_lm = lm.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_ser_mnlprocessi(&_s_errormsg, &_d_lm, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlprocessi' call");
            }
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void mnlprocessi(logitmodel lm, double[] x, out double[] y)
    {
    _core_mnlprocessi( lm,  x, out  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mnlunpack(logitmodel lm, out double[,] a, out int nvars, out int nclasses, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_a = new x_matrix();
        x_int _d_nvars = new x_int();
        x_int _d_nclasses = new x_int();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_ser_mnlunpack(&_s_errormsg, &_d_lm, &_d_a, &_d_nvars, &_d_nclasses);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlunpack' call");
            }
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            nvars = _d_nvars.intval;
            nclasses = _d_nclasses.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void mnlunpack(logitmodel lm, out double[,] a, out int nvars, out int nclasses)
    {
    _core_mnlunpack( lm, out  a, out  nvars, out  nclasses, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mnlpack(double[,] a, int nvars, int nclasses, out logitmodel lm, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_nvars = new x_int(nvars);
        x_int _d_nclasses = new x_int(nclasses);
        void *_d_lm = null;
        lm = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_mnlpack(&_s_errormsg, &_d_a, &_d_nvars, &_d_nclasses, &_d_lm);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlpack' call");
            }
            lm = new logitmodel(_d_lm);
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            if( _d_lm!=null && lm==null)
                _i_x_obj_free_logitmodel(_d_lm); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mnlpack(double[,] a, int nvars, int nclasses, out logitmodel lm)
    {
    _core_mnlpack( a,  nvars,  nclasses, out  lm, alglibmode.serial);
    return;
    }
    private static unsafe double _core_mnlavgce(logitmodel lm, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mnlavgce(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlavgce' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mnlavgce(logitmodel lm, double[,] xy, int npoints)
    {
    double result = _core_mnlavgce( lm,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_mnlrelclserror(logitmodel lm, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mnlrelclserror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlrelclserror' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mnlrelclserror(logitmodel lm, double[,] xy, int npoints)
    {
    double result = _core_mnlrelclserror( lm,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_mnlrmserror(logitmodel lm, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mnlrmserror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlrmserror' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mnlrmserror(logitmodel lm, double[,] xy, int npoints)
    {
    double result = _core_mnlrmserror( lm,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_mnlavgerror(logitmodel lm, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mnlavgerror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlavgerror' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mnlavgerror(logitmodel lm, double[,] xy, int npoints)
    {
    double result = _core_mnlavgerror( lm,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_mnlavgrelerror(logitmodel lm, double[,] xy, int ssize, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_ssize = new x_int(ssize);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mnlavgrelerror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_ssize);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlavgrelerror' call");
            }
            result = _d_result;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mnlavgrelerror(logitmodel lm, double[,] xy, int ssize)
    {
    double result = _core_mnlavgrelerror( lm,  xy,  ssize, alglibmode.serial);
    return result;
    }
    private static unsafe int _core_mnlclserror(logitmodel lm, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        int result;
        x_int _d_result = new x_int();
        void *_d_lm = lm.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mnlclserror(&_s_errormsg, &_d_result, &_d_lm, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mnlclserror' call");
            }
            result = _d_result.intval;
            ap.assert(lm.ptr==_d_lm, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static int mnlclserror(logitmodel lm, double[,] xy, int npoints)
    {
    int result = _core_mnlclserror( lm,  xy,  npoints, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage optserv
    //
    
    
    
    //
    // Subpackage fbls
    //
    
    
    
    //
    // Subpackage cqmodels
    //
    
    
    
    //
    // Subpackage snnls
    //
    
    
    
    //
    // Subpackage sactivesets
    //
    
    
    
    //
    // Subpackage mincg
    //
    

    public unsafe class mincgstate : alglibobject
    {
        public void *ptr;
        public mincgstate(void *x)
        {
            ptr = x;
        }
        ~mincgstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new mincgstate(null);
            return new mincgstate(_i_x_obj_copy_mincgstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_mincgstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_mincgstate(void *x);
    private static _d_x_obj_copy_mincgstate _i_x_obj_copy_mincgstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_mincgstate(void *x);
    private static _d_x_obj_free_mincgstate _i_x_obj_free_mincgstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_set_needf(void *x, byte *dst);
    private static _d_x_mincgstate_get_needf _i_x_mincgstate_get_needf = null;
    private static _d_x_mincgstate_set_needf _i_x_mincgstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_set_needfg(void *x, byte *dst);
    private static _d_x_mincgstate_get_needfg _i_x_mincgstate_get_needfg = null;
    private static _d_x_mincgstate_set_needfg _i_x_mincgstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_set_xupdated(void *x, byte *dst);
    private static _d_x_mincgstate_get_xupdated _i_x_mincgstate_get_xupdated = null;
    private static _d_x_mincgstate_set_xupdated _i_x_mincgstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_set_f(void *x, double *dst);
    private static _d_x_mincgstate_get_f _i_x_mincgstate_get_f = null;
    private static _d_x_mincgstate_set_f _i_x_mincgstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_get_g(void *x, x_vector *dst);
    private static _d_x_mincgstate_get_g _i_x_mincgstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_mincgstate_get_x(void *x, x_vector *dst);
    private static _d_x_mincgstate_get_x _i_x_mincgstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mincgreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int varidx;
        public x_int terminationtype;
    }

    public class mincgreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int varidx;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            mincgreport dst = new mincgreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.varidx = varidx;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mincgreport_init(ref x_mincgreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.varidx.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mincgreport_clear(ref x_mincgreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mincgreport_init_from(ref x_mincgreport x, mincgreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.varidx.longval = v.varidx;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mincgreport_to_record(ref x_mincgreport x, ref mincgreport v)
    {
        if( v==null )
            v = new mincgreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    private static unsafe void _core_mincgcreate(int n, double[] x, out mincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_mincgcreate(&_s_errormsg, &_d_n, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgcreate' call");
            }
            state = new mincgstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_mincgstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mincgcreate(int n, double[] x, out mincgstate state)
    {
    _core_mincgcreate( n,  x, out  state, alglibmode.serial);
    return;
    }
    public static void mincgcreate(double[] x, out mincgstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_mincgcreate( n,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_mincgcreatef(int n, double[] x, double diffstep, out mincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_mincgcreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgcreatef' call");
            }
            state = new mincgstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_mincgstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mincgcreatef(int n, double[] x, double diffstep, out mincgstate state)
    {
    _core_mincgcreatef( n,  x,  diffstep, out  state, alglibmode.serial);
    return;
    }
    public static void mincgcreatef(double[] x, double diffstep, out mincgstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_mincgcreatef( n,  x,  diffstep, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_mincgsetcond(mincgstate state, double epsg, double epsf, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgsetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgsetcond(mincgstate state, double epsg, double epsf, double epsx, int maxits)
    {
    _core_mincgsetcond( state,  epsg,  epsf,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsetscale(mincgstate state, double[] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_ser_mincgsetscale(&_s_errormsg, &_d_state, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    public static void mincgsetscale(mincgstate state, double[] s)
    {
    _core_mincgsetscale( state,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsetxrep(mincgstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgsetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgsetxrep(mincgstate state, bool needxrep)
    {
    _core_mincgsetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsetcgtype(mincgstate state, int cgtype, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_cgtype = new x_int(cgtype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgsetcgtype(&_s_errormsg, &_d_state, &_d_cgtype);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetcgtype' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgsetcgtype(mincgstate state, int cgtype)
    {
    _core_mincgsetcgtype( state,  cgtype, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsetstpmax(mincgstate state, double stpmax, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetstpmax' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgsetstpmax(mincgstate state, double stpmax)
    {
    _core_mincgsetstpmax( state,  stpmax, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsuggeststep(mincgstate state, double stp, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stp = stp;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgsuggeststep(&_s_errormsg, &_d_state, &_d_stp);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsuggeststep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgsuggeststep(mincgstate state, double stp)
    {
    _core_mincgsuggeststep( state,  stp, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsetprecdefault(mincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgsetprecdefault(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetprecdefault' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgsetprecdefault(mincgstate state)
    {
    _core_mincgsetprecdefault( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsetprecdiag(mincgstate state, double[] d, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_ser_mincgsetprecdiag(&_s_errormsg, &_d_state, &_d_d);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetprecdiag' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    public static void mincgsetprecdiag(mincgstate state, double[] d)
    {
    _core_mincgsetprecdiag( state,  d, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsetprecscale(mincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgsetprecscale(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetprecscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgsetprecscale(mincgstate state)
    {
    _core_mincgsetprecscale( state, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_mincgiteration(mincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgiteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgiteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool mincgiteration(mincgstate state)
    {
    bool result = _core_mincgiteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void mincgoptimize(mincgstate state, ndimensional_func func, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'mincgoptimize()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        _i_x_mincgstate_get_x(_state, &_xc_arg);
        _cs_arg = new double[_xc_arg.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_mincgiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'mincgiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_mincgstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_mincgstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_mincgstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_mincgstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'mincgoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void mincgoptimize(mincgstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'mincgoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_mincgstate_get_x(_state, &_xc_arg);
        _i_x_mincgstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_mincgiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'mincgiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_mincgstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_mincgstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_mincgstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_mincgstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'mincgoptimize' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_mincgresults(mincgstate state, out double[] x, out mincgreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_mincgreport _d_rep = new x_mincgreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_mincgreport_init(ref _d_rep);
            _error_code = _i_ser_mincgresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_mincgreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_mincgreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mincgresults(mincgstate state, out double[] x, out mincgreport rep)
    {
    _core_mincgresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgresultsbuf(mincgstate state, ref double[] x, mincgreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_mincgreport _d_rep = new x_mincgreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_mincgreport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_mincgresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_mincgreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_mincgreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mincgresultsbuf(mincgstate state, ref double[] x, mincgreport rep)
    {
    _core_mincgresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgrestartfrom(mincgstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_mincgrestartfrom(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgrestartfrom' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void mincgrestartfrom(mincgstate state, double[] x)
    {
    _core_mincgrestartfrom( state,  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgrequesttermination(mincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgrequesttermination(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgrequesttermination' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgrequesttermination(mincgstate state)
    {
    _core_mincgrequesttermination( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mincgsetgradientcheck(mincgstate state, double teststep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mincgsetgradientcheck(&_s_errormsg, &_d_state, &_d_teststep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mincgsetgradientcheck' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mincgsetgradientcheck(mincgstate state, double teststep)
    {
    _core_mincgsetgradientcheck( state,  teststep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage minbleic
    //
    

    public unsafe class minbleicstate : alglibobject
    {
        public void *ptr;
        public minbleicstate(void *x)
        {
            ptr = x;
        }
        ~minbleicstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new minbleicstate(null);
            return new minbleicstate(_i_x_obj_copy_minbleicstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_minbleicstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minbleicstate(void *x);
    private static _d_x_obj_copy_minbleicstate _i_x_obj_copy_minbleicstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_minbleicstate(void *x);
    private static _d_x_obj_free_minbleicstate _i_x_obj_free_minbleicstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_set_needf(void *x, byte *dst);
    private static _d_x_minbleicstate_get_needf _i_x_minbleicstate_get_needf = null;
    private static _d_x_minbleicstate_set_needf _i_x_minbleicstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_set_needfg(void *x, byte *dst);
    private static _d_x_minbleicstate_get_needfg _i_x_minbleicstate_get_needfg = null;
    private static _d_x_minbleicstate_set_needfg _i_x_minbleicstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minbleicstate_get_xupdated _i_x_minbleicstate_get_xupdated = null;
    private static _d_x_minbleicstate_set_xupdated _i_x_minbleicstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_set_f(void *x, double *dst);
    private static _d_x_minbleicstate_get_f _i_x_minbleicstate_get_f = null;
    private static _d_x_minbleicstate_set_f _i_x_minbleicstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_get_g(void *x, x_vector *dst);
    private static _d_x_minbleicstate_get_g _i_x_minbleicstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minbleicstate_get_x(void *x, x_vector *dst);
    private static _d_x_minbleicstate_get_x _i_x_minbleicstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minbleicreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int varidx;
        public x_int terminationtype;
        public double debugeqerr;
        public double debugfs;
        public double debugff;
        public double debugdx;
        public x_int debugfeasqpits;
        public x_int debugfeasgpaits;
        public x_int inneriterationscount;
        public x_int outeriterationscount;
    }

    public class minbleicreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int varidx;
        public int terminationtype;
        public double debugeqerr;
        public double debugfs;
        public double debugff;
        public double debugdx;
        public int debugfeasqpits;
        public int debugfeasgpaits;
        public int inneriterationscount;
        public int outeriterationscount;
        public override alglib.alglibobject make_copy()
        {
            minbleicreport dst = new minbleicreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.varidx = varidx;
            dst.terminationtype = terminationtype;
            dst.debugeqerr = debugeqerr;
            dst.debugfs = debugfs;
            dst.debugff = debugff;
            dst.debugdx = debugdx;
            dst.debugfeasqpits = debugfeasqpits;
            dst.debugfeasgpaits = debugfeasgpaits;
            dst.inneriterationscount = inneriterationscount;
            dst.outeriterationscount = outeriterationscount;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minbleicreport_init(ref x_minbleicreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.varidx.longval = 0;
        x.terminationtype.longval = 0;
        x.debugeqerr = 0;
        x.debugfs = 0;
        x.debugff = 0;
        x.debugdx = 0;
        x.debugfeasqpits.longval = 0;
        x.debugfeasgpaits.longval = 0;
        x.inneriterationscount.longval = 0;
        x.outeriterationscount.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minbleicreport_clear(ref x_minbleicreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minbleicreport_init_from(ref x_minbleicreport x, minbleicreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.varidx.longval = v.varidx;
        x.terminationtype.longval = v.terminationtype;
        x.debugeqerr = v.debugeqerr;
        x.debugfs = v.debugfs;
        x.debugff = v.debugff;
        x.debugdx = v.debugdx;
        x.debugfeasqpits.longval = v.debugfeasqpits;
        x.debugfeasgpaits.longval = v.debugfeasgpaits;
        x.inneriterationscount.longval = v.inneriterationscount;
        x.outeriterationscount.longval = v.outeriterationscount;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minbleicreport_to_record(ref x_minbleicreport x, ref minbleicreport v)
    {
        if( v==null )
            v = new minbleicreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.debugeqerr = x.debugeqerr;
        v.debugfs = x.debugfs;
        v.debugff = x.debugff;
        v.debugdx = x.debugdx;
        v.debugfeasqpits = x.debugfeasqpits.intval; // long is silently truncated to int
        v.debugfeasgpaits = x.debugfeasgpaits.intval; // long is silently truncated to int
        v.inneriterationscount = x.inneriterationscount.intval; // long is silently truncated to int
        v.outeriterationscount = x.outeriterationscount.intval; // long is silently truncated to int
    }
    private static unsafe void _core_minbleiccreate(int n, double[] x, out minbleicstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minbleiccreate(&_s_errormsg, &_d_n, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleiccreate' call");
            }
            state = new minbleicstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minbleicstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minbleiccreate(int n, double[] x, out minbleicstate state)
    {
    _core_minbleiccreate( n,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minbleiccreate(double[] x, out minbleicstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minbleiccreate( n,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minbleiccreatef(int n, double[] x, double diffstep, out minbleicstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minbleiccreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleiccreatef' call");
            }
            state = new minbleicstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minbleicstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minbleiccreatef(int n, double[] x, double diffstep, out minbleicstate state)
    {
    _core_minbleiccreatef( n,  x,  diffstep, out  state, alglibmode.serial);
    return;
    }
    public static void minbleiccreatef(double[] x, double diffstep, out minbleicstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minbleiccreatef( n,  x,  diffstep, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minbleicsetbc(minbleicstate state, double[] bndl, double[] bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_ser_minbleicsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetbc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    public static void minbleicsetbc(minbleicstate state, double[] bndl, double[] bndu)
    {
    _core_minbleicsetbc( state,  bndl,  bndu, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetlc(minbleicstate state, double[,] c, int[] ct, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_ser_minbleicsetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetlc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    public static void minbleicsetlc(minbleicstate state, double[,] c, int[] ct, int k)
    {
    _core_minbleicsetlc( state,  c,  ct,  k, alglibmode.serial);
    return;
    }
    public static void minbleicsetlc(minbleicstate state, double[,] c, int[] ct)
    {
    int k;
    
    if( (ap.rows(c)!=ap.len(ct)))
        throw new alglibexception("Error while calling 'minbleicsetlc': looks like one of arguments has wrong size");
    
    k = ap.rows(c);
    
    _core_minbleicsetlc( state,  c,  ct,  k, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minbleicsetcond(minbleicstate state, double epsg, double epsf, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicsetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicsetcond(minbleicstate state, double epsg, double epsf, double epsx, int maxits)
    {
    _core_minbleicsetcond( state,  epsg,  epsf,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetscale(minbleicstate state, double[] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_ser_minbleicsetscale(&_s_errormsg, &_d_state, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    public static void minbleicsetscale(minbleicstate state, double[] s)
    {
    _core_minbleicsetscale( state,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetprecdefault(minbleicstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicsetprecdefault(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetprecdefault' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicsetprecdefault(minbleicstate state)
    {
    _core_minbleicsetprecdefault( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetprecdiag(minbleicstate state, double[] d, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_ser_minbleicsetprecdiag(&_s_errormsg, &_d_state, &_d_d);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetprecdiag' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    public static void minbleicsetprecdiag(minbleicstate state, double[] d)
    {
    _core_minbleicsetprecdiag( state,  d, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetprecscale(minbleicstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicsetprecscale(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetprecscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicsetprecscale(minbleicstate state)
    {
    _core_minbleicsetprecscale( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetxrep(minbleicstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicsetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicsetxrep(minbleicstate state, bool needxrep)
    {
    _core_minbleicsetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetstpmax(minbleicstate state, double stpmax, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetstpmax' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicsetstpmax(minbleicstate state, double stpmax)
    {
    _core_minbleicsetstpmax( state,  stpmax, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_minbleiciteration(minbleicstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleiciteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleiciteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool minbleiciteration(minbleicstate state)
    {
    bool result = _core_minbleiciteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void minbleicoptimize(minbleicstate state, ndimensional_func func, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minbleicoptimize()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        _i_x_minbleicstate_get_x(_state, &_xc_arg);
        _cs_arg = new double[_xc_arg.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minbleiciteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minbleiciteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minbleicstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minbleicstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minbleicstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minbleicstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minbleicoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void minbleicoptimize(minbleicstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minbleicoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_minbleicstate_get_x(_state, &_xc_arg);
        _i_x_minbleicstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minbleiciteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minbleiciteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minbleicstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minbleicstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minbleicstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minbleicstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minbleicoptimize' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_minbleicresults(minbleicstate state, out double[] x, out minbleicreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minbleicreport _d_rep = new x_minbleicreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minbleicreport_init(ref _d_rep);
            _error_code = _i_ser_minbleicresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minbleicreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minbleicreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minbleicresults(minbleicstate state, out double[] x, out minbleicreport rep)
    {
    _core_minbleicresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicresultsbuf(minbleicstate state, ref double[] x, minbleicreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minbleicreport _d_rep = new x_minbleicreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minbleicreport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_minbleicresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minbleicreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minbleicreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minbleicresultsbuf(minbleicstate state, ref double[] x, minbleicreport rep)
    {
    _core_minbleicresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicrestartfrom(minbleicstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minbleicrestartfrom(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicrestartfrom' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void minbleicrestartfrom(minbleicstate state, double[] x)
    {
    _core_minbleicrestartfrom( state,  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicrequesttermination(minbleicstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicrequesttermination(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicrequesttermination' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicrequesttermination(minbleicstate state)
    {
    _core_minbleicrequesttermination( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetgradientcheck(minbleicstate state, double teststep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicsetgradientcheck(&_s_errormsg, &_d_state, &_d_teststep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetgradientcheck' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicsetgradientcheck(minbleicstate state, double teststep)
    {
    _core_minbleicsetgradientcheck( state,  teststep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage mcpd
    //
    

    public unsafe class mcpdstate : alglibobject
    {
        public void *ptr;
        public mcpdstate(void *x)
        {
            ptr = x;
        }
        ~mcpdstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new mcpdstate(null);
            return new mcpdstate(_i_x_obj_copy_mcpdstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_mcpdstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_mcpdstate(void *x);
    private static _d_x_obj_copy_mcpdstate _i_x_obj_copy_mcpdstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_mcpdstate(void *x);
    private static _d_x_obj_free_mcpdstate _i_x_obj_free_mcpdstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mcpdreport
    {
        public x_int inneriterationscount;
        public x_int outeriterationscount;
        public x_int nfev;
        public x_int terminationtype;
    }

    public class mcpdreport : alglibobject
    {
        public int inneriterationscount;
        public int outeriterationscount;
        public int nfev;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            mcpdreport dst = new mcpdreport();
            dst.inneriterationscount = inneriterationscount;
            dst.outeriterationscount = outeriterationscount;
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mcpdreport_init(ref x_mcpdreport x)
    {
        x.inneriterationscount.longval = 0;
        x.outeriterationscount.longval = 0;
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mcpdreport_clear(ref x_mcpdreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mcpdreport_init_from(ref x_mcpdreport x, mcpdreport v)
    {
        x.inneriterationscount.longval = v.inneriterationscount;
        x.outeriterationscount.longval = v.outeriterationscount;
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mcpdreport_to_record(ref x_mcpdreport x, ref mcpdreport v)
    {
        if( v==null )
            v = new mcpdreport();
        v.inneriterationscount = x.inneriterationscount.intval; // long is silently truncated to int
        v.outeriterationscount = x.outeriterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    private static unsafe void _core_mcpdcreate(int n, out mcpdstate s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mcpdcreate(&_s_errormsg, &_d_n, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdcreate' call");
            }
            s = new mcpdstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mcpdcreate(int n, out mcpdstate s)
    {
    _core_mcpdcreate( n, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdcreateentry(int n, int entrystate, out mcpdstate s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_entrystate = new x_int(entrystate);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mcpdcreateentry(&_s_errormsg, &_d_n, &_d_entrystate, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdcreateentry' call");
            }
            s = new mcpdstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mcpdcreateentry(int n, int entrystate, out mcpdstate s)
    {
    _core_mcpdcreateentry( n,  entrystate, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdcreateexit(int n, int exitstate, out mcpdstate s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_exitstate = new x_int(exitstate);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mcpdcreateexit(&_s_errormsg, &_d_n, &_d_exitstate, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdcreateexit' call");
            }
            s = new mcpdstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mcpdcreateexit(int n, int exitstate, out mcpdstate s)
    {
    _core_mcpdcreateexit( n,  exitstate, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdcreateentryexit(int n, int entrystate, int exitstate, out mcpdstate s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_entrystate = new x_int(entrystate);
        x_int _d_exitstate = new x_int(exitstate);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mcpdcreateentryexit(&_s_errormsg, &_d_n, &_d_entrystate, &_d_exitstate, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdcreateentryexit' call");
            }
            s = new mcpdstate(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mcpdstate(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mcpdcreateentryexit(int n, int entrystate, int exitstate, out mcpdstate s)
    {
    _core_mcpdcreateentryexit( n,  entrystate,  exitstate, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdaddtrack(mcpdstate s, double[,] xy, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mcpdaddtrack(&_s_errormsg, &_d_s, &_d_xy, &_d_k);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdaddtrack' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void mcpdaddtrack(mcpdstate s, double[,] xy, int k)
    {
    _core_mcpdaddtrack( s,  xy,  k, alglibmode.serial);
    return;
    }
    public static void mcpdaddtrack(mcpdstate s, double[,] xy)
    {
    int k;
    
    
    k = ap.rows(xy);
    
    _core_mcpdaddtrack( s,  xy,  k, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_mcpdsetec(mcpdstate s, double[,] ec, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_ec = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_ec = ec){
                x_matrix_attach_to_array(ref _d_ec, _fp_ec, ap.rows(ec), ap.cols(ec));
                _error_code = _i_ser_mcpdsetec(&_s_errormsg, &_d_s, &_d_ec);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdsetec' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_ec);
        }
        // This function returns no value.
    }
    public static void mcpdsetec(mcpdstate s, double[,] ec)
    {
    _core_mcpdsetec( s,  ec, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdaddec(mcpdstate s, int i, int j, double c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_c = c;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mcpdaddec(&_s_errormsg, &_d_s, &_d_i, &_d_j, &_d_c);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdaddec' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mcpdaddec(mcpdstate s, int i, int j, double c)
    {
    _core_mcpdaddec( s,  i,  j,  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdsetbc(mcpdstate s, double[,] bndl, double[,] bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_bndl = new x_matrix();
        x_matrix _d_bndu = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_matrix_attach_to_array(ref _d_bndl, _fp_bndl, ap.rows(bndl), ap.cols(bndl));
                x_matrix_attach_to_array(ref _d_bndu, _fp_bndu, ap.rows(bndu), ap.cols(bndu));
                _error_code = _i_ser_mcpdsetbc(&_s_errormsg, &_d_s, &_d_bndl, &_d_bndu);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdsetbc' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_bndl);
            x_matrix_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    public static void mcpdsetbc(mcpdstate s, double[,] bndl, double[,] bndu)
    {
    _core_mcpdsetbc( s,  bndl,  bndu, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdaddbc(mcpdstate s, int i, int j, double bndl, double bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_i = new x_int(i);
        x_int _d_j = new x_int(j);
        double _d_bndl = bndl;
        double _d_bndu = bndu;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mcpdaddbc(&_s_errormsg, &_d_s, &_d_i, &_d_j, &_d_bndl, &_d_bndu);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdaddbc' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mcpdaddbc(mcpdstate s, int i, int j, double bndl, double bndu)
    {
    _core_mcpdaddbc( s,  i,  j,  bndl,  bndu, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdsetlc(mcpdstate s, double[,] c, int[] ct, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_ser_mcpdsetlc(&_s_errormsg, &_d_s, &_d_c, &_d_ct, &_d_k);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdsetlc' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    public static void mcpdsetlc(mcpdstate s, double[,] c, int[] ct, int k)
    {
    _core_mcpdsetlc( s,  c,  ct,  k, alglibmode.serial);
    return;
    }
    public static void mcpdsetlc(mcpdstate s, double[,] c, int[] ct)
    {
    int k;
    
    if( (ap.rows(c)!=ap.len(ct)))
        throw new alglibexception("Error while calling 'mcpdsetlc': looks like one of arguments has wrong size");
    
    k = ap.rows(c);
    
    _core_mcpdsetlc( s,  c,  ct,  k, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_mcpdsettikhonovregularizer(mcpdstate s, double v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_v = v;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mcpdsettikhonovregularizer(&_s_errormsg, &_d_s, &_d_v);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdsettikhonovregularizer' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mcpdsettikhonovregularizer(mcpdstate s, double v)
    {
    _core_mcpdsettikhonovregularizer( s,  v, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdsetprior(mcpdstate s, double[,] pp, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_pp = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_pp = pp){
                x_matrix_attach_to_array(ref _d_pp, _fp_pp, ap.rows(pp), ap.cols(pp));
                _error_code = _i_ser_mcpdsetprior(&_s_errormsg, &_d_s, &_d_pp);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdsetprior' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_pp);
        }
        // This function returns no value.
    }
    public static void mcpdsetprior(mcpdstate s, double[,] pp)
    {
    _core_mcpdsetprior( s,  pp, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdsetpredictionweights(mcpdstate s, double[] pw, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_pw = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_pw = pw){
                x_vector_attach_to_array(ref _d_pw, _fp_pw, ap.len(pw));
                _error_code = _i_ser_mcpdsetpredictionweights(&_s_errormsg, &_d_s, &_d_pw);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdsetpredictionweights' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_pw);
        }
        // This function returns no value.
    }
    public static void mcpdsetpredictionweights(mcpdstate s, double[] pw)
    {
    _core_mcpdsetpredictionweights( s,  pw, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdsolve(mcpdstate s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mcpdsolve(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdsolve' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mcpdsolve(mcpdstate s)
    {
    _core_mcpdsolve( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mcpdresults(mcpdstate s, out double[,] p, out mcpdreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_p = new x_matrix();
        x_mcpdreport _d_rep = new x_mcpdreport();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_p, DT_REAL);
            p = null;
            x_mcpdreport_init(ref _d_rep);
            _error_code = _i_ser_mcpdresults(&_s_errormsg, &_d_s, &_d_p, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mcpdresults' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_p.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_p, ref p);
            if( p == null )
                p = new double[0,0];
            rep = null;
            x_mcpdreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_p);
            x_mcpdreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mcpdresults(mcpdstate s, out double[,] p, out mcpdreport rep)
    {
    _core_mcpdresults( s, out  p, out  rep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage mlpe
    //
    

    public unsafe class mlpensemble : alglibobject
    {
        public void *ptr;
        public mlpensemble(void *x)
        {
            ptr = x;
        }
        ~mlpensemble()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new mlpensemble(null);
            return new mlpensemble(_i_x_obj_copy_mlpensemble(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_mlpensemble(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_mlpensemble(void *x);
    private static _d_x_obj_copy_mlpensemble _i_x_obj_copy_mlpensemble = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_mlpensemble(void *x);
    private static _d_x_obj_free_mlpensemble _i_x_obj_free_mlpensemble = null;
    public static unsafe void mlpeserialize(mlpensemble obj, out string s_out)
    {
        byte *_error_msg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        int _error_code = _i_x_mlpeserialize(&_error_msg, &_x, &_out);
        if( _error_code!=X_OK )
            throw new alglibexception(_error_code==X_ASSERTION_FAILED
                ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                : "ALGLIB: unknown error during mlpeserialize() call");
        s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        x_free((IntPtr)_out);
    }
    
    public static unsafe void mlpeunserialize(string s_in, out mlpensemble obj)
    {
        byte *_error_msg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            int _error_code = _i_x_mlpeunserialize(&_error_msg, &_in, &_x);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                    : "ALGLIB: unknown error during mlpeunserialize() call");
            obj = new mlpensemble(_x);
        }
    }
    private static unsafe void _core_mlpecreate0(int nin, int nout, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreate0(&_s_errormsg, &_d_nin, &_d_nout, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreate0' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreate0(int nin, int nout, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreate0( nin,  nout,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreate1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreate1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreate1' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreate1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreate1( nin,  nhid,  nout,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreate2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreate2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreate2' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreate2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreate2( nin,  nhid1,  nhid2,  nout,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreateb0(int nin, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreateb0(&_s_errormsg, &_d_nin, &_d_nout, &_d_b, &_d_d, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreateb0' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreateb0(int nin, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreateb0( nin,  nout,  b,  d,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreateb1(int nin, int nhid, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreateb1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_b, &_d_d, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreateb1' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreateb1(int nin, int nhid, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreateb1( nin,  nhid,  nout,  b,  d,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        double _d_b = b;
        double _d_d = d;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreateb2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_b, &_d_d, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreateb2' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreateb2(int nin, int nhid1, int nhid2, int nout, double b, double d, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreateb2( nin,  nhid1,  nhid2,  nout,  b,  d,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreater0(int nin, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreater0(&_s_errormsg, &_d_nin, &_d_nout, &_d_a, &_d_b, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreater0' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreater0(int nin, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreater0( nin,  nout,  a,  b,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreater1(int nin, int nhid, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreater1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_a, &_d_b, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreater1' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreater1(int nin, int nhid, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreater1( nin,  nhid,  nout,  a,  b,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        double _d_a = a;
        double _d_b = b;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreater2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_a, &_d_b, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreater2' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreater2(int nin, int nhid1, int nhid2, int nout, double a, double b, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreater2( nin,  nhid1,  nhid2,  nout,  a,  b,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreatec0(int nin, int nout, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreatec0(&_s_errormsg, &_d_nin, &_d_nout, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreatec0' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreatec0(int nin, int nout, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreatec0( nin,  nout,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreatec1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid = new x_int(nhid);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreatec1(&_s_errormsg, &_d_nin, &_d_nhid, &_d_nout, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreatec1' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreatec1(int nin, int nhid, int nout, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreatec1( nin,  nhid,  nout,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreatec2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nhid1 = new x_int(nhid1);
        x_int _d_nhid2 = new x_int(nhid2);
        x_int _d_nout = new x_int(nout);
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreatec2(&_s_errormsg, &_d_nin, &_d_nhid1, &_d_nhid2, &_d_nout, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreatec2' call");
            }
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreatec2(int nin, int nhid1, int nhid2, int nout, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreatec2( nin,  nhid1,  nhid2,  nout,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpecreatefromnetwork(multilayerperceptron network, int ensemblesize, out mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_int _d_ensemblesize = new x_int(ensemblesize);
        void *_d_ensemble = null;
        ensemble = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpecreatefromnetwork(&_s_errormsg, &_d_network, &_d_ensemblesize, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpecreatefromnetwork' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            ensemble = new mlpensemble(_d_ensemble);
        }
        finally
        {
            if( _d_ensemble!=null && ensemble==null)
                _i_x_obj_free_mlpensemble(_d_ensemble); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpecreatefromnetwork(multilayerperceptron network, int ensemblesize, out mlpensemble ensemble)
    {
    _core_mlpecreatefromnetwork( network,  ensemblesize, out  ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlperandomize(mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlperandomize(&_s_errormsg, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlperandomize' call");
            }
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlperandomize(mlpensemble ensemble)
    {
    _core_mlperandomize( ensemble, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpeproperties(mlpensemble ensemble, out int nin, out int nout, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_int _d_nin = new x_int();
        x_int _d_nout = new x_int();
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpeproperties(&_s_errormsg, &_d_ensemble, &_d_nin, &_d_nout);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpeproperties' call");
            }
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            nin = _d_nin.intval;
            nout = _d_nout.intval;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpeproperties(mlpensemble ensemble, out int nin, out int nout)
    {
    _core_mlpeproperties( ensemble, out  nin, out  nout, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_mlpeissoftmax(mlpensemble ensemble, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_ensemble = ensemble.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpeissoftmax(&_s_errormsg, &_d_result, &_d_ensemble);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpeissoftmax' call");
            }
            result = _d_result!=0;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool mlpeissoftmax(mlpensemble ensemble)
    {
    bool result = _core_mlpeissoftmax( ensemble, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_mlpeprocess(mlpensemble ensemble, double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_mlpeprocess(&_s_errormsg, &_d_ensemble, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpeprocess' call");
            }
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void mlpeprocess(mlpensemble ensemble, double[] x, ref double[] y)
    {
    _core_mlpeprocess( ensemble,  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpeprocessi(mlpensemble ensemble, double[] x, out double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_ser_mlpeprocessi(&_s_errormsg, &_d_ensemble, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpeprocessi' call");
            }
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void mlpeprocessi(mlpensemble ensemble, double[] x, out double[] y)
    {
    _core_mlpeprocessi( ensemble,  x, out  y, alglibmode.serial);
    return;
    }
    private static unsafe double _core_mlperelclserror(mlpensemble ensemble, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mlperelclserror(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlperelclserror' call");
            }
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlperelclserror(mlpensemble ensemble, double[,] xy, int npoints)
    {
    double result = _core_mlperelclserror( ensemble,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_mlpeavgce(mlpensemble ensemble, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mlpeavgce(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpeavgce' call");
            }
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlpeavgce(mlpensemble ensemble, double[,] xy, int npoints)
    {
    double result = _core_mlpeavgce( ensemble,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_mlpermserror(mlpensemble ensemble, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mlpermserror(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpermserror' call");
            }
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlpermserror(mlpensemble ensemble, double[,] xy, int npoints)
    {
    double result = _core_mlpermserror( ensemble,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_mlpeavgerror(mlpensemble ensemble, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mlpeavgerror(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpeavgerror' call");
            }
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlpeavgerror(mlpensemble ensemble, double[,] xy, int npoints)
    {
    double result = _core_mlpeavgerror( ensemble,  xy,  npoints, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_mlpeavgrelerror(mlpensemble ensemble, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mlpeavgrelerror(&_s_errormsg, &_d_result, &_d_ensemble, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpeavgrelerror' call");
            }
            result = _d_result;
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        return result;
    }
    public static double mlpeavgrelerror(mlpensemble ensemble, double[,] xy, int npoints)
    {
    double result = _core_mlpeavgrelerror( ensemble,  xy,  npoints, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage minlbfgs
    //
    

    public unsafe class minlbfgsstate : alglibobject
    {
        public void *ptr;
        public minlbfgsstate(void *x)
        {
            ptr = x;
        }
        ~minlbfgsstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new minlbfgsstate(null);
            return new minlbfgsstate(_i_x_obj_copy_minlbfgsstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_minlbfgsstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minlbfgsstate(void *x);
    private static _d_x_obj_copy_minlbfgsstate _i_x_obj_copy_minlbfgsstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_minlbfgsstate(void *x);
    private static _d_x_obj_free_minlbfgsstate _i_x_obj_free_minlbfgsstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_set_needf(void *x, byte *dst);
    private static _d_x_minlbfgsstate_get_needf _i_x_minlbfgsstate_get_needf = null;
    private static _d_x_minlbfgsstate_set_needf _i_x_minlbfgsstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_set_needfg(void *x, byte *dst);
    private static _d_x_minlbfgsstate_get_needfg _i_x_minlbfgsstate_get_needfg = null;
    private static _d_x_minlbfgsstate_set_needfg _i_x_minlbfgsstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minlbfgsstate_get_xupdated _i_x_minlbfgsstate_get_xupdated = null;
    private static _d_x_minlbfgsstate_set_xupdated _i_x_minlbfgsstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_set_f(void *x, double *dst);
    private static _d_x_minlbfgsstate_get_f _i_x_minlbfgsstate_get_f = null;
    private static _d_x_minlbfgsstate_set_f _i_x_minlbfgsstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_get_g(void *x, x_vector *dst);
    private static _d_x_minlbfgsstate_get_g _i_x_minlbfgsstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlbfgsstate_get_x(void *x, x_vector *dst);
    private static _d_x_minlbfgsstate_get_x _i_x_minlbfgsstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minlbfgsreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int varidx;
        public x_int terminationtype;
    }

    public class minlbfgsreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int varidx;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            minlbfgsreport dst = new minlbfgsreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.varidx = varidx;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minlbfgsreport_init(ref x_minlbfgsreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.varidx.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minlbfgsreport_clear(ref x_minlbfgsreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minlbfgsreport_init_from(ref x_minlbfgsreport x, minlbfgsreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.varidx.longval = v.varidx;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minlbfgsreport_to_record(ref x_minlbfgsreport x, ref minlbfgsreport v)
    {
        if( v==null )
            v = new minlbfgsreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    private static unsafe void _core_minlbfgscreate(int n, int m, double[] x, out minlbfgsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlbfgscreate(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgscreate' call");
            }
            state = new minlbfgsstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlbfgsstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minlbfgscreate(int n, int m, double[] x, out minlbfgsstate state)
    {
    _core_minlbfgscreate( n,  m,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minlbfgscreate(int m, double[] x, out minlbfgsstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minlbfgscreate( n,  m,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minlbfgscreatef(int n, int m, double[] x, double diffstep, out minlbfgsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlbfgscreatef(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_diffstep, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgscreatef' call");
            }
            state = new minlbfgsstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlbfgsstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minlbfgscreatef(int n, int m, double[] x, double diffstep, out minlbfgsstate state)
    {
    _core_minlbfgscreatef( n,  m,  x,  diffstep, out  state, alglibmode.serial);
    return;
    }
    public static void minlbfgscreatef(int m, double[] x, double diffstep, out minlbfgsstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minlbfgscreatef( n,  m,  x,  diffstep, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minlbfgssetcond(minlbfgsstate state, double epsg, double epsf, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgssetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlbfgssetcond(minlbfgsstate state, double epsg, double epsf, double epsx, int maxits)
    {
    _core_minlbfgssetcond( state,  epsg,  epsf,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetxrep(minlbfgsstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgssetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlbfgssetxrep(minlbfgsstate state, bool needxrep)
    {
    _core_minlbfgssetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetstpmax(minlbfgsstate state, double stpmax, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgssetstpmax(&_s_errormsg, &_d_state, &_d_stpmax);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetstpmax' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlbfgssetstpmax(minlbfgsstate state, double stpmax)
    {
    _core_minlbfgssetstpmax( state,  stpmax, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetscale(minlbfgsstate state, double[] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_ser_minlbfgssetscale(&_s_errormsg, &_d_state, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    public static void minlbfgssetscale(minlbfgsstate state, double[] s)
    {
    _core_minlbfgssetscale( state,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetprecdefault(minlbfgsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgssetprecdefault(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetprecdefault' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlbfgssetprecdefault(minlbfgsstate state)
    {
    _core_minlbfgssetprecdefault( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetpreccholesky(minlbfgsstate state, double[,] p, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_p = new x_matrix();
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_p = p){
                x_matrix_attach_to_array(ref _d_p, _fp_p, ap.rows(p), ap.cols(p));
                _error_code = _i_ser_minlbfgssetpreccholesky(&_s_errormsg, &_d_state, &_d_p, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetpreccholesky' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_p);
        }
        // This function returns no value.
    }
    public static void minlbfgssetpreccholesky(minlbfgsstate state, double[,] p, bool isupper)
    {
    _core_minlbfgssetpreccholesky( state,  p,  isupper, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetprecdiag(minlbfgsstate state, double[] d, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_d = d){
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_ser_minlbfgssetprecdiag(&_s_errormsg, &_d_state, &_d_d);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetprecdiag' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    public static void minlbfgssetprecdiag(minlbfgsstate state, double[] d)
    {
    _core_minlbfgssetprecdiag( state,  d, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetprecscale(minlbfgsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgssetprecscale(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetprecscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlbfgssetprecscale(minlbfgsstate state)
    {
    _core_minlbfgssetprecscale( state, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_minlbfgsiteration(minlbfgsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgsiteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgsiteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool minlbfgsiteration(minlbfgsstate state)
    {
    bool result = _core_minlbfgsiteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void minlbfgsoptimize(minlbfgsstate state, ndimensional_func func, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minlbfgsoptimize()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        _i_x_minlbfgsstate_get_x(_state, &_xc_arg);
        _cs_arg = new double[_xc_arg.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minlbfgsiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minlbfgsiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlbfgsstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlbfgsstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minlbfgsstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlbfgsstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlbfgsoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void minlbfgsoptimize(minlbfgsstate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minlbfgsoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_minlbfgsstate_get_x(_state, &_xc_arg);
        _i_x_minlbfgsstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minlbfgsiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minlbfgsiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlbfgsstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlbfgsstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minlbfgsstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlbfgsstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlbfgsoptimize' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_minlbfgsresults(minlbfgsstate state, out double[] x, out minlbfgsreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlbfgsreport _d_rep = new x_minlbfgsreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minlbfgsreport_init(ref _d_rep);
            _error_code = _i_ser_minlbfgsresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgsresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minlbfgsreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlbfgsreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minlbfgsresults(minlbfgsstate state, out double[] x, out minlbfgsreport rep)
    {
    _core_minlbfgsresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgsresultsbuf(minlbfgsstate state, ref double[] x, minlbfgsreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlbfgsreport _d_rep = new x_minlbfgsreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minlbfgsreport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_minlbfgsresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgsresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minlbfgsreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlbfgsreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minlbfgsresultsbuf(minlbfgsstate state, ref double[] x, minlbfgsreport rep)
    {
    _core_minlbfgsresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgsrestartfrom(minlbfgsstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlbfgsrestartfrom(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgsrestartfrom' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void minlbfgsrestartfrom(minlbfgsstate state, double[] x)
    {
    _core_minlbfgsrestartfrom( state,  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgsrequesttermination(minlbfgsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgsrequesttermination(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgsrequesttermination' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlbfgsrequesttermination(minlbfgsstate state)
    {
    _core_minlbfgsrequesttermination( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetgradientcheck(minlbfgsstate state, double teststep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgssetgradientcheck(&_s_errormsg, &_d_state, &_d_teststep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetgradientcheck' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlbfgssetgradientcheck(minlbfgsstate state, double teststep)
    {
    _core_minlbfgssetgradientcheck( state,  teststep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage mlptrain
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mlpreport
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public x_int ngrad;
        public x_int nhess;
        public x_int ncholesky;
    }

    public class mlpreport : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public int ngrad;
        public int nhess;
        public int ncholesky;
        public override alglib.alglibobject make_copy()
        {
            mlpreport dst = new mlpreport();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.ngrad = ngrad;
            dst.nhess = nhess;
            dst.ncholesky = ncholesky;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mlpreport_init(ref x_mlpreport x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.ngrad.longval = 0;
        x.nhess.longval = 0;
        x.ncholesky.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mlpreport_clear(ref x_mlpreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mlpreport_init_from(ref x_mlpreport x, mlpreport v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.ngrad.longval = v.ngrad;
        x.nhess.longval = v.nhess;
        x.ncholesky.longval = v.ncholesky;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mlpreport_to_record(ref x_mlpreport x, ref mlpreport v)
    {
        if( v==null )
            v = new mlpreport();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.ngrad = x.ngrad.intval; // long is silently truncated to int
        v.nhess = x.nhess.intval; // long is silently truncated to int
        v.ncholesky = x.ncholesky.intval; // long is silently truncated to int
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_mlpcvreport
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
    }

    public class mlpcvreport : alglibobject
    {
        public double relclserror;
        public double avgce;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public override alglib.alglibobject make_copy()
        {
            mlpcvreport dst = new mlpcvreport();
            dst.relclserror = relclserror;
            dst.avgce = avgce;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_mlpcvreport_init(ref x_mlpcvreport x)
    {
        x.relclserror = 0;
        x.avgce = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_mlpcvreport_clear(ref x_mlpcvreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_mlpcvreport_init_from(ref x_mlpcvreport x, mlpcvreport v)
    {
        x.relclserror = v.relclserror;
        x.avgce = v.avgce;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_mlpcvreport_to_record(ref x_mlpcvreport x, ref mlpcvreport v)
    {
        if( v==null )
            v = new mlpcvreport();
        v.relclserror = x.relclserror;
        v.avgce = x.avgce;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
    }

    public unsafe class mlptrainer : alglibobject
    {
        public void *ptr;
        public mlptrainer(void *x)
        {
            ptr = x;
        }
        ~mlptrainer()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new mlptrainer(null);
            return new mlptrainer(_i_x_obj_copy_mlptrainer(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_mlptrainer(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_mlptrainer(void *x);
    private static _d_x_obj_copy_mlptrainer _i_x_obj_copy_mlptrainer = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_mlptrainer(void *x);
    private static _d_x_obj_free_mlptrainer _i_x_obj_free_mlptrainer = null;
    private static unsafe void _core_mlptrainlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                _error_code = _i_ser_mlptrainlm(&_s_errormsg, &_d_network, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlptrainlm' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlptrainlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep)
    {
    _core_mlptrainlm( network,  xy,  npoints,  decay,  restarts, out  info, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlptrainlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        double _d_wstep = wstep;
        x_int _d_maxits = new x_int(maxits);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                _error_code = _i_ser_mlptrainlbfgs(&_s_errormsg, &_d_network, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_wstep, &_d_maxits, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlptrainlbfgs' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlptrainlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep)
    {
    _core_mlptrainlbfgs( network,  xy,  npoints,  decay,  restarts,  wstep,  maxits, out  info, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlptraines(multilayerperceptron network, double[,] trnxy, int trnsize, double[,] valxy, int valsize, double decay, int restarts, out int info, out mlpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_trnxy = new x_matrix();
        x_int _d_trnsize = new x_int(trnsize);
        x_matrix _d_valxy = new x_matrix();
        x_int _d_valsize = new x_int(valsize);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_trnxy = trnxy, _fp_valxy = valxy){
                x_matrix_attach_to_array(ref _d_trnxy, _fp_trnxy, ap.rows(trnxy), ap.cols(trnxy));
                x_matrix_attach_to_array(ref _d_valxy, _fp_valxy, ap.rows(valxy), ap.cols(valxy));
                x_mlpreport_init(ref _d_rep);
                _error_code = _i_ser_mlptraines(&_s_errormsg, &_d_network, &_d_trnxy, &_d_trnsize, &_d_valxy, &_d_valsize, &_d_decay, &_d_restarts, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlptraines' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_trnxy);
            x_matrix_clear(ref _d_valxy);
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlptraines(multilayerperceptron network, double[,] trnxy, int trnsize, double[,] valxy, int valsize, double decay, int restarts, out int info, out mlpreport rep)
    {
    _core_mlptraines( network,  trnxy,  trnsize,  valxy,  valsize,  decay,  restarts, out  info, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpkfoldcvlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        double _d_wstep = wstep;
        x_int _d_maxits = new x_int(maxits);
        x_int _d_foldscount = new x_int(foldscount);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        x_mlpcvreport _d_cvrep = new x_mlpcvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                x_mlpcvreport_init(ref _d_cvrep);
                _error_code = _i_ser_mlpkfoldcvlbfgs(&_s_errormsg, &_d_network, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_wstep, &_d_maxits, &_d_foldscount, &_d_info, &_d_rep, &_d_cvrep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpkfoldcvlbfgs' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
            cvrep = null;
            x_mlpcvreport_to_record(ref _d_cvrep, ref cvrep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
            x_mlpcvreport_clear(ref _d_cvrep);
        }
        // This function returns no value.
    }
    public static void mlpkfoldcvlbfgs(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep)
    {
    _core_mlpkfoldcvlbfgs( network,  xy,  npoints,  decay,  restarts,  wstep,  maxits,  foldscount, out  info, out  rep, out  cvrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpkfoldcvlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_network = network.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_foldscount = new x_int(foldscount);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        x_mlpcvreport _d_cvrep = new x_mlpcvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                x_mlpcvreport_init(ref _d_cvrep);
                _error_code = _i_ser_mlpkfoldcvlm(&_s_errormsg, &_d_network, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_foldscount, &_d_info, &_d_rep, &_d_cvrep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpkfoldcvlm' call");
            }
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
            cvrep = null;
            x_mlpcvreport_to_record(ref _d_cvrep, ref cvrep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
            x_mlpcvreport_clear(ref _d_cvrep);
        }
        // This function returns no value.
    }
    public static void mlpkfoldcvlm(multilayerperceptron network, double[,] xy, int npoints, double decay, int restarts, int foldscount, out int info, out mlpreport rep, out mlpcvreport cvrep)
    {
    _core_mlpkfoldcvlm( network,  xy,  npoints,  decay,  restarts,  foldscount, out  info, out  rep, out  cvrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpkfoldcv(mlptrainer s, multilayerperceptron network, int nrestarts, int foldscount, out mlpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_network = network.ptr;
        x_int _d_nrestarts = new x_int(nrestarts);
        x_int _d_foldscount = new x_int(foldscount);
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            x_mlpreport_init(ref _d_rep);
            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlpkfoldcv(&_s_errormsg, &_d_s, &_d_network, &_d_nrestarts, &_d_foldscount, &_d_rep);
            else    _error_code = _i_smp_mlpkfoldcv(&_s_errormsg, &_d_s, &_d_network, &_d_nrestarts, &_d_foldscount, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpkfoldcv' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlpkfoldcv(mlptrainer s, multilayerperceptron network, int nrestarts, int foldscount, out mlpreport rep)
    {
    _core_mlpkfoldcv( s,  network,  nrestarts,  foldscount, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_mlpkfoldcv(mlptrainer s, multilayerperceptron network, int nrestarts, int foldscount, out mlpreport rep)
    {
    _core_mlpkfoldcv( s,  network,  nrestarts,  foldscount, out  rep, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_mlpcreatetrainer(int nin, int nout, out mlptrainer s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nout = new x_int(nout);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreatetrainer(&_s_errormsg, &_d_nin, &_d_nout, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreatetrainer' call");
            }
            s = new mlptrainer(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mlptrainer(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreatetrainer(int nin, int nout, out mlptrainer s)
    {
    _core_mlpcreatetrainer( nin,  nout, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpcreatetrainercls(int nin, int nclasses, out mlptrainer s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nin = new x_int(nin);
        x_int _d_nclasses = new x_int(nclasses);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpcreatetrainercls(&_s_errormsg, &_d_nin, &_d_nclasses, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcreatetrainercls' call");
            }
            s = new mlptrainer(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_mlptrainer(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void mlpcreatetrainercls(int nin, int nclasses, out mlptrainer s)
    {
    _core_mlpcreatetrainercls( nin,  nclasses, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpsetdataset(mlptrainer s, double[,] xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_mlpsetdataset(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetdataset' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void mlpsetdataset(mlptrainer s, double[,] xy, int npoints)
    {
    _core_mlpsetdataset( s,  xy,  npoints, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpsetsparsedataset(mlptrainer s, sparsematrix xy, int npoints, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_xy = xy.ptr;
        x_int _d_npoints = new x_int(npoints);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpsetsparsedataset(&_s_errormsg, &_d_s, &_d_xy, &_d_npoints);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetsparsedataset' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(xy.ptr==_d_xy, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpsetsparsedataset(mlptrainer s, sparsematrix xy, int npoints)
    {
    _core_mlpsetsparsedataset( s,  xy,  npoints, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpsetdecay(mlptrainer s, double decay, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_decay = decay;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpsetdecay(&_s_errormsg, &_d_s, &_d_decay);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetdecay' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpsetdecay(mlptrainer s, double decay)
    {
    _core_mlpsetdecay( s,  decay, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpsetcond(mlptrainer s, double wstep, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_wstep = wstep;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpsetcond(&_s_errormsg, &_d_s, &_d_wstep, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetcond' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpsetcond(mlptrainer s, double wstep, int maxits)
    {
    _core_mlpsetcond( s,  wstep,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpsetalgobatch(mlptrainer s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpsetalgobatch(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpsetalgobatch' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpsetalgobatch(mlptrainer s)
    {
    _core_mlpsetalgobatch( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlptrainnetwork(mlptrainer s, multilayerperceptron network, int nrestarts, out mlpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_network = network.ptr;
        x_int _d_nrestarts = new x_int(nrestarts);
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            x_mlpreport_init(ref _d_rep);
            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlptrainnetwork(&_s_errormsg, &_d_s, &_d_network, &_d_nrestarts, &_d_rep);
            else    _error_code = _i_smp_mlptrainnetwork(&_s_errormsg, &_d_s, &_d_network, &_d_nrestarts, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlptrainnetwork' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlptrainnetwork(mlptrainer s, multilayerperceptron network, int nrestarts, out mlpreport rep)
    {
    _core_mlptrainnetwork( s,  network,  nrestarts, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_mlptrainnetwork(mlptrainer s, multilayerperceptron network, int nrestarts, out mlpreport rep)
    {
    _core_mlptrainnetwork( s,  network,  nrestarts, out  rep, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_mlpstarttraining(mlptrainer s, multilayerperceptron network, bool randomstart, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_network = network.ptr;
        byte _d_randomstart = (byte)(randomstart ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_mlpstarttraining(&_s_errormsg, &_d_s, &_d_network, &_d_randomstart);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpstarttraining' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void mlpstarttraining(mlptrainer s, multilayerperceptron network, bool randomstart)
    {
    _core_mlpstarttraining( s,  network,  randomstart, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_mlpcontinuetraining(mlptrainer s, multilayerperceptron network, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_s = s.ptr;
        void *_d_network = network.ptr;
        
        // Pack, call, unpack
        try
        {

            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlpcontinuetraining(&_s_errormsg, &_d_result, &_d_s, &_d_network);
            else    _error_code = _i_smp_mlpcontinuetraining(&_s_errormsg, &_d_result, &_d_s, &_d_network);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpcontinuetraining' call");
            }
            result = _d_result!=0;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(network.ptr==_d_network, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool mlpcontinuetraining(mlptrainer s, multilayerperceptron network)
    {
    bool result = _core_mlpcontinuetraining( s,  network, alglibmode.serial);
    return result;
    }
    public static bool smp_mlpcontinuetraining(mlptrainer s, multilayerperceptron network)
    {
    bool result = _core_mlpcontinuetraining( s,  network, alglibmode.parallel);
    return result;
    }
    private static unsafe void _core_mlpebagginglm(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, out mlpcvreport ooberrors, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        x_mlpcvreport _d_ooberrors = new x_mlpcvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                x_mlpcvreport_init(ref _d_ooberrors);
                _error_code = _i_ser_mlpebagginglm(&_s_errormsg, &_d_ensemble, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_info, &_d_rep, &_d_ooberrors);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpebagginglm' call");
            }
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
            ooberrors = null;
            x_mlpcvreport_to_record(ref _d_ooberrors, ref ooberrors);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
            x_mlpcvreport_clear(ref _d_ooberrors);
        }
        // This function returns no value.
    }
    public static void mlpebagginglm(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, out mlpcvreport ooberrors)
    {
    _core_mlpebagginglm( ensemble,  xy,  npoints,  decay,  restarts, out  info, out  rep, out  ooberrors, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpebagginglbfgs(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep, out mlpcvreport ooberrors, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        double _d_wstep = wstep;
        x_int _d_maxits = new x_int(maxits);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        x_mlpcvreport _d_ooberrors = new x_mlpcvreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                x_mlpcvreport_init(ref _d_ooberrors);
                _error_code = _i_ser_mlpebagginglbfgs(&_s_errormsg, &_d_ensemble, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_wstep, &_d_maxits, &_d_info, &_d_rep, &_d_ooberrors);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpebagginglbfgs' call");
            }
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
            ooberrors = null;
            x_mlpcvreport_to_record(ref _d_ooberrors, ref ooberrors);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
            x_mlpcvreport_clear(ref _d_ooberrors);
        }
        // This function returns no value.
    }
    public static void mlpebagginglbfgs(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, double wstep, int maxits, out int info, out mlpreport rep, out mlpcvreport ooberrors)
    {
    _core_mlpebagginglbfgs( ensemble,  xy,  npoints,  decay,  restarts,  wstep,  maxits, out  info, out  rep, out  ooberrors, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlpetraines(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_ensemble = ensemble.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        double _d_decay = decay;
        x_int _d_restarts = new x_int(restarts);
        x_int _d_info = new x_int();
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                x_mlpreport_init(ref _d_rep);
                _error_code = _i_ser_mlpetraines(&_s_errormsg, &_d_ensemble, &_d_xy, &_d_npoints, &_d_decay, &_d_restarts, &_d_info, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlpetraines' call");
            }
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlpetraines(mlpensemble ensemble, double[,] xy, int npoints, double decay, int restarts, out int info, out mlpreport rep)
    {
    _core_mlpetraines( ensemble,  xy,  npoints,  decay,  restarts, out  info, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_mlptrainensemblees(mlptrainer s, mlpensemble ensemble, int nrestarts, out mlpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        void *_d_ensemble = ensemble.ptr;
        x_int _d_nrestarts = new x_int(nrestarts);
        x_mlpreport _d_rep = new x_mlpreport();
        
        // Pack, call, unpack
        try
        {
            x_mlpreport_init(ref _d_rep);
            if( _alglib_mode == alglibmode.serial )
                _error_code = _i_ser_mlptrainensemblees(&_s_errormsg, &_d_s, &_d_ensemble, &_d_nrestarts, &_d_rep);
            else    _error_code = _i_smp_mlptrainensemblees(&_s_errormsg, &_d_s, &_d_ensemble, &_d_nrestarts, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mlptrainensemblees' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(ensemble.ptr==_d_ensemble, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_mlpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_mlpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void mlptrainensemblees(mlptrainer s, mlpensemble ensemble, int nrestarts, out mlpreport rep)
    {
    _core_mlptrainensemblees( s,  ensemble,  nrestarts, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_mlptrainensemblees(mlptrainer s, mlpensemble ensemble, int nrestarts, out mlpreport rep)
    {
    _core_mlptrainensemblees( s,  ensemble,  nrestarts, out  rep, alglibmode.parallel);
    return;
    }
    
    
    //
    // Subpackage pca
    //
    
    private static unsafe void _core_pcabuildbasis(double[,] x, int npoints, int nvars, out int info, out double[] s2, out double[,] v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_npoints = new x_int(npoints);
        x_int _d_nvars = new x_int(nvars);
        x_int _d_info = new x_int();
        x_vector _d_s2 = new x_vector();
        x_matrix _d_v = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_create_empty(ref _d_s2, DT_REAL);
                s2 = null;
                x_matrix_create_empty(ref _d_v, DT_REAL);
                v = null;
                _error_code = _i_ser_pcabuildbasis(&_s_errormsg, &_d_x, &_d_npoints, &_d_nvars, &_d_info, &_d_s2, &_d_v);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pcabuildbasis' call");
            }
            info = _d_info.intval;
            if( _d_s2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_s2, ref s2);
            if( s2 == null )
                s2 = new double[0];
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_s2);
            x_matrix_clear(ref _d_v);
        }
        // This function returns no value.
    }
    public static void pcabuildbasis(double[,] x, int npoints, int nvars, out int info, out double[] s2, out double[,] v)
    {
    _core_pcabuildbasis( x,  npoints,  nvars, out  info, out  s2, out  v, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage odesolver
    //
    

    public unsafe class odesolverstate : alglibobject
    {
        public void *ptr;
        public odesolverstate(void *x)
        {
            ptr = x;
        }
        ~odesolverstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new odesolverstate(null);
            return new odesolverstate(_i_x_obj_copy_odesolverstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_odesolverstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_odesolverstate(void *x);
    private static _d_x_obj_copy_odesolverstate _i_x_obj_copy_odesolverstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_odesolverstate(void *x);
    private static _d_x_obj_free_odesolverstate _i_x_obj_free_odesolverstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_odesolverstate_get_needdy(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_odesolverstate_set_needdy(void *x, byte *dst);
    private static _d_x_odesolverstate_get_needdy _i_x_odesolverstate_get_needdy = null;
    private static _d_x_odesolverstate_set_needdy _i_x_odesolverstate_set_needdy = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_odesolverstate_get_y(void *x, x_vector *dst);
    private static _d_x_odesolverstate_get_y _i_x_odesolverstate_get_y = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_odesolverstate_get_dy(void *x, x_vector *dst);
    private static _d_x_odesolverstate_get_dy _i_x_odesolverstate_get_dy = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_odesolverstate_get_x(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_odesolverstate_set_x(void *x, double *dst);
    private static _d_x_odesolverstate_get_x _i_x_odesolverstate_get_x = null;
    private static _d_x_odesolverstate_set_x _i_x_odesolverstate_set_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_odesolverreport
    {
        public x_int nfev;
        public x_int terminationtype;
    }

    public class odesolverreport : alglibobject
    {
        public int nfev;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            odesolverreport dst = new odesolverreport();
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_odesolverreport_init(ref x_odesolverreport x)
    {
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_odesolverreport_clear(ref x_odesolverreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_odesolverreport_init_from(ref x_odesolverreport x, odesolverreport v)
    {
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_odesolverreport_to_record(ref x_odesolverreport x, ref odesolverreport v)
    {
        if( v==null )
            v = new odesolverreport();
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    private static unsafe void _core_odesolverrkck(double[] y, int n, double[] x, int m, double eps, double h, out odesolverstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_eps = eps;
        double _d_h = h;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_x = x){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_odesolverrkck(&_s_errormsg, &_d_y, &_d_n, &_d_x, &_d_m, &_d_eps, &_d_h, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'odesolverrkck' call");
            }
            state = new odesolverstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_odesolverstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void odesolverrkck(double[] y, int n, double[] x, int m, double eps, double h, out odesolverstate state)
    {
    _core_odesolverrkck( y,  n,  x,  m,  eps,  h, out  state, alglibmode.serial);
    return;
    }
    public static void odesolverrkck(double[] y, double[] x, double eps, double h, out odesolverstate state)
    {
    int n;
    int m;
    
    
    n = ap.len(y);
    m = ap.len(x);
    
    _core_odesolverrkck( y,  n,  x,  m,  eps,  h, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe bool _core_odesolveriteration(odesolverstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_odesolveriteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'odesolveriteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool odesolveriteration(odesolverstate state)
    {
    bool result = _core_odesolveriteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void odesolversolve(odesolverstate state, ndimensional_ode_rp diff, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        void *_state = state.ptr;
        double _xc_x = 0;
        x_vector _xc_y  = new x_vector();
        x_vector _xc_dy = new x_vector();
        double[] _cs_y  = null;
        double[] _cs_dy = null;
        byte _xc_needdy = 0;
    
        //
        // Check correctness of delegates
        //
        if( diff==null )
            throw new alglibexception("ALGLIB: error in 'odesolversolve()' (diff is null)");
    
        //
        // Attach x-structures to internal arrays allocated by solver
        //
        x_vector_create_empty(ref _xc_y,  DT_REAL);
        x_vector_create_empty(ref _xc_dy, DT_REAL);
        _i_x_odesolverstate_get_y(_state,  &_xc_y);
        _i_x_odesolverstate_get_dy(_state, &_xc_dy);
        _cs_y  = new double[_xc_y.cnt];
        _cs_dy = new double[_xc_dy.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_odesolveriteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during odesolveriteration() call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
    
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_odesolverstate_get_needdy(_state, &_xc_needdy);
            if( _xc_needdy!=0 )
            {
                _i_x_odesolverstate_get_x(_state, &_xc_x);
                x_vector_to_array(ref _xc_y, ref _cs_y);
                diff(_cs_y, _xc_x, _cs_dy, obj);
                x_vector_from_array(ref _xc_dy, _cs_dy, X_REWRITE);
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'odesolversolve' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_odesolverresults(odesolverstate state, out int m, out double[] xtbl, out double[,] ytbl, out odesolverreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_m = new x_int();
        x_vector _d_xtbl = new x_vector();
        x_matrix _d_ytbl = new x_matrix();
        x_odesolverreport _d_rep = new x_odesolverreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_xtbl, DT_REAL);
            xtbl = null;
            x_matrix_create_empty(ref _d_ytbl, DT_REAL);
            ytbl = null;
            x_odesolverreport_init(ref _d_rep);
            _error_code = _i_ser_odesolverresults(&_s_errormsg, &_d_state, &_d_m, &_d_xtbl, &_d_ytbl, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'odesolverresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            m = _d_m.intval;
            if( _d_xtbl.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_xtbl, ref xtbl);
            if( xtbl == null )
                xtbl = new double[0];
            if( _d_ytbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_ytbl, ref ytbl);
            if( ytbl == null )
                ytbl = new double[0,0];
            rep = null;
            x_odesolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_xtbl);
            x_matrix_clear(ref _d_ytbl);
            x_odesolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void odesolverresults(odesolverstate state, out int m, out double[] xtbl, out double[,] ytbl, out odesolverreport rep)
    {
    _core_odesolverresults( state, out  m, out  xtbl, out  ytbl, out  rep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage fft
    //
    
    private static unsafe void _core_fftc1d(ref complex[] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_fftc1d(&_s_errormsg, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fftc1d' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void fftc1d(ref complex[] a, int n)
    {
    _core_fftc1d(ref  a,  n, alglibmode.serial);
    return;
    }
    public static void fftc1d(ref complex[] a)
    {
    int n;
    
    
    n = ap.len(a);
    
    _core_fftc1d(ref  a,  n, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_fftc1dinv(ref complex[] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_fftc1dinv(&_s_errormsg, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fftc1dinv' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void fftc1dinv(ref complex[] a, int n)
    {
    _core_fftc1dinv(ref  a,  n, alglibmode.serial);
    return;
    }
    public static void fftc1dinv(ref complex[] a)
    {
    int n;
    
    
    n = ap.len(a);
    
    _core_fftc1dinv(ref  a,  n, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_fftr1d(double[] a, int n, out complex[] f, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_create_empty(ref _d_f, DT_COMPLEX);
                f = null;
                _error_code = _i_ser_fftr1d(&_s_errormsg, &_d_a, &_d_n, &_d_f);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fftr1d' call");
            }
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    public static void fftr1d(double[] a, int n, out complex[] f)
    {
    _core_fftr1d( a,  n, out  f, alglibmode.serial);
    return;
    }
    public static void fftr1d(double[] a, out complex[] f)
    {
    int n;
    
    
    n = ap.len(a);
    
    _core_fftr1d( a,  n, out  f, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_fftr1dinv(complex[] f, int n, out double[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_f = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                x_vector_create_empty(ref _d_a, DT_REAL);
                a = null;
                _error_code = _i_ser_fftr1dinv(&_s_errormsg, &_d_f, &_d_n, &_d_a);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fftr1dinv' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void fftr1dinv(complex[] f, int n, out double[] a)
    {
    _core_fftr1dinv( f,  n, out  a, alglibmode.serial);
    return;
    }
    public static void fftr1dinv(complex[] f, out double[] a)
    {
    int n;
    
    
    n = ap.len(f);
    
    _core_fftr1dinv( f,  n, out  a, alglibmode.serial);
    
    return;
    }
    
    
    //
    // Subpackage conv
    //
    
    private static unsafe void _core_convc1d(complex[] a, int m, complex[] b, int n, out complex[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_ser_convc1d(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'convc1d' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void convc1d(complex[] a, int m, complex[] b, int n, out complex[] r)
    {
    _core_convc1d( a,  m,  b,  n, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_convc1dinv(complex[] a, int m, complex[] b, int n, out complex[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_ser_convc1dinv(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'convc1dinv' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void convc1dinv(complex[] a, int m, complex[] b, int n, out complex[] r)
    {
    _core_convc1dinv( a,  m,  b,  n, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_convc1dcircular(complex[] s, int m, complex[] r, int n, out complex[] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_s = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_r = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_s = s, _fp_r = r){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                x_vector_attach_to_array(ref _d_r, _fp_r, ap.len(r));
                x_vector_create_empty(ref _d_c, DT_COMPLEX);
                c = null;
                _error_code = _i_ser_convc1dcircular(&_s_errormsg, &_d_s, &_d_m, &_d_r, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'convc1dcircular' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_s);
            x_vector_clear(ref _d_r);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void convc1dcircular(complex[] s, int m, complex[] r, int n, out complex[] c)
    {
    _core_convc1dcircular( s,  m,  r,  n, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_convc1dcircularinv(complex[] a, int m, complex[] b, int n, out complex[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_ser_convc1dcircularinv(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'convc1dcircularinv' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void convc1dcircularinv(complex[] a, int m, complex[] b, int n, out complex[] r)
    {
    _core_convc1dcircularinv( a,  m,  b,  n, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_convr1d(double[] a, int m, double[] b, int n, out double[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_ser_convr1d(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'convr1d' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void convr1d(double[] a, int m, double[] b, int n, out double[] r)
    {
    _core_convr1d( a,  m,  b,  n, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_convr1dinv(double[] a, int m, double[] b, int n, out double[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_ser_convr1dinv(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'convr1dinv' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void convr1dinv(double[] a, int m, double[] b, int n, out double[] r)
    {
    _core_convr1dinv( a,  m,  b,  n, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_convr1dcircular(double[] s, int m, double[] r, int n, out double[] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_s = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_r = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s, _fp_r = r){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                x_vector_attach_to_array(ref _d_r, _fp_r, ap.len(r));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_ser_convr1dcircular(&_s_errormsg, &_d_s, &_d_m, &_d_r, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'convr1dcircular' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_s);
            x_vector_clear(ref _d_r);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void convr1dcircular(double[] s, int m, double[] r, int n, out double[] c)
    {
    _core_convr1dcircular( s,  m,  r,  n, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_convr1dcircularinv(double[] a, int m, double[] b, int n, out double[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_b = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                x_vector_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_ser_convr1dcircularinv(&_s_errormsg, &_d_a, &_d_m, &_d_b, &_d_n, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'convr1dcircularinv' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void convr1dcircularinv(double[] a, int m, double[] b, int n, out double[] r)
    {
    _core_convr1dcircularinv( a,  m,  b,  n, out  r, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage corr
    //
    
    private static unsafe void _core_corrc1d(complex[] signal, int n, complex[] pattern, int m, out complex[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_signal = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_pattern = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_signal = signal, _fp_pattern = pattern){
                x_vector_attach_to_array(ref _d_signal, _fp_signal, ap.len(signal));
                x_vector_attach_to_array(ref _d_pattern, _fp_pattern, ap.len(pattern));
                x_vector_create_empty(ref _d_r, DT_COMPLEX);
                r = null;
                _error_code = _i_ser_corrc1d(&_s_errormsg, &_d_signal, &_d_n, &_d_pattern, &_d_m, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'corrc1d' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_signal);
            x_vector_clear(ref _d_pattern);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void corrc1d(complex[] signal, int n, complex[] pattern, int m, out complex[] r)
    {
    _core_corrc1d( signal,  n,  pattern,  m, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_corrc1dcircular(complex[] signal, int m, complex[] pattern, int n, out complex[] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_signal = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_pattern = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_signal = signal, _fp_pattern = pattern){
                x_vector_attach_to_array(ref _d_signal, _fp_signal, ap.len(signal));
                x_vector_attach_to_array(ref _d_pattern, _fp_pattern, ap.len(pattern));
                x_vector_create_empty(ref _d_c, DT_COMPLEX);
                c = null;
                _error_code = _i_ser_corrc1dcircular(&_s_errormsg, &_d_signal, &_d_m, &_d_pattern, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'corrc1dcircular' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new alglib.complex[0];
        }
        finally
        {
            x_vector_clear(ref _d_signal);
            x_vector_clear(ref _d_pattern);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void corrc1dcircular(complex[] signal, int m, complex[] pattern, int n, out complex[] c)
    {
    _core_corrc1dcircular( signal,  m,  pattern,  n, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_corrr1d(double[] signal, int n, double[] pattern, int m, out double[] r, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_signal = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_pattern = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_r = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_signal = signal, _fp_pattern = pattern){
                x_vector_attach_to_array(ref _d_signal, _fp_signal, ap.len(signal));
                x_vector_attach_to_array(ref _d_pattern, _fp_pattern, ap.len(pattern));
                x_vector_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_ser_corrr1d(&_s_errormsg, &_d_signal, &_d_n, &_d_pattern, &_d_m, &_d_r);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'corrr1d' call");
            }
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_signal);
            x_vector_clear(ref _d_pattern);
            x_vector_clear(ref _d_r);
        }
        // This function returns no value.
    }
    public static void corrr1d(double[] signal, int n, double[] pattern, int m, out double[] r)
    {
    _core_corrr1d( signal,  n,  pattern,  m, out  r, alglibmode.serial);
    return;
    }
    private static unsafe void _core_corrr1dcircular(double[] signal, int m, double[] pattern, int n, out double[] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_signal = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_pattern = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_signal = signal, _fp_pattern = pattern){
                x_vector_attach_to_array(ref _d_signal, _fp_signal, ap.len(signal));
                x_vector_attach_to_array(ref _d_pattern, _fp_pattern, ap.len(pattern));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                _error_code = _i_ser_corrr1dcircular(&_s_errormsg, &_d_signal, &_d_m, &_d_pattern, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'corrr1dcircular' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_signal);
            x_vector_clear(ref _d_pattern);
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void corrr1dcircular(double[] signal, int m, double[] pattern, int n, out double[] c)
    {
    _core_corrr1dcircular( signal,  m,  pattern,  n, out  c, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage fht
    //
    
    private static unsafe void _core_fhtr1d(ref double[] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_fhtr1d(&_s_errormsg, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fhtr1d' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void fhtr1d(ref double[] a, int n)
    {
    _core_fhtr1d(ref  a,  n, alglibmode.serial);
    return;
    }
    private static unsafe void _core_fhtr1dinv(ref double[] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_fhtr1dinv(&_s_errormsg, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fhtr1dinv' call");
            }
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void fhtr1dinv(ref double[] a, int n)
    {
    _core_fhtr1dinv(ref  a,  n, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage gq
    //
    
    private static unsafe void _core_gqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_alpha = new x_vector();
        x_vector _d_beta = new x_vector();
        double _d_mu0 = mu0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_alpha = alpha, _fp_beta = beta){
                x_vector_attach_to_array(ref _d_alpha, _fp_alpha, ap.len(alpha));
                x_vector_attach_to_array(ref _d_beta, _fp_beta, ap.len(beta));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_ser_gqgeneraterec(&_s_errormsg, &_d_alpha, &_d_beta, &_d_mu0, &_d_n, &_d_info, &_d_x, &_d_w);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gqgeneraterec' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_alpha);
            x_vector_clear(ref _d_beta);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void gqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] w)
    {
    _core_gqgeneraterec( alpha,  beta,  mu0,  n, out  info, out  x, out  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gqgenerategausslobattorec(double[] alpha, double[] beta, double mu0, double a, double b, int n, out int info, out double[] x, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_alpha = new x_vector();
        x_vector _d_beta = new x_vector();
        double _d_mu0 = mu0;
        double _d_a = a;
        double _d_b = b;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_alpha = alpha, _fp_beta = beta){
                x_vector_attach_to_array(ref _d_alpha, _fp_alpha, ap.len(alpha));
                x_vector_attach_to_array(ref _d_beta, _fp_beta, ap.len(beta));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_ser_gqgenerategausslobattorec(&_s_errormsg, &_d_alpha, &_d_beta, &_d_mu0, &_d_a, &_d_b, &_d_n, &_d_info, &_d_x, &_d_w);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gqgenerategausslobattorec' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_alpha);
            x_vector_clear(ref _d_beta);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void gqgenerategausslobattorec(double[] alpha, double[] beta, double mu0, double a, double b, int n, out int info, out double[] x, out double[] w)
    {
    _core_gqgenerategausslobattorec( alpha,  beta,  mu0,  a,  b,  n, out  info, out  x, out  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gqgenerategaussradaurec(double[] alpha, double[] beta, double mu0, double a, int n, out int info, out double[] x, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_alpha = new x_vector();
        x_vector _d_beta = new x_vector();
        double _d_mu0 = mu0;
        double _d_a = a;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_alpha = alpha, _fp_beta = beta){
                x_vector_attach_to_array(ref _d_alpha, _fp_alpha, ap.len(alpha));
                x_vector_attach_to_array(ref _d_beta, _fp_beta, ap.len(beta));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_vector_create_empty(ref _d_w, DT_REAL);
                w = null;
                _error_code = _i_ser_gqgenerategaussradaurec(&_s_errormsg, &_d_alpha, &_d_beta, &_d_mu0, &_d_a, &_d_n, &_d_info, &_d_x, &_d_w);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gqgenerategaussradaurec' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_alpha);
            x_vector_clear(ref _d_beta);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void gqgenerategaussradaurec(double[] alpha, double[] beta, double mu0, double a, int n, out int info, out double[] x, out double[] w)
    {
    _core_gqgenerategaussradaurec( alpha,  beta,  mu0,  a,  n, out  info, out  x, out  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gqgenerategausslegendre(int n, out int info, out double[] x, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_ser_gqgenerategausslegendre(&_s_errormsg, &_d_n, &_d_info, &_d_x, &_d_w);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gqgenerategausslegendre' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void gqgenerategausslegendre(int n, out int info, out double[] x, out double[] w)
    {
    _core_gqgenerategausslegendre( n, out  info, out  x, out  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        double _d_beta = beta;
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_ser_gqgenerategaussjacobi(&_s_errormsg, &_d_n, &_d_alpha, &_d_beta, &_d_info, &_d_x, &_d_w);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gqgenerategaussjacobi' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void gqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] w)
    {
    _core_gqgenerategaussjacobi( n,  alpha,  beta, out  info, out  x, out  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gqgenerategausslaguerre(int n, double alpha, out int info, out double[] x, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_ser_gqgenerategausslaguerre(&_s_errormsg, &_d_n, &_d_alpha, &_d_info, &_d_x, &_d_w);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gqgenerategausslaguerre' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void gqgenerategausslaguerre(int n, double alpha, out int info, out double[] x, out double[] w)
    {
    _core_gqgenerategausslaguerre( n,  alpha, out  info, out  x, out  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gqgenerategausshermite(int n, out int info, out double[] x, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_ser_gqgenerategausshermite(&_s_errormsg, &_d_n, &_d_info, &_d_x, &_d_w);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gqgenerategausshermite' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void gqgenerategausshermite(int n, out int info, out double[] x, out double[] w)
    {
    _core_gqgenerategausshermite( n, out  info, out  x, out  w, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage gkq
    //
    
    private static unsafe void _core_gkqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_alpha = new x_vector();
        x_vector _d_beta = new x_vector();
        double _d_mu0 = mu0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_alpha = alpha, _fp_beta = beta){
                x_vector_attach_to_array(ref _d_alpha, _fp_alpha, ap.len(alpha));
                x_vector_attach_to_array(ref _d_beta, _fp_beta, ap.len(beta));
                x_vector_create_empty(ref _d_x, DT_REAL);
                x = null;
                x_vector_create_empty(ref _d_wkronrod, DT_REAL);
                wkronrod = null;
                x_vector_create_empty(ref _d_wgauss, DT_REAL);
                wgauss = null;
                _error_code = _i_ser_gkqgeneraterec(&_s_errormsg, &_d_alpha, &_d_beta, &_d_mu0, &_d_n, &_d_info, &_d_x, &_d_wkronrod, &_d_wgauss);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gkqgeneraterec' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_alpha);
            x_vector_clear(ref _d_beta);
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    public static void gkqgeneraterec(double[] alpha, double[] beta, double mu0, int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss)
    {
    _core_gkqgeneraterec( alpha,  beta,  mu0,  n, out  info, out  x, out  wkronrod, out  wgauss, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gkqgenerategausslegendre(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_wkronrod, DT_REAL);
            wkronrod = null;
            x_vector_create_empty(ref _d_wgauss, DT_REAL);
            wgauss = null;
            _error_code = _i_ser_gkqgenerategausslegendre(&_s_errormsg, &_d_n, &_d_info, &_d_x, &_d_wkronrod, &_d_wgauss);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gkqgenerategausslegendre' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    public static void gkqgenerategausslegendre(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss)
    {
    _core_gkqgenerategausslegendre( n, out  info, out  x, out  wkronrod, out  wgauss, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gkqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        double _d_alpha = alpha;
        double _d_beta = beta;
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_wkronrod, DT_REAL);
            wkronrod = null;
            x_vector_create_empty(ref _d_wgauss, DT_REAL);
            wgauss = null;
            _error_code = _i_ser_gkqgenerategaussjacobi(&_s_errormsg, &_d_n, &_d_alpha, &_d_beta, &_d_info, &_d_x, &_d_wkronrod, &_d_wgauss);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gkqgenerategaussjacobi' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    public static void gkqgenerategaussjacobi(int n, double alpha, double beta, out int info, out double[] x, out double[] wkronrod, out double[] wgauss)
    {
    _core_gkqgenerategaussjacobi( n,  alpha,  beta, out  info, out  x, out  wkronrod, out  wgauss, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gkqlegendrecalc(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_info = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_wkronrod, DT_REAL);
            wkronrod = null;
            x_vector_create_empty(ref _d_wgauss, DT_REAL);
            wgauss = null;
            _error_code = _i_ser_gkqlegendrecalc(&_s_errormsg, &_d_n, &_d_info, &_d_x, &_d_wkronrod, &_d_wgauss);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gkqlegendrecalc' call");
            }
            info = _d_info.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    public static void gkqlegendrecalc(int n, out int info, out double[] x, out double[] wkronrod, out double[] wgauss)
    {
    _core_gkqlegendrecalc( n, out  info, out  x, out  wkronrod, out  wgauss, alglibmode.serial);
    return;
    }
    private static unsafe void _core_gkqlegendretbl(int n, out double[] x, out double[] wkronrod, out double[] wgauss, out double eps, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        x_vector _d_wkronrod = new x_vector();
        x_vector _d_wgauss = new x_vector();
        double _d_eps = 0;
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_wkronrod, DT_REAL);
            wkronrod = null;
            x_vector_create_empty(ref _d_wgauss, DT_REAL);
            wgauss = null;
            _error_code = _i_ser_gkqlegendretbl(&_s_errormsg, &_d_n, &_d_x, &_d_wkronrod, &_d_wgauss, &_d_eps);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'gkqlegendretbl' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_wkronrod.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wkronrod, ref wkronrod);
            if( wkronrod == null )
                wkronrod = new double[0];
            if( _d_wgauss.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_wgauss, ref wgauss);
            if( wgauss == null )
                wgauss = new double[0];
            eps = _d_eps;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_wkronrod);
            x_vector_clear(ref _d_wgauss);
        }
        // This function returns no value.
    }
    public static void gkqlegendretbl(int n, out double[] x, out double[] wkronrod, out double[] wgauss, out double eps)
    {
    _core_gkqlegendretbl( n, out  x, out  wkronrod, out  wgauss, out  eps, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage autogk
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_autogkreport
    {
        public x_int terminationtype;
        public x_int nfev;
        public x_int nintervals;
    }

    public class autogkreport : alglibobject
    {
        public int terminationtype;
        public int nfev;
        public int nintervals;
        public override alglib.alglibobject make_copy()
        {
            autogkreport dst = new autogkreport();
            dst.terminationtype = terminationtype;
            dst.nfev = nfev;
            dst.nintervals = nintervals;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_autogkreport_init(ref x_autogkreport x)
    {
        x.terminationtype.longval = 0;
        x.nfev.longval = 0;
        x.nintervals.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_autogkreport_clear(ref x_autogkreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_autogkreport_init_from(ref x_autogkreport x, autogkreport v)
    {
        x.terminationtype.longval = v.terminationtype;
        x.nfev.longval = v.nfev;
        x.nintervals.longval = v.nintervals;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_autogkreport_to_record(ref x_autogkreport x, ref autogkreport v)
    {
        if( v==null )
            v = new autogkreport();
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.nintervals = x.nintervals.intval; // long is silently truncated to int
    }

    public unsafe class autogkstate : alglibobject
    {
        public void *ptr;
        public autogkstate(void *x)
        {
            ptr = x;
        }
        ~autogkstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new autogkstate(null);
            return new autogkstate(_i_x_obj_copy_autogkstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_autogkstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_autogkstate(void *x);
    private static _d_x_obj_copy_autogkstate _i_x_obj_copy_autogkstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_autogkstate(void *x);
    private static _d_x_obj_free_autogkstate _i_x_obj_free_autogkstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_set_needf(void *x, byte *dst);
    private static _d_x_autogkstate_get_needf _i_x_autogkstate_get_needf = null;
    private static _d_x_autogkstate_set_needf _i_x_autogkstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_get_x(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_set_x(void *x, double *dst);
    private static _d_x_autogkstate_get_x _i_x_autogkstate_get_x = null;
    private static _d_x_autogkstate_set_x _i_x_autogkstate_set_x = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_get_xminusa(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_set_xminusa(void *x, double *dst);
    private static _d_x_autogkstate_get_xminusa _i_x_autogkstate_get_xminusa = null;
    private static _d_x_autogkstate_set_xminusa _i_x_autogkstate_set_xminusa = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_get_bminusx(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_set_bminusx(void *x, double *dst);
    private static _d_x_autogkstate_get_bminusx _i_x_autogkstate_get_bminusx = null;
    private static _d_x_autogkstate_set_bminusx _i_x_autogkstate_set_bminusx = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_autogkstate_set_f(void *x, double *dst);
    private static _d_x_autogkstate_get_f _i_x_autogkstate_get_f = null;
    private static _d_x_autogkstate_set_f _i_x_autogkstate_set_f = null;
    private static unsafe void _core_autogksmooth(double a, double b, out autogkstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_autogksmooth(&_s_errormsg, &_d_a, &_d_b, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'autogksmooth' call");
            }
            state = new autogkstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void autogksmooth(double a, double b, out autogkstate state)
    {
    _core_autogksmooth( a,  b, out  state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_autogksmoothw(double a, double b, double xwidth, out autogkstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        double _d_xwidth = xwidth;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_autogksmoothw(&_s_errormsg, &_d_a, &_d_b, &_d_xwidth, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'autogksmoothw' call");
            }
            state = new autogkstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void autogksmoothw(double a, double b, double xwidth, out autogkstate state)
    {
    _core_autogksmoothw( a,  b,  xwidth, out  state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_autogksingular(double a, double b, double alpha, double beta, out autogkstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        double _d_alpha = alpha;
        double _d_beta = beta;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_autogksingular(&_s_errormsg, &_d_a, &_d_b, &_d_alpha, &_d_beta, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'autogksingular' call");
            }
            state = new autogkstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_autogkstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void autogksingular(double a, double b, double alpha, double beta, out autogkstate state)
    {
    _core_autogksingular( a,  b,  alpha,  beta, out  state, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_autogkiteration(autogkstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_autogkiteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'autogkiteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool autogkiteration(autogkstate state)
    {
    bool result = _core_autogkiteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void autogkintegrate(autogkstate state, integrator1_func func, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        void *_state = state.ptr;
        double _xc_x = 0;
        double _xc_xminusa = 0;
        double _xc_bminusx = 0;
        double _xc_f = 0;
        byte   _xc_needf = 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'autogkintegrate()' (func is null)");
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_autogkiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during autogkiteration() call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
    
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_autogkstate_get_needf(_state, &_xc_needf);
            if( _xc_needf!=0 )
            {
                _i_x_autogkstate_get_x(_state, &_xc_x);
                _i_x_autogkstate_get_xminusa(_state, &_xc_xminusa);
                _i_x_autogkstate_get_bminusx(_state, &_xc_bminusx);
                func(_xc_x, _xc_xminusa, _xc_bminusx, ref _xc_f, obj);
                _i_x_autogkstate_set_f(_state, &_xc_f);
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'autogkintegrate' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_autogkresults(autogkstate state, out double v, out autogkreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_v = 0;
        x_autogkreport _d_rep = new x_autogkreport();
        
        // Pack, call, unpack
        try
        {
            x_autogkreport_init(ref _d_rep);
            _error_code = _i_ser_autogkresults(&_s_errormsg, &_d_state, &_d_v, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'autogkresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            v = _d_v;
            rep = null;
            x_autogkreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_autogkreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void autogkresults(autogkstate state, out double v, out autogkreport rep)
    {
    _core_autogkresults( state, out  v, out  rep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage idwint
    //
    

    public unsafe class idwinterpolant : alglibobject
    {
        public void *ptr;
        public idwinterpolant(void *x)
        {
            ptr = x;
        }
        ~idwinterpolant()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new idwinterpolant(null);
            return new idwinterpolant(_i_x_obj_copy_idwinterpolant(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_idwinterpolant(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_idwinterpolant(void *x);
    private static _d_x_obj_copy_idwinterpolant _i_x_obj_copy_idwinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_idwinterpolant(void *x);
    private static _d_x_obj_free_idwinterpolant _i_x_obj_free_idwinterpolant = null;
    private static unsafe double _core_idwcalc(idwinterpolant z, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_z = z.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_idwcalc(&_s_errormsg, &_d_result, &_d_z, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'idwcalc' call");
            }
            result = _d_result;
            ap.assert(z.ptr==_d_z, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        return result;
    }
    public static double idwcalc(idwinterpolant z, double[] x)
    {
    double result = _core_idwcalc( z,  x, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_idwbuildmodifiedshepard(double[,] xy, int n, int nx, int d, int nq, int nw, out idwinterpolant z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_nx = new x_int(nx);
        x_int _d_d = new x_int(d);
        x_int _d_nq = new x_int(nq);
        x_int _d_nw = new x_int(nw);
        void *_d_z = null;
        z = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_idwbuildmodifiedshepard(&_s_errormsg, &_d_xy, &_d_n, &_d_nx, &_d_d, &_d_nq, &_d_nw, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'idwbuildmodifiedshepard' call");
            }
            z = new idwinterpolant(_d_z);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_z!=null && z==null)
                _i_x_obj_free_idwinterpolant(_d_z); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void idwbuildmodifiedshepard(double[,] xy, int n, int nx, int d, int nq, int nw, out idwinterpolant z)
    {
    _core_idwbuildmodifiedshepard( xy,  n,  nx,  d,  nq,  nw, out  z, alglibmode.serial);
    return;
    }
    private static unsafe void _core_idwbuildmodifiedshepardr(double[,] xy, int n, int nx, double r, out idwinterpolant z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_nx = new x_int(nx);
        double _d_r = r;
        void *_d_z = null;
        z = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_idwbuildmodifiedshepardr(&_s_errormsg, &_d_xy, &_d_n, &_d_nx, &_d_r, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'idwbuildmodifiedshepardr' call");
            }
            z = new idwinterpolant(_d_z);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_z!=null && z==null)
                _i_x_obj_free_idwinterpolant(_d_z); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void idwbuildmodifiedshepardr(double[,] xy, int n, int nx, double r, out idwinterpolant z)
    {
    _core_idwbuildmodifiedshepardr( xy,  n,  nx,  r, out  z, alglibmode.serial);
    return;
    }
    private static unsafe void _core_idwbuildnoisy(double[,] xy, int n, int nx, int d, int nq, int nw, out idwinterpolant z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_nx = new x_int(nx);
        x_int _d_d = new x_int(d);
        x_int _d_nq = new x_int(nq);
        x_int _d_nw = new x_int(nw);
        void *_d_z = null;
        z = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_idwbuildnoisy(&_s_errormsg, &_d_xy, &_d_n, &_d_nx, &_d_d, &_d_nq, &_d_nw, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'idwbuildnoisy' call");
            }
            z = new idwinterpolant(_d_z);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_z!=null && z==null)
                _i_x_obj_free_idwinterpolant(_d_z); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void idwbuildnoisy(double[,] xy, int n, int nx, int d, int nq, int nw, out idwinterpolant z)
    {
    _core_idwbuildnoisy( xy,  n,  nx,  d,  nq,  nw, out  z, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage ratint
    //
    

    public unsafe class barycentricinterpolant : alglibobject
    {
        public void *ptr;
        public barycentricinterpolant(void *x)
        {
            ptr = x;
        }
        ~barycentricinterpolant()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new barycentricinterpolant(null);
            return new barycentricinterpolant(_i_x_obj_copy_barycentricinterpolant(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_barycentricinterpolant(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_barycentricinterpolant(void *x);
    private static _d_x_obj_copy_barycentricinterpolant _i_x_obj_copy_barycentricinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_barycentricinterpolant(void *x);
    private static _d_x_obj_free_barycentricinterpolant _i_x_obj_free_barycentricinterpolant = null;
    private static unsafe double _core_barycentriccalc(barycentricinterpolant b, double t, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_b = b.ptr;
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_barycentriccalc(&_s_errormsg, &_d_result, &_d_b, &_d_t);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentriccalc' call");
            }
            result = _d_result;
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double barycentriccalc(barycentricinterpolant b, double t)
    {
    double result = _core_barycentriccalc( b,  t, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_barycentricdiff1(barycentricinterpolant b, double t, out double f, out double df, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        double _d_t = t;
        double _d_f = 0;
        double _d_df = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_barycentricdiff1(&_s_errormsg, &_d_b, &_d_t, &_d_f, &_d_df);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentricdiff1' call");
            }
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
            f = _d_f;
            df = _d_df;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void barycentricdiff1(barycentricinterpolant b, double t, out double f, out double df)
    {
    _core_barycentricdiff1( b,  t, out  f, out  df, alglibmode.serial);
    return;
    }
    private static unsafe void _core_barycentricdiff2(barycentricinterpolant b, double t, out double f, out double df, out double d2f, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        double _d_t = t;
        double _d_f = 0;
        double _d_df = 0;
        double _d_d2f = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_barycentricdiff2(&_s_errormsg, &_d_b, &_d_t, &_d_f, &_d_df, &_d_d2f);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentricdiff2' call");
            }
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
            f = _d_f;
            df = _d_df;
            d2f = _d_d2f;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void barycentricdiff2(barycentricinterpolant b, double t, out double f, out double df, out double d2f)
    {
    _core_barycentricdiff2( b,  t, out  f, out  df, out  d2f, alglibmode.serial);
    return;
    }
    private static unsafe void _core_barycentriclintransx(barycentricinterpolant b, double ca, double cb, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        double _d_ca = ca;
        double _d_cb = cb;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_barycentriclintransx(&_s_errormsg, &_d_b, &_d_ca, &_d_cb);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentriclintransx' call");
            }
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void barycentriclintransx(barycentricinterpolant b, double ca, double cb)
    {
    _core_barycentriclintransx( b,  ca,  cb, alglibmode.serial);
    return;
    }
    private static unsafe void _core_barycentriclintransy(barycentricinterpolant b, double ca, double cb, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        double _d_ca = ca;
        double _d_cb = cb;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_barycentriclintransy(&_s_errormsg, &_d_b, &_d_ca, &_d_cb);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentriclintransy' call");
            }
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void barycentriclintransy(barycentricinterpolant b, double ca, double cb)
    {
    _core_barycentriclintransy( b,  ca,  cb, alglibmode.serial);
    return;
    }
    private static unsafe void _core_barycentricunpack(barycentricinterpolant b, out int n, out double[] x, out double[] y, out double[] w, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_b = b.ptr;
        x_int _d_n = new x_int();
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_vector_create_empty(ref _d_y, DT_REAL);
            y = null;
            x_vector_create_empty(ref _d_w, DT_REAL);
            w = null;
            _error_code = _i_ser_barycentricunpack(&_s_errormsg, &_d_b, &_d_n, &_d_x, &_d_y, &_d_w);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentricunpack' call");
            }
            ap.assert(b.ptr==_d_b, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
            if( _d_w.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_w, ref w);
            if( w == null )
                w = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
        }
        // This function returns no value.
    }
    public static void barycentricunpack(barycentricinterpolant b, out int n, out double[] x, out double[] y, out double[] w)
    {
    _core_barycentricunpack( b, out  n, out  x, out  y, out  w, alglibmode.serial);
    return;
    }
    private static unsafe void _core_barycentricbuildxyw(double[] x, double[] y, double[] w, int n, out barycentricinterpolant b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_b = null;
        b = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                _error_code = _i_ser_barycentricbuildxyw(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentricbuildxyw' call");
            }
            b = new barycentricinterpolant(_d_b);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            if( _d_b!=null && b==null)
                _i_x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void barycentricbuildxyw(double[] x, double[] y, double[] w, int n, out barycentricinterpolant b)
    {
    _core_barycentricbuildxyw( x,  y,  w,  n, out  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_barycentricbuildfloaterhormann(double[] x, double[] y, int n, int d, out barycentricinterpolant b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_d = new x_int(d);
        void *_d_b = null;
        b = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_barycentricbuildfloaterhormann(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_d, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentricbuildfloaterhormann' call");
            }
            b = new barycentricinterpolant(_d_b);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_b!=null && b==null)
                _i_x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void barycentricbuildfloaterhormann(double[] x, double[] y, int n, int d, out barycentricinterpolant b)
    {
    _core_barycentricbuildfloaterhormann( x,  y,  n,  d, out  b, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage polint
    //
    
    private static unsafe void _core_polynomialbar2cheb(barycentricinterpolant p, double a, double b, out double[] t, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_t = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_t, DT_REAL);
            t = null;
            _error_code = _i_ser_polynomialbar2cheb(&_s_errormsg, &_d_p, &_d_a, &_d_b, &_d_t);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialbar2cheb' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_t.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_t, ref t);
            if( t == null )
                t = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_t);
        }
        // This function returns no value.
    }
    public static void polynomialbar2cheb(barycentricinterpolant p, double a, double b, out double[] t)
    {
    _core_polynomialbar2cheb( p,  a,  b, out  t, alglibmode.serial);
    return;
    }
    private static unsafe void _core_polynomialcheb2bar(double[] t, int n, double a, double b, out barycentricinterpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_t = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_a = a;
        double _d_b = b;
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_t = t){
                x_vector_attach_to_array(ref _d_t, _fp_t, ap.len(t));
                _error_code = _i_ser_polynomialcheb2bar(&_s_errormsg, &_d_t, &_d_n, &_d_a, &_d_b, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialcheb2bar' call");
            }
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_t);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void polynomialcheb2bar(double[] t, int n, double a, double b, out barycentricinterpolant p)
    {
    _core_polynomialcheb2bar( t,  n,  a,  b, out  p, alglibmode.serial);
    return;
    }
    public static void polynomialcheb2bar(double[] t, double a, double b, out barycentricinterpolant p)
    {
    int n;
    
    
    n = ap.len(t);
    
    _core_polynomialcheb2bar( t,  n,  a,  b, out  p, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_polynomialbar2pow(barycentricinterpolant p, double c, double s, out double[] a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_c = c;
        double _d_s = s;
        x_vector _d_a = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_a, DT_REAL);
            a = null;
            _error_code = _i_ser_polynomialbar2pow(&_s_errormsg, &_d_p, &_d_c, &_d_s, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialbar2pow' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void polynomialbar2pow(barycentricinterpolant p, double c, double s, out double[] a)
    {
    _core_polynomialbar2pow( p,  c,  s, out  a, alglibmode.serial);
    return;
    }
    public static void polynomialbar2pow(barycentricinterpolant p, out double[] a)
    {
    double c;
    double s;
    
    
    c = 0;
    s = 1;
    
    _core_polynomialbar2pow( p,  c,  s, out  a, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_polynomialpow2bar(double[] a, int n, double c, double s, out barycentricinterpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_c = c;
        double _d_s = s;
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                _error_code = _i_ser_polynomialpow2bar(&_s_errormsg, &_d_a, &_d_n, &_d_c, &_d_s, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialpow2bar' call");
            }
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_a);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void polynomialpow2bar(double[] a, int n, double c, double s, out barycentricinterpolant p)
    {
    _core_polynomialpow2bar( a,  n,  c,  s, out  p, alglibmode.serial);
    return;
    }
    public static void polynomialpow2bar(double[] a, out barycentricinterpolant p)
    {
    int n;
    double c;
    double s;
    
    
    n = ap.len(a);
    c = 0;
    s = 1;
    
    _core_polynomialpow2bar( a,  n,  c,  s, out  p, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_polynomialbuild(double[] x, double[] y, int n, out barycentricinterpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_polynomialbuild(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialbuild' call");
            }
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void polynomialbuild(double[] x, double[] y, int n, out barycentricinterpolant p)
    {
    _core_polynomialbuild( x,  y,  n, out  p, alglibmode.serial);
    return;
    }
    public static void polynomialbuild(double[] x, double[] y, out barycentricinterpolant p)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'polynomialbuild': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_polynomialbuild( x,  y,  n, out  p, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_polynomialbuildeqdist(double a, double b, double[] y, int n, out barycentricinterpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_polynomialbuildeqdist(&_s_errormsg, &_d_a, &_d_b, &_d_y, &_d_n, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialbuildeqdist' call");
            }
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void polynomialbuildeqdist(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
    _core_polynomialbuildeqdist( a,  b,  y,  n, out  p, alglibmode.serial);
    return;
    }
    public static void polynomialbuildeqdist(double a, double b, double[] y, out barycentricinterpolant p)
    {
    int n;
    
    
    n = ap.len(y);
    
    _core_polynomialbuildeqdist( a,  b,  y,  n, out  p, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_polynomialbuildcheb1(double a, double b, double[] y, int n, out barycentricinterpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_polynomialbuildcheb1(&_s_errormsg, &_d_a, &_d_b, &_d_y, &_d_n, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialbuildcheb1' call");
            }
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void polynomialbuildcheb1(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
    _core_polynomialbuildcheb1( a,  b,  y,  n, out  p, alglibmode.serial);
    return;
    }
    public static void polynomialbuildcheb1(double a, double b, double[] y, out barycentricinterpolant p)
    {
    int n;
    
    
    n = ap.len(y);
    
    _core_polynomialbuildcheb1( a,  b,  y,  n, out  p, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_polynomialbuildcheb2(double a, double b, double[] y, int n, out barycentricinterpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_polynomialbuildcheb2(&_s_errormsg, &_d_a, &_d_b, &_d_y, &_d_n, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialbuildcheb2' call");
            }
            p = new barycentricinterpolant(_d_p);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void polynomialbuildcheb2(double a, double b, double[] y, int n, out barycentricinterpolant p)
    {
    _core_polynomialbuildcheb2( a,  b,  y,  n, out  p, alglibmode.serial);
    return;
    }
    public static void polynomialbuildcheb2(double a, double b, double[] y, out barycentricinterpolant p)
    {
    int n;
    
    
    n = ap.len(y);
    
    _core_polynomialbuildcheb2( a,  b,  y,  n, out  p, alglibmode.serial);
    
    return;
    }
    private static unsafe double _core_polynomialcalceqdist(double a, double b, double[] f, int n, double t, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_f = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_ser_polynomialcalceqdist(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_f, &_d_n, &_d_t);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialcalceqdist' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        return result;
    }
    public static double polynomialcalceqdist(double a, double b, double[] f, int n, double t)
    {
    double result = _core_polynomialcalceqdist( a,  b,  f,  n,  t, alglibmode.serial);
    return result;
    }
    public static double polynomialcalceqdist(double a, double b, double[] f, double t)
    {
    int n;
    
    
    n = ap.len(f);
    
    double result = _core_polynomialcalceqdist( a,  b,  f,  n,  t, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_polynomialcalccheb1(double a, double b, double[] f, int n, double t, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_f = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_ser_polynomialcalccheb1(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_f, &_d_n, &_d_t);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialcalccheb1' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        return result;
    }
    public static double polynomialcalccheb1(double a, double b, double[] f, int n, double t)
    {
    double result = _core_polynomialcalccheb1( a,  b,  f,  n,  t, alglibmode.serial);
    return result;
    }
    public static double polynomialcalccheb1(double a, double b, double[] f, double t)
    {
    int n;
    
    
    n = ap.len(f);
    
    double result = _core_polynomialcalccheb1( a,  b,  f,  n,  t, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_polynomialcalccheb2(double a, double b, double[] f, int n, double t, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        x_vector _d_f = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_ser_polynomialcalccheb2(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_f, &_d_n, &_d_t);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialcalccheb2' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        return result;
    }
    public static double polynomialcalccheb2(double a, double b, double[] f, int n, double t)
    {
    double result = _core_polynomialcalccheb2( a,  b,  f,  n,  t, alglibmode.serial);
    return result;
    }
    public static double polynomialcalccheb2(double a, double b, double[] f, double t)
    {
    int n;
    
    
    n = ap.len(f);
    
    double result = _core_polynomialcalccheb2( a,  b,  f,  n,  t, alglibmode.serial);
    
    return result;
    }
    
    
    //
    // Subpackage spline1d
    //
    

    public unsafe class spline1dinterpolant : alglibobject
    {
        public void *ptr;
        public spline1dinterpolant(void *x)
        {
            ptr = x;
        }
        ~spline1dinterpolant()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new spline1dinterpolant(null);
            return new spline1dinterpolant(_i_x_obj_copy_spline1dinterpolant(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_spline1dinterpolant(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_spline1dinterpolant(void *x);
    private static _d_x_obj_copy_spline1dinterpolant _i_x_obj_copy_spline1dinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_spline1dinterpolant(void *x);
    private static _d_x_obj_free_spline1dinterpolant _i_x_obj_free_spline1dinterpolant = null;
    private static unsafe void _core_spline1dbuildlinear(double[] x, double[] y, int n, out spline1dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_spline1dbuildlinear(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dbuildlinear' call");
            }
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline1dbuildlinear(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
    _core_spline1dbuildlinear( x,  y,  n, out  c, alglibmode.serial);
    return;
    }
    public static void spline1dbuildlinear(double[] x, double[] y, out spline1dinterpolant c)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dbuildlinear': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dbuildlinear( x,  y,  n, out  c, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dbuildcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out spline1dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_spline1dbuildcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dbuildcubic' call");
            }
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline1dbuildcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out spline1dinterpolant c)
    {
    _core_spline1dbuildcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  c, alglibmode.serial);
    return;
    }
    public static void spline1dbuildcubic(double[] x, double[] y, out spline1dinterpolant c)
    {
    int n;
    int boundltype;
    double boundl;
    int boundrtype;
    double boundr;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dbuildcubic': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    boundltype = 0;
    boundl = 0;
    boundrtype = 0;
    boundr = 0;
    
    _core_spline1dbuildcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  c, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dgriddiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_d = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                _error_code = _i_ser_spline1dgriddiffcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_d);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dgriddiffcubic' call");
            }
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_d);
        }
        // This function returns no value.
    }
    public static void spline1dgriddiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d)
    {
    _core_spline1dgriddiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d, alglibmode.serial);
    return;
    }
    public static void spline1dgriddiffcubic(double[] x, double[] y, out double[] d)
    {
    int n;
    int boundltype;
    double boundl;
    int boundrtype;
    double boundr;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dgriddiffcubic': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    boundltype = 0;
    boundl = 0;
    boundrtype = 0;
    boundr = 0;
    
    _core_spline1dgriddiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dgriddiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d1, out double[] d2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_d1 = new x_vector();
        x_vector _d_d2 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_create_empty(ref _d_d1, DT_REAL);
                d1 = null;
                x_vector_create_empty(ref _d_d2, DT_REAL);
                d2 = null;
                _error_code = _i_ser_spline1dgriddiff2cubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_d1, &_d_d2);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dgriddiff2cubic' call");
            }
            if( _d_d1.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d1, ref d1);
            if( d1 == null )
                d1 = new double[0];
            if( _d_d2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2, ref d2);
            if( d2 == null )
                d2 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_d1);
            x_vector_clear(ref _d_d2);
        }
        // This function returns no value.
    }
    public static void spline1dgriddiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, out double[] d1, out double[] d2)
    {
    _core_spline1dgriddiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d1, out  d2, alglibmode.serial);
    return;
    }
    public static void spline1dgriddiff2cubic(double[] x, double[] y, out double[] d1, out double[] d2)
    {
    int n;
    int boundltype;
    double boundl;
    int boundrtype;
    double boundr;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dgriddiff2cubic': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    boundltype = 0;
    boundl = 0;
    boundrtype = 0;
    boundr = 0;
    
    _core_spline1dgriddiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr, out  d1, out  d2, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dconvcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_x2 = new x_vector();
        x_int _d_n2 = new x_int(n2);
        x_vector _d_y2 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_x2 = x2){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_x2, _fp_x2, ap.len(x2));
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                _error_code = _i_ser_spline1dconvcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_x2, &_d_n2, &_d_y2);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dconvcubic' call");
            }
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
        }
        // This function returns no value.
    }
    public static void spline1dconvcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2)
    {
    _core_spline1dconvcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, alglibmode.serial);
    return;
    }
    public static void spline1dconvcubic(double[] x, double[] y, double[] x2, out double[] y2)
    {
    int n;
    int boundltype;
    double boundl;
    int boundrtype;
    double boundr;
    int n2;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dconvcubic': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    boundltype = 0;
    boundl = 0;
    boundrtype = 0;
    boundr = 0;
    n2 = ap.len(x2);
    
    _core_spline1dconvcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dconvdiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_x2 = new x_vector();
        x_int _d_n2 = new x_int(n2);
        x_vector _d_y2 = new x_vector();
        x_vector _d_d2 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_x2 = x2){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_x2, _fp_x2, ap.len(x2));
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                x_vector_create_empty(ref _d_d2, DT_REAL);
                d2 = null;
                _error_code = _i_ser_spline1dconvdiffcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_x2, &_d_n2, &_d_y2, &_d_d2);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dconvdiffcubic' call");
            }
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
            if( _d_d2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2, ref d2);
            if( d2 == null )
                d2 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
            x_vector_clear(ref _d_d2);
        }
        // This function returns no value.
    }
    public static void spline1dconvdiffcubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2)
    {
    _core_spline1dconvdiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, alglibmode.serial);
    return;
    }
    public static void spline1dconvdiffcubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2)
    {
    int n;
    int boundltype;
    double boundl;
    int boundrtype;
    double boundr;
    int n2;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dconvdiffcubic': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    boundltype = 0;
    boundl = 0;
    boundrtype = 0;
    boundr = 0;
    n2 = ap.len(x2);
    
    _core_spline1dconvdiffcubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dconvdiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, out double[] dd2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundltype = new x_int(boundltype);
        double _d_boundl = boundl;
        x_int _d_boundrtype = new x_int(boundrtype);
        double _d_boundr = boundr;
        x_vector _d_x2 = new x_vector();
        x_int _d_n2 = new x_int(n2);
        x_vector _d_y2 = new x_vector();
        x_vector _d_d2 = new x_vector();
        x_vector _d_dd2 = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_x2 = x2){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_x2, _fp_x2, ap.len(x2));
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                x_vector_create_empty(ref _d_d2, DT_REAL);
                d2 = null;
                x_vector_create_empty(ref _d_dd2, DT_REAL);
                dd2 = null;
                _error_code = _i_ser_spline1dconvdiff2cubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundltype, &_d_boundl, &_d_boundrtype, &_d_boundr, &_d_x2, &_d_n2, &_d_y2, &_d_d2, &_d_dd2);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dconvdiff2cubic' call");
            }
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
            if( _d_d2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d2, ref d2);
            if( d2 == null )
                d2 = new double[0];
            if( _d_dd2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_dd2, ref dd2);
            if( dd2 == null )
                dd2 = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
            x_vector_clear(ref _d_d2);
            x_vector_clear(ref _d_dd2);
        }
        // This function returns no value.
    }
    public static void spline1dconvdiff2cubic(double[] x, double[] y, int n, int boundltype, double boundl, int boundrtype, double boundr, double[] x2, int n2, out double[] y2, out double[] d2, out double[] dd2)
    {
    _core_spline1dconvdiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, out  dd2, alglibmode.serial);
    return;
    }
    public static void spline1dconvdiff2cubic(double[] x, double[] y, double[] x2, out double[] y2, out double[] d2, out double[] dd2)
    {
    int n;
    int boundltype;
    double boundl;
    int boundrtype;
    double boundr;
    int n2;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dconvdiff2cubic': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    boundltype = 0;
    boundl = 0;
    boundrtype = 0;
    boundr = 0;
    n2 = ap.len(x2);
    
    _core_spline1dconvdiff2cubic( x,  y,  n,  boundltype,  boundl,  boundrtype,  boundr,  x2,  n2, out  y2, out  d2, out  dd2, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dbuildcatmullrom(double[] x, double[] y, int n, int boundtype, double tension, out spline1dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_boundtype = new x_int(boundtype);
        double _d_tension = tension;
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_spline1dbuildcatmullrom(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_boundtype, &_d_tension, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dbuildcatmullrom' call");
            }
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline1dbuildcatmullrom(double[] x, double[] y, int n, int boundtype, double tension, out spline1dinterpolant c)
    {
    _core_spline1dbuildcatmullrom( x,  y,  n,  boundtype,  tension, out  c, alglibmode.serial);
    return;
    }
    public static void spline1dbuildcatmullrom(double[] x, double[] y, out spline1dinterpolant c)
    {
    int n;
    int boundtype;
    double tension;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dbuildcatmullrom': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    boundtype = 0;
    tension = 0;
    
    _core_spline1dbuildcatmullrom( x,  y,  n,  boundtype,  tension, out  c, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dbuildhermite(double[] x, double[] y, double[] d, int n, out spline1dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_d = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_d = d){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_d, _fp_d, ap.len(d));
                _error_code = _i_ser_spline1dbuildhermite(&_s_errormsg, &_d_x, &_d_y, &_d_d, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dbuildhermite' call");
            }
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_d);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, int n, out spline1dinterpolant c)
    {
    _core_spline1dbuildhermite( x,  y,  d,  n, out  c, alglibmode.serial);
    return;
    }
    public static void spline1dbuildhermite(double[] x, double[] y, double[] d, out spline1dinterpolant c)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(d)))
        throw new alglibexception("Error while calling 'spline1dbuildhermite': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dbuildhermite( x,  y,  d,  n, out  c, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_spline1dbuildakima(double[] x, double[] y, int n, out spline1dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_spline1dbuildakima(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dbuildakima' call");
            }
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline1dbuildakima(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
    _core_spline1dbuildakima( x,  y,  n, out  c, alglibmode.serial);
    return;
    }
    public static void spline1dbuildakima(double[] x, double[] y, out spline1dinterpolant c)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dbuildakima': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dbuildakima( x,  y,  n, out  c, alglibmode.serial);
    
    return;
    }
    private static unsafe double _core_spline1dcalc(spline1dinterpolant c, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline1dcalc(&_s_errormsg, &_d_result, &_d_c, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dcalc' call");
            }
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double spline1dcalc(spline1dinterpolant c, double x)
    {
    double result = _core_spline1dcalc( c,  x, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_spline1ddiff(spline1dinterpolant c, double x, out double s, out double ds, out double d2s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_s = 0;
        double _d_ds = 0;
        double _d_d2s = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline1ddiff(&_s_errormsg, &_d_c, &_d_x, &_d_s, &_d_ds, &_d_d2s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1ddiff' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            s = _d_s;
            ds = _d_ds;
            d2s = _d_d2s;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spline1ddiff(spline1dinterpolant c, double x, out double s, out double ds, out double d2s)
    {
    _core_spline1ddiff( c,  x, out  s, out  ds, out  d2s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline1dunpack(spline1dinterpolant c, out int n, out double[,] tbl, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        x_int _d_n = new x_int();
        x_matrix _d_tbl = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_tbl, DT_REAL);
            tbl = null;
            _error_code = _i_ser_spline1dunpack(&_s_errormsg, &_d_c, &_d_n, &_d_tbl);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dunpack' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            if( _d_tbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_tbl, ref tbl);
            if( tbl == null )
                tbl = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_tbl);
        }
        // This function returns no value.
    }
    public static void spline1dunpack(spline1dinterpolant c, out int n, out double[,] tbl)
    {
    _core_spline1dunpack( c, out  n, out  tbl, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline1dlintransx(spline1dinterpolant c, double a, double b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline1dlintransx(&_s_errormsg, &_d_c, &_d_a, &_d_b);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dlintransx' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spline1dlintransx(spline1dinterpolant c, double a, double b)
    {
    _core_spline1dlintransx( c,  a,  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline1dlintransy(spline1dinterpolant c, double a, double b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline1dlintransy(&_s_errormsg, &_d_c, &_d_a, &_d_b);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dlintransy' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spline1dlintransy(spline1dinterpolant c, double a, double b)
    {
    _core_spline1dlintransy( c,  a,  b, alglibmode.serial);
    return;
    }
    private static unsafe double _core_spline1dintegrate(spline1dinterpolant c, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline1dintegrate(&_s_errormsg, &_d_result, &_d_c, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dintegrate' call");
            }
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double spline1dintegrate(spline1dinterpolant c, double x)
    {
    double result = _core_spline1dintegrate( c,  x, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_spline1dbuildmonotone(double[] x, double[] y, int n, out spline1dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_spline1dbuildmonotone(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dbuildmonotone' call");
            }
            c = new spline1dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline1dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline1dbuildmonotone(double[] x, double[] y, int n, out spline1dinterpolant c)
    {
    _core_spline1dbuildmonotone( x,  y,  n, out  c, alglibmode.serial);
    return;
    }
    public static void spline1dbuildmonotone(double[] x, double[] y, out spline1dinterpolant c)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dbuildmonotone': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dbuildmonotone( x,  y,  n, out  c, alglibmode.serial);
    
    return;
    }
    
    
    //
    // Subpackage normestimator
    //
    

    public unsafe class normestimatorstate : alglibobject
    {
        public void *ptr;
        public normestimatorstate(void *x)
        {
            ptr = x;
        }
        ~normestimatorstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new normestimatorstate(null);
            return new normestimatorstate(_i_x_obj_copy_normestimatorstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_normestimatorstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_normestimatorstate(void *x);
    private static _d_x_obj_copy_normestimatorstate _i_x_obj_copy_normestimatorstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_normestimatorstate(void *x);
    private static _d_x_obj_free_normestimatorstate _i_x_obj_free_normestimatorstate = null;
    private static unsafe void _core_normestimatorcreate(int m, int n, int nstart, int nits, out normestimatorstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        x_int _d_nstart = new x_int(nstart);
        x_int _d_nits = new x_int(nits);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_normestimatorcreate(&_s_errormsg, &_d_m, &_d_n, &_d_nstart, &_d_nits, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'normestimatorcreate' call");
            }
            state = new normestimatorstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_normestimatorstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void normestimatorcreate(int m, int n, int nstart, int nits, out normestimatorstate state)
    {
    _core_normestimatorcreate( m,  n,  nstart,  nits, out  state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_normestimatorsetseed(normestimatorstate state, int seedval, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_seedval = new x_int(seedval);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_normestimatorsetseed(&_s_errormsg, &_d_state, &_d_seedval);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'normestimatorsetseed' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void normestimatorsetseed(normestimatorstate state, int seedval)
    {
    _core_normestimatorsetseed( state,  seedval, alglibmode.serial);
    return;
    }
    private static unsafe void _core_normestimatorestimatesparse(normestimatorstate state, sparsematrix a, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_normestimatorestimatesparse(&_s_errormsg, &_d_state, &_d_a);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'normestimatorestimatesparse' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void normestimatorestimatesparse(normestimatorstate state, sparsematrix a)
    {
    _core_normestimatorestimatesparse( state,  a, alglibmode.serial);
    return;
    }
    private static unsafe void _core_normestimatorresults(normestimatorstate state, out double nrm, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_nrm = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_normestimatorresults(&_s_errormsg, &_d_state, &_d_nrm);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'normestimatorresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            nrm = _d_nrm;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void normestimatorresults(normestimatorstate state, out double nrm)
    {
    _core_normestimatorresults( state, out  nrm, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage qqpsolver
    //
    
    
    
    //
    // Subpackage qpbleicsolver
    //
    
    
    
    //
    // Subpackage qpcholeskysolver
    //
    
    
    
    //
    // Subpackage minqp
    //
    

    public unsafe class minqpstate : alglibobject
    {
        public void *ptr;
        public minqpstate(void *x)
        {
            ptr = x;
        }
        ~minqpstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new minqpstate(null);
            return new minqpstate(_i_x_obj_copy_minqpstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_minqpstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minqpstate(void *x);
    private static _d_x_obj_copy_minqpstate _i_x_obj_copy_minqpstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_minqpstate(void *x);
    private static _d_x_obj_free_minqpstate _i_x_obj_free_minqpstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minqpreport
    {
        public x_int inneriterationscount;
        public x_int outeriterationscount;
        public x_int nmv;
        public x_int ncholesky;
        public x_int terminationtype;
    }

    public class minqpreport : alglibobject
    {
        public int inneriterationscount;
        public int outeriterationscount;
        public int nmv;
        public int ncholesky;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            minqpreport dst = new minqpreport();
            dst.inneriterationscount = inneriterationscount;
            dst.outeriterationscount = outeriterationscount;
            dst.nmv = nmv;
            dst.ncholesky = ncholesky;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minqpreport_init(ref x_minqpreport x)
    {
        x.inneriterationscount.longval = 0;
        x.outeriterationscount.longval = 0;
        x.nmv.longval = 0;
        x.ncholesky.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minqpreport_clear(ref x_minqpreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minqpreport_init_from(ref x_minqpreport x, minqpreport v)
    {
        x.inneriterationscount.longval = v.inneriterationscount;
        x.outeriterationscount.longval = v.outeriterationscount;
        x.nmv.longval = v.nmv;
        x.ncholesky.longval = v.ncholesky;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minqpreport_to_record(ref x_minqpreport x, ref minqpreport v)
    {
        if( v==null )
            v = new minqpreport();
        v.inneriterationscount = x.inneriterationscount.intval; // long is silently truncated to int
        v.outeriterationscount = x.outeriterationscount.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.ncholesky = x.ncholesky.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    private static unsafe void _core_minqpcreate(int n, out minqpstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minqpcreate(&_s_errormsg, &_d_n, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpcreate' call");
            }
            state = new minqpstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_minqpstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minqpcreate(int n, out minqpstate state)
    {
    _core_minqpcreate( n, out  state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetlinearterm(minqpstate state, double[] b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_ser_minqpsetlinearterm(&_s_errormsg, &_d_state, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetlinearterm' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void minqpsetlinearterm(minqpstate state, double[] b)
    {
    _core_minqpsetlinearterm( state,  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetquadraticterm(minqpstate state, double[,] a, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_a = new x_matrix();
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_minqpsetquadraticterm(&_s_errormsg, &_d_state, &_d_a, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetquadraticterm' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        // This function returns no value.
    }
    public static void minqpsetquadraticterm(minqpstate state, double[,] a, bool isupper)
    {
    _core_minqpsetquadraticterm( state,  a,  isupper, alglibmode.serial);
    return;
    }
    public static void minqpsetquadraticterm(minqpstate state, double[,] a)
    {
    bool isupper;
    
    if( !alglib.ap.issymmetric(a) )
        throw new alglibexception("'a' parameter is not symmetric matrix");
    
    isupper = false;
    
    _core_minqpsetquadraticterm( state,  a,  isupper, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minqpsetquadratictermsparse(minqpstate state, sparsematrix a, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minqpsetquadratictermsparse(&_s_errormsg, &_d_state, &_d_a, &_d_isupper);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetquadratictermsparse' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minqpsetquadratictermsparse(minqpstate state, sparsematrix a, bool isupper)
    {
    _core_minqpsetquadratictermsparse( state,  a,  isupper, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetstartingpoint(minqpstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minqpsetstartingpoint(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetstartingpoint' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void minqpsetstartingpoint(minqpstate state, double[] x)
    {
    _core_minqpsetstartingpoint( state,  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetorigin(minqpstate state, double[] xorigin, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_xorigin = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xorigin = xorigin){
                x_vector_attach_to_array(ref _d_xorigin, _fp_xorigin, ap.len(xorigin));
                _error_code = _i_ser_minqpsetorigin(&_s_errormsg, &_d_state, &_d_xorigin);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetorigin' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_xorigin);
        }
        // This function returns no value.
    }
    public static void minqpsetorigin(minqpstate state, double[] xorigin)
    {
    _core_minqpsetorigin( state,  xorigin, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetscale(minqpstate state, double[] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_ser_minqpsetscale(&_s_errormsg, &_d_state, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    public static void minqpsetscale(minqpstate state, double[] s)
    {
    _core_minqpsetscale( state,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetalgocholesky(minqpstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minqpsetalgocholesky(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetalgocholesky' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minqpsetalgocholesky(minqpstate state)
    {
    _core_minqpsetalgocholesky( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetalgobleic(minqpstate state, double epsg, double epsf, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minqpsetalgobleic(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetalgobleic' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minqpsetalgobleic(minqpstate state, double epsg, double epsf, double epsx, int maxits)
    {
    _core_minqpsetalgobleic( state,  epsg,  epsf,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetalgoquickqp(minqpstate state, double epsg, double epsf, double epsx, int maxouterits, bool usenewton, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxouterits = new x_int(maxouterits);
        byte _d_usenewton = (byte)(usenewton ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minqpsetalgoquickqp(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxouterits, &_d_usenewton);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetalgoquickqp' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minqpsetalgoquickqp(minqpstate state, double epsg, double epsf, double epsx, int maxouterits, bool usenewton)
    {
    _core_minqpsetalgoquickqp( state,  epsg,  epsf,  epsx,  maxouterits,  usenewton, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetbc(minqpstate state, double[] bndl, double[] bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_ser_minqpsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetbc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    public static void minqpsetbc(minqpstate state, double[] bndl, double[] bndu)
    {
    _core_minqpsetbc( state,  bndl,  bndu, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpsetlc(minqpstate state, double[,] c, int[] ct, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_ser_minqpsetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpsetlc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    public static void minqpsetlc(minqpstate state, double[,] c, int[] ct, int k)
    {
    _core_minqpsetlc( state,  c,  ct,  k, alglibmode.serial);
    return;
    }
    public static void minqpsetlc(minqpstate state, double[,] c, int[] ct)
    {
    int k;
    
    if( (ap.rows(c)!=ap.len(ct)))
        throw new alglibexception("Error while calling 'minqpsetlc': looks like one of arguments has wrong size");
    
    k = ap.rows(c);
    
    _core_minqpsetlc( state,  c,  ct,  k, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minqpoptimize(minqpstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minqpoptimize(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpoptimize' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minqpoptimize(minqpstate state)
    {
    _core_minqpoptimize( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpresults(minqpstate state, out double[] x, out minqpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minqpreport _d_rep = new x_minqpreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minqpreport_init(ref _d_rep);
            _error_code = _i_ser_minqpresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minqpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minqpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minqpresults(minqpstate state, out double[] x, out minqpreport rep)
    {
    _core_minqpresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minqpresultsbuf(minqpstate state, ref double[] x, minqpreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minqpreport _d_rep = new x_minqpreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minqpreport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_minqpresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minqpresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minqpreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minqpreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minqpresultsbuf(minqpstate state, ref double[] x, minqpreport rep)
    {
    _core_minqpresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage minlm
    //
    

    public unsafe class minlmstate : alglibobject
    {
        public void *ptr;
        public minlmstate(void *x)
        {
            ptr = x;
        }
        ~minlmstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new minlmstate(null);
            return new minlmstate(_i_x_obj_copy_minlmstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_minlmstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minlmstate(void *x);
    private static _d_x_obj_copy_minlmstate _i_x_obj_copy_minlmstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_minlmstate(void *x);
    private static _d_x_obj_free_minlmstate _i_x_obj_free_minlmstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_set_needf(void *x, byte *dst);
    private static _d_x_minlmstate_get_needf _i_x_minlmstate_get_needf = null;
    private static _d_x_minlmstate_set_needf _i_x_minlmstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_set_needfg(void *x, byte *dst);
    private static _d_x_minlmstate_get_needfg _i_x_minlmstate_get_needfg = null;
    private static _d_x_minlmstate_set_needfg _i_x_minlmstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_needfgh(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_set_needfgh(void *x, byte *dst);
    private static _d_x_minlmstate_get_needfgh _i_x_minlmstate_get_needfgh = null;
    private static _d_x_minlmstate_set_needfgh _i_x_minlmstate_set_needfgh = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_needfi(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_set_needfi(void *x, byte *dst);
    private static _d_x_minlmstate_get_needfi _i_x_minlmstate_get_needfi = null;
    private static _d_x_minlmstate_set_needfi _i_x_minlmstate_set_needfi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_needfij(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_set_needfij(void *x, byte *dst);
    private static _d_x_minlmstate_get_needfij _i_x_minlmstate_get_needfij = null;
    private static _d_x_minlmstate_set_needfij _i_x_minlmstate_set_needfij = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minlmstate_get_xupdated _i_x_minlmstate_get_xupdated = null;
    private static _d_x_minlmstate_set_xupdated _i_x_minlmstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_set_f(void *x, double *dst);
    private static _d_x_minlmstate_get_f _i_x_minlmstate_get_f = null;
    private static _d_x_minlmstate_set_f _i_x_minlmstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_fi(void *x, x_vector *dst);
    private static _d_x_minlmstate_get_fi _i_x_minlmstate_get_fi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_g(void *x, x_vector *dst);
    private static _d_x_minlmstate_get_g _i_x_minlmstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_h(void *x, x_matrix *dst);
    private static _d_x_minlmstate_get_h _i_x_minlmstate_get_h = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_j(void *x, x_matrix *dst);
    private static _d_x_minlmstate_get_j _i_x_minlmstate_get_j = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minlmstate_get_x(void *x, x_vector *dst);
    private static _d_x_minlmstate_get_x _i_x_minlmstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minlmreport
    {
        public x_int iterationscount;
        public x_int terminationtype;
        public x_int funcidx;
        public x_int varidx;
        public x_int nfunc;
        public x_int njac;
        public x_int ngrad;
        public x_int nhess;
        public x_int ncholesky;
    }

    public class minlmreport : alglibobject
    {
        public int iterationscount;
        public int terminationtype;
        public int funcidx;
        public int varidx;
        public int nfunc;
        public int njac;
        public int ngrad;
        public int nhess;
        public int ncholesky;
        public override alglib.alglibobject make_copy()
        {
            minlmreport dst = new minlmreport();
            dst.iterationscount = iterationscount;
            dst.terminationtype = terminationtype;
            dst.funcidx = funcidx;
            dst.varidx = varidx;
            dst.nfunc = nfunc;
            dst.njac = njac;
            dst.ngrad = ngrad;
            dst.nhess = nhess;
            dst.ncholesky = ncholesky;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minlmreport_init(ref x_minlmreport x)
    {
        x.iterationscount.longval = 0;
        x.terminationtype.longval = 0;
        x.funcidx.longval = 0;
        x.varidx.longval = 0;
        x.nfunc.longval = 0;
        x.njac.longval = 0;
        x.ngrad.longval = 0;
        x.nhess.longval = 0;
        x.ncholesky.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minlmreport_clear(ref x_minlmreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minlmreport_init_from(ref x_minlmreport x, minlmreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.terminationtype.longval = v.terminationtype;
        x.funcidx.longval = v.funcidx;
        x.varidx.longval = v.varidx;
        x.nfunc.longval = v.nfunc;
        x.njac.longval = v.njac;
        x.ngrad.longval = v.ngrad;
        x.nhess.longval = v.nhess;
        x.ncholesky.longval = v.ncholesky;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minlmreport_to_record(ref x_minlmreport x, ref minlmreport v)
    {
        if( v==null )
            v = new minlmreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.funcidx = x.funcidx.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.nfunc = x.nfunc.intval; // long is silently truncated to int
        v.njac = x.njac.intval; // long is silently truncated to int
        v.ngrad = x.ngrad.intval; // long is silently truncated to int
        v.nhess = x.nhess.intval; // long is silently truncated to int
        v.ncholesky = x.ncholesky.intval; // long is silently truncated to int
    }
    private static unsafe void _core_minlmcreatevj(int n, int m, double[] x, out minlmstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlmcreatevj(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmcreatevj' call");
            }
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minlmcreatevj(int n, int m, double[] x, out minlmstate state)
    {
    _core_minlmcreatevj( n,  m,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minlmcreatevj(int m, double[] x, out minlmstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minlmcreatevj( n,  m,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minlmcreatev(int n, int m, double[] x, double diffstep, out minlmstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlmcreatev(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_diffstep, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmcreatev' call");
            }
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minlmcreatev(int n, int m, double[] x, double diffstep, out minlmstate state)
    {
    _core_minlmcreatev( n,  m,  x,  diffstep, out  state, alglibmode.serial);
    return;
    }
    public static void minlmcreatev(int m, double[] x, double diffstep, out minlmstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minlmcreatev( n,  m,  x,  diffstep, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minlmcreatefgh(int n, double[] x, out minlmstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlmcreatefgh(&_s_errormsg, &_d_n, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmcreatefgh' call");
            }
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minlmcreatefgh(int n, double[] x, out minlmstate state)
    {
    _core_minlmcreatefgh( n,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minlmcreatefgh(double[] x, out minlmstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minlmcreatefgh( n,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minlmsetcond(minlmstate state, double epsg, double epsf, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlmsetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmsetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlmsetcond(minlmstate state, double epsg, double epsf, double epsx, int maxits)
    {
    _core_minlmsetcond( state,  epsg,  epsf,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmsetxrep(minlmstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlmsetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmsetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlmsetxrep(minlmstate state, bool needxrep)
    {
    _core_minlmsetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmsetstpmax(minlmstate state, double stpmax, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlmsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmsetstpmax' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlmsetstpmax(minlmstate state, double stpmax)
    {
    _core_minlmsetstpmax( state,  stpmax, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmsetscale(minlmstate state, double[] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_ser_minlmsetscale(&_s_errormsg, &_d_state, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmsetscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    public static void minlmsetscale(minlmstate state, double[] s)
    {
    _core_minlmsetscale( state,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmsetbc(minlmstate state, double[] bndl, double[] bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_ser_minlmsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmsetbc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    public static void minlmsetbc(minlmstate state, double[] bndl, double[] bndu)
    {
    _core_minlmsetbc( state,  bndl,  bndu, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmsetacctype(minlmstate state, int acctype, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_acctype = new x_int(acctype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlmsetacctype(&_s_errormsg, &_d_state, &_d_acctype);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmsetacctype' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlmsetacctype(minlmstate state, int acctype)
    {
    _core_minlmsetacctype( state,  acctype, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_minlmiteration(minlmstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlmiteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmiteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool minlmiteration(minlmstate state)
    {
    bool result = _core_minlmiteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        byte _xc_needfi= 0;
    
        //
        // Check correctness of delegates
        //
        if( fvec==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (fvec is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minlmiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minlmiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needfi(_state, &_xc_needfi);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfi!=0 )
            {
                fvec(_cs_arg, _cs_fi, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_fvec  fvec, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needfi= 0;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( fvec==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (fvec is null)");
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        _i_x_minlmstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minlmiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minlmiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needfi(_state, &_xc_needfi);
            _i_x_minlmstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfi!=0 )
            {
                fvec(_cs_arg, _cs_fi, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                continue;
            }
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_grad grad, ndimensional_hess hess, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        x_matrix _xc_h = new x_matrix();
        double[,] _cs_h = null;
        byte _xc_needf= 0;
        byte _xc_needfg= 0;
        byte _xc_needfgh= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (grad is null)");
        if( hess==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (hess is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        x_matrix_create_empty(ref _xc_h, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_g(_state, &_xc_g);
        _i_x_minlmstate_get_h(_state, &_xc_h);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
        _cs_h = new double[_xc_h.rows,_xc_h.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minlmiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minlmiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needf(_state, &_xc_needf);
            _i_x_minlmstate_get_needfg(_state, &_xc_needfg);
            _i_x_minlmstate_get_needfgh(_state, &_xc_needfgh);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_needfgh!=0 )
            {
                hess(_cs_arg, ref _cs_f, _cs_g, _cs_h, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                x_matrix_from_array(ref _xc_h, _cs_h, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needf= 0;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (func is null)");
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        _i_x_minlmstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minlmiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minlmiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needf(_state, &_xc_needf);
            _i_x_minlmstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void minlmoptimize(minlmstate state, ndimensional_func func, ndimensional_grad grad, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needf= 0;
        byte _xc_needfg= 0;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (grad is null)");
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minlmoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minlmstate_get_x(_state, &_xc_arg);
        _i_x_minlmstate_get_g(_state, &_xc_g);
        _i_x_minlmstate_get_fi(_state, &_xc_fi);
        _i_x_minlmstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minlmiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minlmiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minlmstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minlmstate_get_needf(_state, &_xc_needf);
            _i_x_minlmstate_get_needfg(_state, &_xc_needfg);
            _i_x_minlmstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minlmstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minlmstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minlmoptimize' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_minlmresults(minlmstate state, out double[] x, out minlmreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlmreport _d_rep = new x_minlmreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minlmreport_init(ref _d_rep);
            _error_code = _i_ser_minlmresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minlmreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlmreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minlmresults(minlmstate state, out double[] x, out minlmreport rep)
    {
    _core_minlmresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmresultsbuf(minlmstate state, ref double[] x, minlmreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minlmreport _d_rep = new x_minlmreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minlmreport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_minlmresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minlmreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minlmreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minlmresultsbuf(minlmstate state, ref double[] x, minlmreport rep)
    {
    _core_minlmresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmrestartfrom(minlmstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlmrestartfrom(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmrestartfrom' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void minlmrestartfrom(minlmstate state, double[] x)
    {
    _core_minlmrestartfrom( state,  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmrequesttermination(minlmstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlmrequesttermination(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmrequesttermination' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlmrequesttermination(minlmstate state)
    {
    _core_minlmrequesttermination( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlmcreatevgj(int n, int m, double[] x, out minlmstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlmcreatevgj(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmcreatevgj' call");
            }
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minlmcreatevgj(int n, int m, double[] x, out minlmstate state)
    {
    _core_minlmcreatevgj( n,  m,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minlmcreatevgj(int m, double[] x, out minlmstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minlmcreatevgj( n,  m,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minlmcreatefgj(int n, int m, double[] x, out minlmstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlmcreatefgj(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmcreatefgj' call");
            }
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minlmcreatefgj(int n, int m, double[] x, out minlmstate state)
    {
    _core_minlmcreatefgj( n,  m,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minlmcreatefgj(int m, double[] x, out minlmstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minlmcreatefgj( n,  m,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minlmcreatefj(int n, int m, double[] x, out minlmstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minlmcreatefj(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmcreatefj' call");
            }
            state = new minlmstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minlmstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minlmcreatefj(int n, int m, double[] x, out minlmstate state)
    {
    _core_minlmcreatefj( n,  m,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minlmcreatefj(int m, double[] x, out minlmstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minlmcreatefj( n,  m,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minlmsetgradientcheck(minlmstate state, double teststep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlmsetgradientcheck(&_s_errormsg, &_d_state, &_d_teststep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlmsetgradientcheck' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlmsetgradientcheck(minlmstate state, double teststep)
    {
    _core_minlmsetgradientcheck( state,  teststep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage lsfit
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_polynomialfitreport
    {
        public double taskrcond;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
    }

    public class polynomialfitreport : alglibobject
    {
        public double taskrcond;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public override alglib.alglibobject make_copy()
        {
            polynomialfitreport dst = new polynomialfitreport();
            dst.taskrcond = taskrcond;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.maxerror = maxerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_polynomialfitreport_init(ref x_polynomialfitreport x)
    {
        x.taskrcond = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.maxerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_polynomialfitreport_clear(ref x_polynomialfitreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_polynomialfitreport_init_from(ref x_polynomialfitreport x, polynomialfitreport v)
    {
        x.taskrcond = v.taskrcond;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.maxerror = v.maxerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_polynomialfitreport_to_record(ref x_polynomialfitreport x, ref polynomialfitreport v)
    {
        if( v==null )
            v = new polynomialfitreport();
        v.taskrcond = x.taskrcond;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.maxerror = x.maxerror;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_barycentricfitreport
    {
        public double taskrcond;
        public x_int dbest;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
    }

    public class barycentricfitreport : alglibobject
    {
        public double taskrcond;
        public int dbest;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public override alglib.alglibobject make_copy()
        {
            barycentricfitreport dst = new barycentricfitreport();
            dst.taskrcond = taskrcond;
            dst.dbest = dbest;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.maxerror = maxerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_barycentricfitreport_init(ref x_barycentricfitreport x)
    {
        x.taskrcond = 0;
        x.dbest.longval = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.maxerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_barycentricfitreport_clear(ref x_barycentricfitreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_barycentricfitreport_init_from(ref x_barycentricfitreport x, barycentricfitreport v)
    {
        x.taskrcond = v.taskrcond;
        x.dbest.longval = v.dbest;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.maxerror = v.maxerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_barycentricfitreport_to_record(ref x_barycentricfitreport x, ref barycentricfitreport v)
    {
        if( v==null )
            v = new barycentricfitreport();
        v.taskrcond = x.taskrcond;
        v.dbest = x.dbest.intval; // long is silently truncated to int
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.maxerror = x.maxerror;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_spline1dfitreport
    {
        public double taskrcond;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
    }

    public class spline1dfitreport : alglibobject
    {
        public double taskrcond;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public override alglib.alglibobject make_copy()
        {
            spline1dfitreport dst = new spline1dfitreport();
            dst.taskrcond = taskrcond;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.maxerror = maxerror;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_spline1dfitreport_init(ref x_spline1dfitreport x)
    {
        x.taskrcond = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.maxerror = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_spline1dfitreport_clear(ref x_spline1dfitreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_spline1dfitreport_init_from(ref x_spline1dfitreport x, spline1dfitreport v)
    {
        x.taskrcond = v.taskrcond;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.maxerror = v.maxerror;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_spline1dfitreport_to_record(ref x_spline1dfitreport x, ref spline1dfitreport v)
    {
        if( v==null )
            v = new spline1dfitreport();
        v.taskrcond = x.taskrcond;
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.maxerror = x.maxerror;
    }

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_lsfitreport
    {
        public double taskrcond;
        public x_int iterationscount;
        public x_int varidx;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public double wrmserror;
        public x_matrix covpar;
        public x_vector errpar;
        public x_vector errcurve;
        public x_vector noise;
        public double r2;
    }

    public class lsfitreport : alglibobject
    {
        public double taskrcond;
        public int iterationscount;
        public int varidx;
        public double rmserror;
        public double avgerror;
        public double avgrelerror;
        public double maxerror;
        public double wrmserror;
        public double[,] covpar;
        public double[] errpar;
        public double[] errcurve;
        public double[] noise;
        public double r2;
        public override alglib.alglibobject make_copy()
        {
            lsfitreport dst = new lsfitreport();
            dst.taskrcond = taskrcond;
            dst.iterationscount = iterationscount;
            dst.varidx = varidx;
            dst.rmserror = rmserror;
            dst.avgerror = avgerror;
            dst.avgrelerror = avgrelerror;
            dst.maxerror = maxerror;
            dst.wrmserror = wrmserror;
            dst.covpar = (double[,])covpar.Clone();        dst.errpar = (double[])errpar.Clone();        dst.errcurve = (double[])errcurve.Clone();        dst.noise = (double[])noise.Clone();        dst.r2 = r2;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_lsfitreport_init(ref x_lsfitreport x)
    {
        x.taskrcond = 0;
        x.iterationscount.longval = 0;
        x.varidx.longval = 0;
        x.rmserror = 0;
        x.avgerror = 0;
        x.avgrelerror = 0;
        x.maxerror = 0;
        x.wrmserror = 0;
        x_matrix_create_empty(ref x.covpar, DT_REAL);
        x_vector_create_empty(ref x.errpar, DT_REAL);
        x_vector_create_empty(ref x.errcurve, DT_REAL);
        x_vector_create_empty(ref x.noise, DT_REAL);
        x.r2 = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_lsfitreport_clear(ref x_lsfitreport x)
    {
        x_matrix_clear(ref x.covpar);
        x_vector_clear(ref x.errpar);
        x_vector_clear(ref x.errcurve);
        x_vector_clear(ref x.noise);
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_lsfitreport_init_from(ref x_lsfitreport x, lsfitreport v)
    {
        x.taskrcond = v.taskrcond;
        x.iterationscount.longval = v.iterationscount;
        x.varidx.longval = v.varidx;
        x.rmserror = v.rmserror;
        x.avgerror = v.avgerror;
        x.avgrelerror = v.avgrelerror;
        x.maxerror = v.maxerror;
        x.wrmserror = v.wrmserror;
        x_matrix_from_array(ref x.covpar, v.covpar, X_CREATE);
        x_vector_from_array(ref x.errpar, v.errpar, X_CREATE);
        x_vector_from_array(ref x.errcurve, v.errcurve, X_CREATE);
        x_vector_from_array(ref x.noise, v.noise, X_CREATE);
        x.r2 = v.r2;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_lsfitreport_to_record(ref x_lsfitreport x, ref lsfitreport v)
    {
        if( v==null )
            v = new lsfitreport();
        v.taskrcond = x.taskrcond;
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.rmserror = x.rmserror;
        v.avgerror = x.avgerror;
        v.avgrelerror = x.avgrelerror;
        v.maxerror = x.maxerror;
        v.wrmserror = x.wrmserror;
        x_matrix_to_array(ref x.covpar, ref v.covpar);
        x_vector_to_array(ref x.errpar, ref v.errpar);
        x_vector_to_array(ref x.errcurve, ref v.errcurve);
        x_vector_to_array(ref x.noise, ref v.noise);
        v.r2 = x.r2;
    }

    public unsafe class lsfitstate : alglibobject
    {
        public void *ptr;
        public lsfitstate(void *x)
        {
            ptr = x;
        }
        ~lsfitstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new lsfitstate(null);
            return new lsfitstate(_i_x_obj_copy_lsfitstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_lsfitstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_lsfitstate(void *x);
    private static _d_x_obj_copy_lsfitstate _i_x_obj_copy_lsfitstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_lsfitstate(void *x);
    private static _d_x_obj_free_lsfitstate _i_x_obj_free_lsfitstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_set_needf(void *x, byte *dst);
    private static _d_x_lsfitstate_get_needf _i_x_lsfitstate_get_needf = null;
    private static _d_x_lsfitstate_set_needf _i_x_lsfitstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_set_needfg(void *x, byte *dst);
    private static _d_x_lsfitstate_get_needfg _i_x_lsfitstate_get_needfg = null;
    private static _d_x_lsfitstate_set_needfg _i_x_lsfitstate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_needfgh(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_set_needfgh(void *x, byte *dst);
    private static _d_x_lsfitstate_get_needfgh _i_x_lsfitstate_get_needfgh = null;
    private static _d_x_lsfitstate_set_needfgh _i_x_lsfitstate_set_needfgh = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_set_xupdated(void *x, byte *dst);
    private static _d_x_lsfitstate_get_xupdated _i_x_lsfitstate_get_xupdated = null;
    private static _d_x_lsfitstate_set_xupdated _i_x_lsfitstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_c(void *x, x_vector *dst);
    private static _d_x_lsfitstate_get_c _i_x_lsfitstate_get_c = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_set_f(void *x, double *dst);
    private static _d_x_lsfitstate_get_f _i_x_lsfitstate_get_f = null;
    private static _d_x_lsfitstate_set_f _i_x_lsfitstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_g(void *x, x_vector *dst);
    private static _d_x_lsfitstate_get_g _i_x_lsfitstate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_h(void *x, x_matrix *dst);
    private static _d_x_lsfitstate_get_h _i_x_lsfitstate_get_h = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_lsfitstate_get_x(void *x, x_vector *dst);
    private static _d_x_lsfitstate_get_x _i_x_lsfitstate_get_x = null;
    private static unsafe void _core_lstfitpiecewiselinearrdpfixed(double[] x, double[] y, int n, int m, out double[] x2, out double[] y2, out int nsections, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x2 = new x_vector();
        x_vector _d_y2 = new x_vector();
        x_int _d_nsections = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_create_empty(ref _d_x2, DT_REAL);
                x2 = null;
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                _error_code = _i_ser_lstfitpiecewiselinearrdpfixed(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_x2, &_d_y2, &_d_nsections);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lstfitpiecewiselinearrdpfixed' call");
            }
            if( _d_x2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x2, ref x2);
            if( x2 == null )
                x2 = new double[0];
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
            nsections = _d_nsections.intval;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
        }
        // This function returns no value.
    }
    public static void lstfitpiecewiselinearrdpfixed(double[] x, double[] y, int n, int m, out double[] x2, out double[] y2, out int nsections)
    {
    _core_lstfitpiecewiselinearrdpfixed( x,  y,  n,  m, out  x2, out  y2, out  nsections, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lstfitpiecewiselinearrdp(double[] x, double[] y, int n, double eps, out double[] x2, out double[] y2, out int nsections, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_eps = eps;
        x_vector _d_x2 = new x_vector();
        x_vector _d_y2 = new x_vector();
        x_int _d_nsections = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_create_empty(ref _d_x2, DT_REAL);
                x2 = null;
                x_vector_create_empty(ref _d_y2, DT_REAL);
                y2 = null;
                _error_code = _i_ser_lstfitpiecewiselinearrdp(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_eps, &_d_x2, &_d_y2, &_d_nsections);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lstfitpiecewiselinearrdp' call");
            }
            if( _d_x2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x2, ref x2);
            if( x2 == null )
                x2 = new double[0];
            if( _d_y2.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y2, ref y2);
            if( y2 == null )
                y2 = new double[0];
            nsections = _d_nsections.intval;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_x2);
            x_vector_clear(ref _d_y2);
        }
        // This function returns no value.
    }
    public static void lstfitpiecewiselinearrdp(double[] x, double[] y, int n, double eps, out double[] x2, out double[] y2, out int nsections)
    {
    _core_lstfitpiecewiselinearrdp( x,  y,  n,  eps, out  x2, out  y2, out  nsections, alglibmode.serial);
    return;
    }
    private static unsafe void _core_polynomialfit(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_p = null;
        p = null;
        x_polynomialfitreport _d_rep = new x_polynomialfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_polynomialfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_polynomialfit(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_p, &_d_rep);
                else    _error_code = _i_smp_polynomialfit(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_p, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialfit' call");
            }
            info = _d_info.intval;
            p = new barycentricinterpolant(_d_p);
            rep = null;
            x_polynomialfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
            x_polynomialfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void polynomialfit(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
    _core_polynomialfit( x,  y,  n,  m, out  info, out  p, out  rep, alglibmode.serial);
    return;
    }
    public static void polynomialfit(double[] x, double[] y, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'polynomialfit': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_polynomialfit( x,  y,  n,  m, out  info, out  p, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_polynomialfit(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
    _core_polynomialfit( x,  y,  n,  m, out  info, out  p, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_polynomialfit(double[] x, double[] y, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'polynomialfit': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_polynomialfit( x,  y,  n,  m, out  info, out  p, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_polynomialfitwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_xc = new x_vector();
        x_vector _d_yc = new x_vector();
        x_vector _d_dc = new x_vector();
        x_int _d_k = new x_int(k);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_p = null;
        p = null;
        x_polynomialfitreport _d_rep = new x_polynomialfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_xc = xc, _fp_yc = yc){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_xc, _fp_xc, ap.len(xc));
                x_vector_attach_to_array(ref _d_yc, _fp_yc, ap.len(yc));
                x_vector_from_array(ref _d_dc, dc, X_CREATE);
                x_polynomialfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_polynomialfitwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_p, &_d_rep);
                else    _error_code = _i_smp_polynomialfitwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_p, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialfitwc' call");
            }
            info = _d_info.intval;
            p = new barycentricinterpolant(_d_p);
            rep = null;
            x_polynomialfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_xc);
            x_vector_clear(ref _d_yc);
            x_vector_clear(ref _d_dc);
            if( _d_p!=null && p==null)
                _i_x_obj_free_barycentricinterpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
            x_polynomialfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void polynomialfitwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
    _core_polynomialfitwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  p, out  rep, alglibmode.serial);
    return;
    }
    public static void polynomialfitwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
    int n;
    int k;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
    if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
        throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    k = ap.len(xc);
    
    _core_polynomialfitwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  p, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_polynomialfitwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
    _core_polynomialfitwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  p, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_polynomialfitwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out barycentricinterpolant p, out polynomialfitreport rep)
    {
    int n;
    int k;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
    if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
        throw new alglibexception("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    k = ap.len(xc);
    
    _core_polynomialfitwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  p, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe double _core_logisticcalc4(double x, double a, double b, double c, double d, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        double _d_a = a;
        double _d_b = b;
        double _d_c = c;
        double _d_d = d;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_logisticcalc4(&_s_errormsg, &_d_result, &_d_x, &_d_a, &_d_b, &_d_c, &_d_d);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'logisticcalc4' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double logisticcalc4(double x, double a, double b, double c, double d)
    {
    double result = _core_logisticcalc4( x,  a,  b,  c,  d, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_logisticcalc5(double x, double a, double b, double c, double d, double g, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        double _d_a = a;
        double _d_b = b;
        double _d_c = c;
        double _d_d = d;
        double _d_g = g;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_logisticcalc5(&_s_errormsg, &_d_result, &_d_x, &_d_a, &_d_b, &_d_c, &_d_d, &_d_g);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'logisticcalc5' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double logisticcalc5(double x, double a, double b, double c, double d, double g)
    {
    double result = _core_logisticcalc5( x,  a,  b,  c,  d,  g, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_logisticfit4(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_ser_logisticfit4(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_a, &_d_b, &_d_c, &_d_d, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'logisticfit4' call");
            }
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void logisticfit4(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out lsfitreport rep)
    {
    _core_logisticfit4( x,  y,  n, out  a, out  b, out  c, out  d, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_logisticfit4ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_cnstrleft = cnstrleft;
        double _d_cnstrright = cnstrright;
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_ser_logisticfit4ec(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_cnstrleft, &_d_cnstrright, &_d_a, &_d_b, &_d_c, &_d_d, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'logisticfit4ec' call");
            }
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void logisticfit4ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out lsfitreport rep)
    {
    _core_logisticfit4ec( x,  y,  n,  cnstrleft,  cnstrright, out  a, out  b, out  c, out  d, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_logisticfit5(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        double _d_g = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_ser_logisticfit5(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_a, &_d_b, &_d_c, &_d_d, &_d_g, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'logisticfit5' call");
            }
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            g = _d_g;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void logisticfit5(double[] x, double[] y, int n, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
    _core_logisticfit5( x,  y,  n, out  a, out  b, out  c, out  d, out  g, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_logisticfit5ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_cnstrleft = cnstrleft;
        double _d_cnstrright = cnstrright;
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        double _d_g = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_ser_logisticfit5ec(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_cnstrleft, &_d_cnstrright, &_d_a, &_d_b, &_d_c, &_d_d, &_d_g, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'logisticfit5ec' call");
            }
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            g = _d_g;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void logisticfit5ec(double[] x, double[] y, int n, double cnstrleft, double cnstrright, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
    _core_logisticfit5ec( x,  y,  n,  cnstrleft,  cnstrright, out  a, out  b, out  c, out  d, out  g, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_logisticfit45x(double[] x, double[] y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_cnstrleft = cnstrleft;
        double _d_cnstrright = cnstrright;
        byte _d_is4pl = (byte)(is4pl ? 1 : 0);
        double _d_lambdav = lambdav;
        double _d_epsx = epsx;
        x_int _d_rscnt = new x_int(rscnt);
        double _d_a = 0;
        double _d_b = 0;
        double _d_c = 0;
        double _d_d = 0;
        double _d_g = 0;
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_lsfitreport_init(ref _d_rep);
                _error_code = _i_ser_logisticfit45x(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_cnstrleft, &_d_cnstrright, &_d_is4pl, &_d_lambdav, &_d_epsx, &_d_rscnt, &_d_a, &_d_b, &_d_c, &_d_d, &_d_g, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'logisticfit45x' call");
            }
            a = _d_a;
            b = _d_b;
            c = _d_c;
            d = _d_d;
            g = _d_g;
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void logisticfit45x(double[] x, double[] y, int n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, int rscnt, out double a, out double b, out double c, out double d, out double g, out lsfitreport rep)
    {
    _core_logisticfit45x( x,  y,  n,  cnstrleft,  cnstrright,  is4pl,  lambdav,  epsx,  rscnt, out  a, out  b, out  c, out  d, out  g, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_barycentricfitfloaterhormannwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_xc = new x_vector();
        x_vector _d_yc = new x_vector();
        x_vector _d_dc = new x_vector();
        x_int _d_k = new x_int(k);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_b = null;
        b = null;
        x_barycentricfitreport _d_rep = new x_barycentricfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_xc = xc, _fp_yc = yc){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_xc, _fp_xc, ap.len(xc));
                x_vector_attach_to_array(ref _d_yc, _fp_yc, ap.len(yc));
                x_vector_from_array(ref _d_dc, dc, X_CREATE);
                x_barycentricfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_barycentricfitfloaterhormannwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_b, &_d_rep);
                else    _error_code = _i_smp_barycentricfitfloaterhormannwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_b, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentricfitfloaterhormannwc' call");
            }
            info = _d_info.intval;
            b = new barycentricinterpolant(_d_b);
            rep = null;
            x_barycentricfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_xc);
            x_vector_clear(ref _d_yc);
            x_vector_clear(ref _d_dc);
            if( _d_b!=null && b==null)
                _i_x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to C# objects
            x_barycentricfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void barycentricfitfloaterhormannwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep)
    {
    _core_barycentricfitfloaterhormannwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  b, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_barycentricfitfloaterhormannwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep)
    {
    _core_barycentricfitfloaterhormannwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  b, out  rep, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_barycentricfitfloaterhormann(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_b = null;
        b = null;
        x_barycentricfitreport _d_rep = new x_barycentricfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_barycentricfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_barycentricfitfloaterhormann(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_b, &_d_rep);
                else    _error_code = _i_smp_barycentricfitfloaterhormann(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_b, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'barycentricfitfloaterhormann' call");
            }
            info = _d_info.intval;
            b = new barycentricinterpolant(_d_b);
            rep = null;
            x_barycentricfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_b!=null && b==null)
                _i_x_obj_free_barycentricinterpolant(_d_b); // on exception clean up X objects which were not attached to C# objects
            x_barycentricfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void barycentricfitfloaterhormann(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep)
    {
    _core_barycentricfitfloaterhormann( x,  y,  n,  m, out  info, out  b, out  rep, alglibmode.serial);
    return;
    }
    public static void smp_barycentricfitfloaterhormann(double[] x, double[] y, int n, int m, out int info, out barycentricinterpolant b, out barycentricfitreport rep)
    {
    _core_barycentricfitfloaterhormann( x,  y,  n,  m, out  info, out  b, out  rep, alglibmode.parallel);
    return;
    }
    private static unsafe void _core_spline1dfitpenalized(double[] x, double[] y, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        double _d_rho = rho;
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_spline1dfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spline1dfitpenalized(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_rho, &_d_info, &_d_s, &_d_rep);
                else    _error_code = _i_smp_spline1dfitpenalized(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_rho, &_d_info, &_d_s, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dfitpenalized' call");
            }
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void spline1dfitpenalized(double[] x, double[] y, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfitpenalized( x,  y,  n,  m,  rho, out  info, out  s, out  rep, alglibmode.serial);
    return;
    }
    public static void spline1dfitpenalized(double[] x, double[] y, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dfitpenalized( x,  y,  n,  m,  rho, out  info, out  s, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_spline1dfitpenalized(double[] x, double[] y, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfitpenalized( x,  y,  n,  m,  rho, out  info, out  s, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_spline1dfitpenalized(double[] x, double[] y, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dfitpenalized( x,  y,  n,  m,  rho, out  info, out  s, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spline1dfitpenalizedw(double[] x, double[] y, double[] w, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        double _d_rho = rho;
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_spline1dfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spline1dfitpenalizedw(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_m, &_d_rho, &_d_info, &_d_s, &_d_rep);
                else    _error_code = _i_smp_spline1dfitpenalizedw(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_m, &_d_rho, &_d_info, &_d_s, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dfitpenalizedw' call");
            }
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfitpenalizedw( x,  y,  w,  n,  m,  rho, out  info, out  s, out  rep, alglibmode.serial);
    return;
    }
    public static void spline1dfitpenalizedw(double[] x, double[] y, double[] w, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dfitpenalizedw( x,  y,  w,  n,  m,  rho, out  info, out  s, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_spline1dfitpenalizedw(double[] x, double[] y, double[] w, int n, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfitpenalizedw( x,  y,  w,  n,  m,  rho, out  info, out  s, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_spline1dfitpenalizedw(double[] x, double[] y, double[] w, int m, double rho, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dfitpenalizedw( x,  y,  w,  n,  m,  rho, out  info, out  s, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spline1dfitcubicwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_xc = new x_vector();
        x_vector _d_yc = new x_vector();
        x_vector _d_dc = new x_vector();
        x_int _d_k = new x_int(k);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_xc = xc, _fp_yc = yc){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_xc, _fp_xc, ap.len(xc));
                x_vector_attach_to_array(ref _d_yc, _fp_yc, ap.len(yc));
                x_vector_from_array(ref _d_dc, dc, X_CREATE);
                x_spline1dfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spline1dfitcubicwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_s, &_d_rep);
                else    _error_code = _i_smp_spline1dfitcubicwc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_s, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dfitcubicwc' call");
            }
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_xc);
            x_vector_clear(ref _d_yc);
            x_vector_clear(ref _d_dc);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfitcubicwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, alglibmode.serial);
    return;
    }
    public static void spline1dfitcubicwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    int k;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
    if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
        throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    k = ap.len(xc);
    
    _core_spline1dfitcubicwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_spline1dfitcubicwc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfitcubicwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_spline1dfitcubicwc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    int k;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
    if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
        throw new alglibexception("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    k = ap.len(xc);
    
    _core_spline1dfitcubicwc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spline1dfithermitewc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_xc = new x_vector();
        x_vector _d_yc = new x_vector();
        x_vector _d_dc = new x_vector();
        x_int _d_k = new x_int(k);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_xc = xc, _fp_yc = yc){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_xc, _fp_xc, ap.len(xc));
                x_vector_attach_to_array(ref _d_yc, _fp_yc, ap.len(yc));
                x_vector_from_array(ref _d_dc, dc, X_CREATE);
                x_spline1dfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spline1dfithermitewc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_s, &_d_rep);
                else    _error_code = _i_smp_spline1dfithermitewc(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_n, &_d_xc, &_d_yc, &_d_dc, &_d_k, &_d_m, &_d_info, &_d_s, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dfithermitewc' call");
            }
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_xc);
            x_vector_clear(ref _d_yc);
            x_vector_clear(ref _d_dc);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfithermitewc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, alglibmode.serial);
    return;
    }
    public static void spline1dfithermitewc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    int k;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
    if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
        throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    k = ap.len(xc);
    
    _core_spline1dfithermitewc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_spline1dfithermitewc(double[] x, double[] y, double[] w, int n, double[] xc, double[] yc, int[] dc, int k, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfithermitewc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_spline1dfithermitewc(double[] x, double[] y, double[] w, double[] xc, double[] yc, int[] dc, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    int k;
    
    if( (ap.len(x)!=ap.len(y)) || (ap.len(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
    if( (ap.len(xc)!=ap.len(yc)) || (ap.len(xc)!=ap.len(dc)))
        throw new alglibexception("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    k = ap.len(xc);
    
    _core_spline1dfithermitewc( x,  y,  w,  n,  xc,  yc,  dc,  k,  m, out  info, out  s, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spline1dfitcubic(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_spline1dfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spline1dfitcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_s, &_d_rep);
                else    _error_code = _i_smp_spline1dfitcubic(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_s, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dfitcubic' call");
            }
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void spline1dfitcubic(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfitcubic( x,  y,  n,  m, out  info, out  s, out  rep, alglibmode.serial);
    return;
    }
    public static void spline1dfitcubic(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dfitcubic( x,  y,  n,  m, out  info, out  s, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_spline1dfitcubic(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfitcubic( x,  y,  n,  m, out  info, out  s, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_spline1dfitcubic(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dfitcubic( x,  y,  n,  m, out  info, out  s, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_spline1dfithermite(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        void *_d_s = null;
        s = null;
        x_spline1dfitreport _d_rep = new x_spline1dfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_spline1dfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_spline1dfithermite(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_s, &_d_rep);
                else    _error_code = _i_smp_spline1dfithermite(&_s_errormsg, &_d_x, &_d_y, &_d_n, &_d_m, &_d_info, &_d_s, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline1dfithermite' call");
            }
            info = _d_info.intval;
            s = new spline1dinterpolant(_d_s);
            rep = null;
            x_spline1dfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            if( _d_s!=null && s==null)
                _i_x_obj_free_spline1dinterpolant(_d_s); // on exception clean up X objects which were not attached to C# objects
            x_spline1dfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void spline1dfithermite(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfithermite( x,  y,  n,  m, out  info, out  s, out  rep, alglibmode.serial);
    return;
    }
    public static void spline1dfithermite(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dfithermite( x,  y,  n,  m, out  info, out  s, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_spline1dfithermite(double[] x, double[] y, int n, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    _core_spline1dfithermite( x,  y,  n,  m, out  info, out  s, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_spline1dfithermite(double[] x, double[] y, int m, out int info, out spline1dinterpolant s, out spline1dfitreport rep)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_spline1dfithermite( x,  y,  n,  m, out  info, out  s, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_lsfitlinearw(double[] y, double[] w, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_matrix _d_fmatrix = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_w = w, _fp_fmatrix = fmatrix){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_matrix_attach_to_array(ref _d_fmatrix, _fp_fmatrix, ap.rows(fmatrix), ap.cols(fmatrix));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_lsfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_lsfitlinearw(&_s_errormsg, &_d_y, &_d_w, &_d_fmatrix, &_d_n, &_d_m, &_d_info, &_d_c, &_d_rep);
                else    _error_code = _i_smp_lsfitlinearw(&_s_errormsg, &_d_y, &_d_w, &_d_fmatrix, &_d_n, &_d_m, &_d_info, &_d_c, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitlinearw' call");
            }
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_fmatrix);
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitlinearw( y,  w,  fmatrix,  n,  m, out  info, out  c, out  rep, alglibmode.serial);
    return;
    }
    public static void lsfitlinearw(double[] y, double[] w, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep)
    {
    int n;
    int m;
    
    if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
        throw new alglibexception("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size");
    
    n = ap.len(y);
    m = ap.cols(fmatrix);
    
    _core_lsfitlinearw( y,  w,  fmatrix,  n,  m, out  info, out  c, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_lsfitlinearw(double[] y, double[] w, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitlinearw( y,  w,  fmatrix,  n,  m, out  info, out  c, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_lsfitlinearw(double[] y, double[] w, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep)
    {
    int n;
    int m;
    
    if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
        throw new alglibexception("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size");
    
    n = ap.len(y);
    m = ap.cols(fmatrix);
    
    _core_lsfitlinearw( y,  w,  fmatrix,  n,  m, out  info, out  c, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_matrix _d_fmatrix = new x_matrix();
        x_matrix _d_cmatrix = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_w = w, _fp_fmatrix = fmatrix, _fp_cmatrix = cmatrix){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_matrix_attach_to_array(ref _d_fmatrix, _fp_fmatrix, ap.rows(fmatrix), ap.cols(fmatrix));
                x_matrix_attach_to_array(ref _d_cmatrix, _fp_cmatrix, ap.rows(cmatrix), ap.cols(cmatrix));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_lsfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_lsfitlinearwc(&_s_errormsg, &_d_y, &_d_w, &_d_fmatrix, &_d_cmatrix, &_d_n, &_d_m, &_d_k, &_d_info, &_d_c, &_d_rep);
                else    _error_code = _i_smp_lsfitlinearwc(&_s_errormsg, &_d_y, &_d_w, &_d_fmatrix, &_d_cmatrix, &_d_n, &_d_m, &_d_k, &_d_info, &_d_c, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitlinearwc' call");
            }
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_matrix_clear(ref _d_fmatrix);
            x_matrix_clear(ref _d_cmatrix);
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitlinearwc( y,  w,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, alglibmode.serial);
    return;
    }
    public static void lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep)
    {
    int n;
    int m;
    int k;
    
    if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
        throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
    if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
        throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
    
    n = ap.len(y);
    m = ap.cols(fmatrix);
    k = ap.rows(cmatrix);
    
    _core_lsfitlinearwc( y,  w,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitlinearwc( y,  w,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_lsfitlinearwc(double[] y, double[] w, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep)
    {
    int n;
    int m;
    int k;
    
    if( (ap.len(y)!=ap.len(w)) || (ap.len(y)!=ap.rows(fmatrix)))
        throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
    if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
        throw new alglibexception("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
    
    n = ap.len(y);
    m = ap.cols(fmatrix);
    k = ap.rows(cmatrix);
    
    _core_lsfitlinearwc( y,  w,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_lsfitlinear(double[] y, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_matrix _d_fmatrix = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_fmatrix = fmatrix){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_matrix_attach_to_array(ref _d_fmatrix, _fp_fmatrix, ap.rows(fmatrix), ap.cols(fmatrix));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_lsfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_lsfitlinear(&_s_errormsg, &_d_y, &_d_fmatrix, &_d_n, &_d_m, &_d_info, &_d_c, &_d_rep);
                else    _error_code = _i_smp_lsfitlinear(&_s_errormsg, &_d_y, &_d_fmatrix, &_d_n, &_d_m, &_d_info, &_d_c, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitlinear' call");
            }
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_matrix_clear(ref _d_fmatrix);
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void lsfitlinear(double[] y, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitlinear( y,  fmatrix,  n,  m, out  info, out  c, out  rep, alglibmode.serial);
    return;
    }
    public static void lsfitlinear(double[] y, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep)
    {
    int n;
    int m;
    
    if( (ap.len(y)!=ap.rows(fmatrix)))
        throw new alglibexception("Error while calling 'lsfitlinear': looks like one of arguments has wrong size");
    
    n = ap.len(y);
    m = ap.cols(fmatrix);
    
    _core_lsfitlinear( y,  fmatrix,  n,  m, out  info, out  c, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_lsfitlinear(double[] y, double[,] fmatrix, int n, int m, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitlinear( y,  fmatrix,  n,  m, out  info, out  c, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_lsfitlinear(double[] y, double[,] fmatrix, out int info, out double[] c, out lsfitreport rep)
    {
    int n;
    int m;
    
    if( (ap.len(y)!=ap.rows(fmatrix)))
        throw new alglibexception("Error while calling 'lsfitlinear': looks like one of arguments has wrong size");
    
    n = ap.len(y);
    m = ap.cols(fmatrix);
    
    _core_lsfitlinear( y,  fmatrix,  n,  m, out  info, out  c, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_y = new x_vector();
        x_matrix _d_fmatrix = new x_matrix();
        x_matrix _d_cmatrix = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_y = y, _fp_fmatrix = fmatrix, _fp_cmatrix = cmatrix){
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_matrix_attach_to_array(ref _d_fmatrix, _fp_fmatrix, ap.rows(fmatrix), ap.cols(fmatrix));
                x_matrix_attach_to_array(ref _d_cmatrix, _fp_cmatrix, ap.rows(cmatrix), ap.cols(cmatrix));
                x_vector_create_empty(ref _d_c, DT_REAL);
                c = null;
                x_lsfitreport_init(ref _d_rep);
                if( _alglib_mode == alglibmode.serial )
                    _error_code = _i_ser_lsfitlinearc(&_s_errormsg, &_d_y, &_d_fmatrix, &_d_cmatrix, &_d_n, &_d_m, &_d_k, &_d_info, &_d_c, &_d_rep);
                else    _error_code = _i_smp_lsfitlinearc(&_s_errormsg, &_d_y, &_d_fmatrix, &_d_cmatrix, &_d_n, &_d_m, &_d_k, &_d_info, &_d_c, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitlinearc' call");
            }
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_y);
            x_matrix_clear(ref _d_fmatrix);
            x_matrix_clear(ref _d_cmatrix);
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitlinearc( y,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, alglibmode.serial);
    return;
    }
    public static void lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep)
    {
    int n;
    int m;
    int k;
    
    if( (ap.len(y)!=ap.rows(fmatrix)))
        throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
    if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
        throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
    
    n = ap.len(y);
    m = ap.cols(fmatrix);
    k = ap.rows(cmatrix);
    
    _core_lsfitlinearc( y,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, alglibmode.serial);
    
    return;
    }
    public static void smp_lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, int n, int m, int k, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitlinearc( y,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, alglibmode.parallel);
    return;
    }
    public static void smp_lsfitlinearc(double[] y, double[,] fmatrix, double[,] cmatrix, out int info, out double[] c, out lsfitreport rep)
    {
    int n;
    int m;
    int k;
    
    if( (ap.len(y)!=ap.rows(fmatrix)))
        throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
    if( (ap.cols(fmatrix)!=ap.cols(cmatrix)-1))
        throw new alglibexception("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
    
    n = ap.len(y);
    m = ap.cols(fmatrix);
    k = ap.rows(cmatrix);
    
    _core_lsfitlinearc( y,  fmatrix,  cmatrix,  n,  m,  k, out  info, out  c, out  rep, alglibmode.parallel);
    
    return;
    }
    private static unsafe void _core_lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, double diffstep, out lsfitstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_lsfitcreatewf(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_c, &_d_n, &_d_m, &_d_k, &_d_diffstep, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitcreatewf' call");
            }
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, double diffstep, out lsfitstate state)
    {
    _core_lsfitcreatewf( x,  y,  w,  c,  n,  m,  k,  diffstep, out  state, alglibmode.serial);
    return;
    }
    public static void lsfitcreatewf(double[,] x, double[] y, double[] w, double[] c, double diffstep, out lsfitstate state)
    {
    int n;
    int m;
    int k;
    
    if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'lsfitcreatewf': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m = ap.cols(x);
    k = ap.len(c);
    
    _core_lsfitcreatewf( x,  y,  w,  c,  n,  m,  k,  diffstep, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_lsfitcreatef(double[,] x, double[] y, double[] c, int n, int m, int k, double diffstep, out lsfitstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_lsfitcreatef(&_s_errormsg, &_d_x, &_d_y, &_d_c, &_d_n, &_d_m, &_d_k, &_d_diffstep, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitcreatef' call");
            }
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, int n, int m, int k, double diffstep, out lsfitstate state)
    {
    _core_lsfitcreatef( x,  y,  c,  n,  m,  k,  diffstep, out  state, alglibmode.serial);
    return;
    }
    public static void lsfitcreatef(double[,] x, double[] y, double[] c, double diffstep, out lsfitstate state)
    {
    int n;
    int m;
    int k;
    
    if( (ap.rows(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'lsfitcreatef': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m = ap.cols(x);
    k = ap.len(c);
    
    _core_lsfitcreatef( x,  y,  c,  n,  m,  k,  diffstep, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        byte _d_cheapfg = (byte)(cheapfg ? 1 : 0);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_lsfitcreatewfg(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_c, &_d_n, &_d_m, &_d_k, &_d_cheapfg, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitcreatewfg' call");
            }
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state)
    {
    _core_lsfitcreatewfg( x,  y,  w,  c,  n,  m,  k,  cheapfg, out  state, alglibmode.serial);
    return;
    }
    public static void lsfitcreatewfg(double[,] x, double[] y, double[] w, double[] c, bool cheapfg, out lsfitstate state)
    {
    int n;
    int m;
    int k;
    
    if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'lsfitcreatewfg': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m = ap.cols(x);
    k = ap.len(c);
    
    _core_lsfitcreatewfg( x,  y,  w,  c,  n,  m,  k,  cheapfg, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_lsfitcreatefg(double[,] x, double[] y, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        byte _d_cheapfg = (byte)(cheapfg ? 1 : 0);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_lsfitcreatefg(&_s_errormsg, &_d_x, &_d_y, &_d_c, &_d_n, &_d_m, &_d_k, &_d_cheapfg, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitcreatefg' call");
            }
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, int n, int m, int k, bool cheapfg, out lsfitstate state)
    {
    _core_lsfitcreatefg( x,  y,  c,  n,  m,  k,  cheapfg, out  state, alglibmode.serial);
    return;
    }
    public static void lsfitcreatefg(double[,] x, double[] y, double[] c, bool cheapfg, out lsfitstate state)
    {
    int n;
    int m;
    int k;
    
    if( (ap.rows(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'lsfitcreatefg': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m = ap.cols(x);
    k = ap.len(c);
    
    _core_lsfitcreatefg( x,  y,  c,  n,  m,  k,  cheapfg, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, out lsfitstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_w = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_w = w, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_w, _fp_w, ap.len(w));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_lsfitcreatewfgh(&_s_errormsg, &_d_x, &_d_y, &_d_w, &_d_c, &_d_n, &_d_m, &_d_k, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitcreatewfgh' call");
            }
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_w);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, int n, int m, int k, out lsfitstate state)
    {
    _core_lsfitcreatewfgh( x,  y,  w,  c,  n,  m,  k, out  state, alglibmode.serial);
    return;
    }
    public static void lsfitcreatewfgh(double[,] x, double[] y, double[] w, double[] c, out lsfitstate state)
    {
    int n;
    int m;
    int k;
    
    if( (ap.rows(x)!=ap.len(y)) || (ap.rows(x)!=ap.len(w)))
        throw new alglibexception("Error while calling 'lsfitcreatewfgh': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m = ap.cols(x);
    k = ap.len(c);
    
    _core_lsfitcreatewfgh( x,  y,  w,  c,  n,  m,  k, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_lsfitcreatefgh(double[,] x, double[] y, double[] c, int n, int m, int k, out lsfitstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_vector _d_y = new x_vector();
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_int _d_k = new x_int(k);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_c = c){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_lsfitcreatefgh(&_s_errormsg, &_d_x, &_d_y, &_d_c, &_d_n, &_d_m, &_d_k, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitcreatefgh' call");
            }
            state = new lsfitstate(_d_state);
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_c);
            if( _d_state!=null && state==null)
                _i_x_obj_free_lsfitstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, int n, int m, int k, out lsfitstate state)
    {
    _core_lsfitcreatefgh( x,  y,  c,  n,  m,  k, out  state, alglibmode.serial);
    return;
    }
    public static void lsfitcreatefgh(double[,] x, double[] y, double[] c, out lsfitstate state)
    {
    int n;
    int m;
    int k;
    
    if( (ap.rows(x)!=ap.len(y)))
        throw new alglibexception("Error while calling 'lsfitcreatefgh': looks like one of arguments has wrong size");
    
    n = ap.rows(x);
    m = ap.cols(x);
    k = ap.len(c);
    
    _core_lsfitcreatefgh( x,  y,  c,  n,  m,  k, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_lsfitsetcond(lsfitstate state, double epsf, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lsfitsetcond(&_s_errormsg, &_d_state, &_d_epsf, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitsetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lsfitsetcond(lsfitstate state, double epsf, double epsx, int maxits)
    {
    _core_lsfitsetcond( state,  epsf,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lsfitsetstpmax(lsfitstate state, double stpmax, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lsfitsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitsetstpmax' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lsfitsetstpmax(lsfitstate state, double stpmax)
    {
    _core_lsfitsetstpmax( state,  stpmax, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lsfitsetxrep(lsfitstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lsfitsetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitsetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lsfitsetxrep(lsfitstate state, bool needxrep)
    {
    _core_lsfitsetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lsfitsetscale(lsfitstate state, double[] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_ser_lsfitsetscale(&_s_errormsg, &_d_state, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitsetscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    public static void lsfitsetscale(lsfitstate state, double[] s)
    {
    _core_lsfitsetscale( state,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lsfitsetbc(lsfitstate state, double[] bndl, double[] bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_ser_lsfitsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitsetbc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    public static void lsfitsetbc(lsfitstate state, double[] bndl, double[] bndu)
    {
    _core_lsfitsetbc( state,  bndl,  bndu, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_lsfititeration(lsfitstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lsfititeration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfititeration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool lsfititeration(lsfitstate state)
    {
    bool result = _core_lsfititeration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_par = new x_vector();
        double[] _cs_par = null;
        double _cs_f = 0;
        byte _xc_needf= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_par, DT_REAL);
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_par = new double[_xc_par.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_lsfititeration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'lsfititeration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_lsfitstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_lsfitstate_get_needf(_state, &_xc_needf);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            x_vector_to_array(ref _xc_par, ref _cs_par);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, _cs_par, ref _cs_f, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_lsfitstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
    }
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_par = new x_vector();
        double[] _cs_par = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needf= 0;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_par, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        _i_x_lsfitstate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_par = new double[_xc_par.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_lsfititeration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'lsfititeration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_lsfitstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_lsfitstate_get_needf(_state, &_xc_needf);
            _i_x_lsfitstate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            x_vector_to_array(ref _xc_par, ref _cs_par);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, _cs_par, ref _cs_f, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, _cs_par, ref _cs_f, _cs_g, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_lsfitstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
    }
    public static unsafe void lsfitfit(lsfitstate state, ndimensional_pfunc func, ndimensional_pgrad grad, ndimensional_phess hess, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_par = new x_vector();
        double[] _cs_par = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        x_matrix _xc_h = new x_matrix();
        double[,] _cs_h = null;
        byte _xc_needf= 0;
        byte _xc_needfg= 0;
        byte _xc_needfgh= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (func is null)");
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (grad is null)");
        if( hess==null )
            throw new alglibexception("ALGLIB: error in 'lsfitfit()' (hess is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_par, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        x_matrix_create_empty(ref _xc_h, DT_REAL);
        _i_x_lsfitstate_get_c(_state, &_xc_arg);
        _i_x_lsfitstate_get_x(_state, &_xc_par);
        _i_x_lsfitstate_get_g(_state, &_xc_g);
        _i_x_lsfitstate_get_h(_state, &_xc_h);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_par = new double[_xc_par.cnt];
        _cs_g = new double[_xc_g.cnt];
        _cs_h = new double[_xc_h.rows,_xc_h.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_lsfititeration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'lsfititeration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_lsfitstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_lsfitstate_get_needf(_state, &_xc_needf);
            _i_x_lsfitstate_get_needfg(_state, &_xc_needfg);
            _i_x_lsfitstate_get_needfgh(_state, &_xc_needfgh);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            x_vector_to_array(ref _xc_par, ref _cs_par);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, _cs_par, ref _cs_f, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, _cs_par, ref _cs_f, _cs_g, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_needfgh!=0 )
            {
                hess(_cs_arg, _cs_par, ref _cs_f, _cs_g, _cs_h, obj);
                _i_x_lsfitstate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                x_matrix_from_array(ref _xc_h, _cs_h, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_lsfitstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_lsfitresults(lsfitstate state, out int info, out double[] c, out lsfitreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_info = new x_int();
        x_vector _d_c = new x_vector();
        x_lsfitreport _d_rep = new x_lsfitreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            x_lsfitreport_init(ref _d_rep);
            _error_code = _i_ser_lsfitresults(&_s_errormsg, &_d_state, &_d_info, &_d_c, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            info = _d_info.intval;
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
            rep = null;
            x_lsfitreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_c);
            x_lsfitreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void lsfitresults(lsfitstate state, out int info, out double[] c, out lsfitreport rep)
    {
    _core_lsfitresults( state, out  info, out  c, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lsfitsetgradientcheck(lsfitstate state, double teststep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lsfitsetgradientcheck(&_s_errormsg, &_d_state, &_d_teststep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lsfitsetgradientcheck' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lsfitsetgradientcheck(lsfitstate state, double teststep)
    {
    _core_lsfitsetgradientcheck( state,  teststep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage parametric
    //
    

    public unsafe class pspline2interpolant : alglibobject
    {
        public void *ptr;
        public pspline2interpolant(void *x)
        {
            ptr = x;
        }
        ~pspline2interpolant()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new pspline2interpolant(null);
            return new pspline2interpolant(_i_x_obj_copy_pspline2interpolant(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_pspline2interpolant(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_pspline2interpolant(void *x);
    private static _d_x_obj_copy_pspline2interpolant _i_x_obj_copy_pspline2interpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_pspline2interpolant(void *x);
    private static _d_x_obj_free_pspline2interpolant _i_x_obj_free_pspline2interpolant = null;

    public unsafe class pspline3interpolant : alglibobject
    {
        public void *ptr;
        public pspline3interpolant(void *x)
        {
            ptr = x;
        }
        ~pspline3interpolant()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new pspline3interpolant(null);
            return new pspline3interpolant(_i_x_obj_copy_pspline3interpolant(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_pspline3interpolant(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_pspline3interpolant(void *x);
    private static _d_x_obj_copy_pspline3interpolant _i_x_obj_copy_pspline3interpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_pspline3interpolant(void *x);
    private static _d_x_obj_free_pspline3interpolant _i_x_obj_free_pspline3interpolant = null;
    private static unsafe void _core_pspline2build(double[,] xy, int n, int st, int pt, out pspline2interpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_st = new x_int(st);
        x_int _d_pt = new x_int(pt);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_pspline2build(&_s_errormsg, &_d_xy, &_d_n, &_d_st, &_d_pt, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline2build' call");
            }
            p = new pspline2interpolant(_d_p);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_p!=null && p==null)
                _i_x_obj_free_pspline2interpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void pspline2build(double[,] xy, int n, int st, int pt, out pspline2interpolant p)
    {
    _core_pspline2build( xy,  n,  st,  pt, out  p, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline3build(double[,] xy, int n, int st, int pt, out pspline3interpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_st = new x_int(st);
        x_int _d_pt = new x_int(pt);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_pspline3build(&_s_errormsg, &_d_xy, &_d_n, &_d_st, &_d_pt, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline3build' call");
            }
            p = new pspline3interpolant(_d_p);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_p!=null && p==null)
                _i_x_obj_free_pspline3interpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void pspline3build(double[,] xy, int n, int st, int pt, out pspline3interpolant p)
    {
    _core_pspline3build( xy,  n,  st,  pt, out  p, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline2buildperiodic(double[,] xy, int n, int st, int pt, out pspline2interpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_st = new x_int(st);
        x_int _d_pt = new x_int(pt);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_pspline2buildperiodic(&_s_errormsg, &_d_xy, &_d_n, &_d_st, &_d_pt, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline2buildperiodic' call");
            }
            p = new pspline2interpolant(_d_p);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_p!=null && p==null)
                _i_x_obj_free_pspline2interpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void pspline2buildperiodic(double[,] xy, int n, int st, int pt, out pspline2interpolant p)
    {
    _core_pspline2buildperiodic( xy,  n,  st,  pt, out  p, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline3buildperiodic(double[,] xy, int n, int st, int pt, out pspline3interpolant p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_st = new x_int(st);
        x_int _d_pt = new x_int(pt);
        void *_d_p = null;
        p = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_pspline3buildperiodic(&_s_errormsg, &_d_xy, &_d_n, &_d_st, &_d_pt, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline3buildperiodic' call");
            }
            p = new pspline3interpolant(_d_p);
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
            if( _d_p!=null && p==null)
                _i_x_obj_free_pspline3interpolant(_d_p); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void pspline3buildperiodic(double[,] xy, int n, int st, int pt, out pspline3interpolant p)
    {
    _core_pspline3buildperiodic( xy,  n,  st,  pt, out  p, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline2parametervalues(pspline2interpolant p, out int n, out double[] t, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        x_int _d_n = new x_int();
        x_vector _d_t = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_t, DT_REAL);
            t = null;
            _error_code = _i_ser_pspline2parametervalues(&_s_errormsg, &_d_p, &_d_n, &_d_t);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline2parametervalues' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            if( _d_t.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_t, ref t);
            if( t == null )
                t = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_t);
        }
        // This function returns no value.
    }
    public static void pspline2parametervalues(pspline2interpolant p, out int n, out double[] t)
    {
    _core_pspline2parametervalues( p, out  n, out  t, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline3parametervalues(pspline3interpolant p, out int n, out double[] t, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        x_int _d_n = new x_int();
        x_vector _d_t = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_t, DT_REAL);
            t = null;
            _error_code = _i_ser_pspline3parametervalues(&_s_errormsg, &_d_p, &_d_n, &_d_t);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline3parametervalues' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            if( _d_t.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_t, ref t);
            if( t == null )
                t = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_t);
        }
        // This function returns no value.
    }
    public static void pspline3parametervalues(pspline3interpolant p, out int n, out double[] t)
    {
    _core_pspline3parametervalues( p, out  n, out  t, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline2calc(pspline2interpolant p, double t, out double x, out double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_y = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline2calc(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline2calc' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pspline2calc(pspline2interpolant p, double t, out double x, out double y)
    {
    _core_pspline2calc( p,  t, out  x, out  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline3calc(pspline3interpolant p, double t, out double x, out double y, out double z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_y = 0;
        double _d_z = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline3calc(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_y, &_d_z);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline3calc' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
            z = _d_z;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pspline3calc(pspline3interpolant p, double t, out double x, out double y, out double z)
    {
    _core_pspline3calc( p,  t, out  x, out  y, out  z, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline2tangent(pspline2interpolant p, double t, out double x, out double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_y = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline2tangent(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline2tangent' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pspline2tangent(pspline2interpolant p, double t, out double x, out double y)
    {
    _core_pspline2tangent( p,  t, out  x, out  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline3tangent(pspline3interpolant p, double t, out double x, out double y, out double z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_y = 0;
        double _d_z = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline3tangent(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_y, &_d_z);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline3tangent' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            y = _d_y;
            z = _d_z;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pspline3tangent(pspline3interpolant p, double t, out double x, out double y, out double z)
    {
    _core_pspline3tangent( p,  t, out  x, out  y, out  z, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline2diff(pspline2interpolant p, double t, out double x, out double dx, out double y, out double dy, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_dx = 0;
        double _d_y = 0;
        double _d_dy = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline2diff(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_dx, &_d_y, &_d_dy);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline2diff' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            dx = _d_dx;
            y = _d_y;
            dy = _d_dy;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pspline2diff(pspline2interpolant p, double t, out double x, out double dx, out double y, out double dy)
    {
    _core_pspline2diff( p,  t, out  x, out  dx, out  y, out  dy, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline3diff(pspline3interpolant p, double t, out double x, out double dx, out double y, out double dy, out double z, out double dz, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_dx = 0;
        double _d_y = 0;
        double _d_dy = 0;
        double _d_z = 0;
        double _d_dz = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline3diff(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_dx, &_d_y, &_d_dy, &_d_z, &_d_dz);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline3diff' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            dx = _d_dx;
            y = _d_y;
            dy = _d_dy;
            z = _d_z;
            dz = _d_dz;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pspline3diff(pspline3interpolant p, double t, out double x, out double dx, out double y, out double dy, out double z, out double dz)
    {
    _core_pspline3diff( p,  t, out  x, out  dx, out  y, out  dy, out  z, out  dz, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline2diff2(pspline2interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_dx = 0;
        double _d_d2x = 0;
        double _d_y = 0;
        double _d_dy = 0;
        double _d_d2y = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline2diff2(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_dx, &_d_d2x, &_d_y, &_d_dy, &_d_d2y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline2diff2' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            dx = _d_dx;
            d2x = _d_d2x;
            y = _d_y;
            dy = _d_dy;
            d2y = _d_d2y;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pspline2diff2(pspline2interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y)
    {
    _core_pspline2diff2( p,  t, out  x, out  dx, out  d2x, out  y, out  dy, out  d2y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_pspline3diff2(pspline3interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, out double z, out double dz, out double d2z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_p = p.ptr;
        double _d_t = t;
        double _d_x = 0;
        double _d_dx = 0;
        double _d_d2x = 0;
        double _d_y = 0;
        double _d_dy = 0;
        double _d_d2y = 0;
        double _d_z = 0;
        double _d_dz = 0;
        double _d_d2z = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline3diff2(&_s_errormsg, &_d_p, &_d_t, &_d_x, &_d_dx, &_d_d2x, &_d_y, &_d_dy, &_d_d2y, &_d_z, &_d_dz, &_d_d2z);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline3diff2' call");
            }
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
            x = _d_x;
            dx = _d_dx;
            d2x = _d_d2x;
            y = _d_y;
            dy = _d_dy;
            d2y = _d_d2y;
            z = _d_z;
            dz = _d_dz;
            d2z = _d_d2z;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pspline3diff2(pspline3interpolant p, double t, out double x, out double dx, out double d2x, out double y, out double dy, out double d2y, out double z, out double dz, out double d2z)
    {
    _core_pspline3diff2( p,  t, out  x, out  dx, out  d2x, out  y, out  dy, out  d2y, out  z, out  dz, out  d2z, alglibmode.serial);
    return;
    }
    private static unsafe double _core_pspline2arclength(pspline2interpolant p, double a, double b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_p = p.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline2arclength(&_s_errormsg, &_d_result, &_d_p, &_d_a, &_d_b);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline2arclength' call");
            }
            result = _d_result;
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double pspline2arclength(pspline2interpolant p, double a, double b)
    {
    double result = _core_pspline2arclength( p,  a,  b, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_pspline3arclength(pspline3interpolant p, double a, double b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_p = p.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pspline3arclength(&_s_errormsg, &_d_result, &_d_p, &_d_a, &_d_b);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pspline3arclength' call");
            }
            result = _d_result;
            ap.assert(p.ptr==_d_p, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double pspline3arclength(pspline3interpolant p, double a, double b)
    {
    double result = _core_pspline3arclength( p,  a,  b, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_parametricrdpfixed(double[,] x, int n, int d, int stopm, double stopeps, out double[,] x2, out int[] idx2, out int nsections, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_x = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_d = new x_int(d);
        x_int _d_stopm = new x_int(stopm);
        double _d_stopeps = stopeps;
        x_matrix _d_x2 = new x_matrix();
        x_vector _d_idx2 = new x_vector();
        x_int _d_nsections = new x_int();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_matrix_attach_to_array(ref _d_x, _fp_x, ap.rows(x), ap.cols(x));
                x_matrix_create_empty(ref _d_x2, DT_REAL);
                x2 = null;
                x_vector_create_empty(ref _d_idx2, DT_INT);
                idx2 = null;
                _error_code = _i_ser_parametricrdpfixed(&_s_errormsg, &_d_x, &_d_n, &_d_d, &_d_stopm, &_d_stopeps, &_d_x2, &_d_idx2, &_d_nsections);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'parametricrdpfixed' call");
            }
            if( _d_x2.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_x2, ref x2);
            if( x2 == null )
                x2 = new double[0,0];
            x_vector_to_array(ref _d_idx2, ref idx2);
            nsections = _d_nsections.intval;
        }
        finally
        {
            x_matrix_clear(ref _d_x);
            x_matrix_clear(ref _d_x2);
            x_vector_clear(ref _d_idx2);
        }
        // This function returns no value.
    }
    public static void parametricrdpfixed(double[,] x, int n, int d, int stopm, double stopeps, out double[,] x2, out int[] idx2, out int nsections)
    {
    _core_parametricrdpfixed( x,  n,  d,  stopm,  stopeps, out  x2, out  idx2, out  nsections, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage linlsqr
    //
    

    public unsafe class linlsqrstate : alglibobject
    {
        public void *ptr;
        public linlsqrstate(void *x)
        {
            ptr = x;
        }
        ~linlsqrstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new linlsqrstate(null);
            return new linlsqrstate(_i_x_obj_copy_linlsqrstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_linlsqrstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_linlsqrstate(void *x);
    private static _d_x_obj_copy_linlsqrstate _i_x_obj_copy_linlsqrstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_linlsqrstate(void *x);
    private static _d_x_obj_free_linlsqrstate _i_x_obj_free_linlsqrstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_linlsqrreport
    {
        public x_int iterationscount;
        public x_int nmv;
        public x_int terminationtype;
    }

    public class linlsqrreport : alglibobject
    {
        public int iterationscount;
        public int nmv;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            linlsqrreport dst = new linlsqrreport();
            dst.iterationscount = iterationscount;
            dst.nmv = nmv;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_linlsqrreport_init(ref x_linlsqrreport x)
    {
        x.iterationscount.longval = 0;
        x.nmv.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_linlsqrreport_clear(ref x_linlsqrreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_linlsqrreport_init_from(ref x_linlsqrreport x, linlsqrreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nmv.longval = v.nmv;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_linlsqrreport_to_record(ref x_linlsqrreport x, ref linlsqrreport v)
    {
        if( v==null )
            v = new linlsqrreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    private static unsafe void _core_linlsqrcreate(int m, int n, out linlsqrstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_linlsqrcreate(&_s_errormsg, &_d_m, &_d_n, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'linlsqrcreate' call");
            }
            state = new linlsqrstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_linlsqrstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void linlsqrcreate(int m, int n, out linlsqrstate state)
    {
    _core_linlsqrcreate( m,  n, out  state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_linlsqrsetprecunit(linlsqrstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_linlsqrsetprecunit(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'linlsqrsetprecunit' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void linlsqrsetprecunit(linlsqrstate state)
    {
    _core_linlsqrsetprecunit( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_linlsqrsetprecdiag(linlsqrstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_linlsqrsetprecdiag(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'linlsqrsetprecdiag' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void linlsqrsetprecdiag(linlsqrstate state)
    {
    _core_linlsqrsetprecdiag( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_linlsqrsetlambdai(linlsqrstate state, double lambdai, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_lambdai = lambdai;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_linlsqrsetlambdai(&_s_errormsg, &_d_state, &_d_lambdai);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'linlsqrsetlambdai' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void linlsqrsetlambdai(linlsqrstate state, double lambdai)
    {
    _core_linlsqrsetlambdai( state,  lambdai, alglibmode.serial);
    return;
    }
    private static unsafe void _core_linlsqrsolvesparse(linlsqrstate state, sparsematrix a, double[] b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_ser_linlsqrsolvesparse(&_s_errormsg, &_d_state, &_d_a, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'linlsqrsolvesparse' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void linlsqrsolvesparse(linlsqrstate state, sparsematrix a, double[] b)
    {
    _core_linlsqrsolvesparse( state,  a,  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_linlsqrsetcond(linlsqrstate state, double epsa, double epsb, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsa = epsa;
        double _d_epsb = epsb;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_linlsqrsetcond(&_s_errormsg, &_d_state, &_d_epsa, &_d_epsb, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'linlsqrsetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void linlsqrsetcond(linlsqrstate state, double epsa, double epsb, int maxits)
    {
    _core_linlsqrsetcond( state,  epsa,  epsb,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_linlsqrresults(linlsqrstate state, out double[] x, out linlsqrreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_linlsqrreport _d_rep = new x_linlsqrreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_linlsqrreport_init(ref _d_rep);
            _error_code = _i_ser_linlsqrresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'linlsqrresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_linlsqrreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_linlsqrreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void linlsqrresults(linlsqrstate state, out double[] x, out linlsqrreport rep)
    {
    _core_linlsqrresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_linlsqrsetxrep(linlsqrstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_linlsqrsetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'linlsqrsetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void linlsqrsetxrep(linlsqrstate state, bool needxrep)
    {
    _core_linlsqrsetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage rbf
    //
    

    public unsafe class rbfmodel : alglibobject
    {
        public void *ptr;
        public rbfmodel(void *x)
        {
            ptr = x;
        }
        ~rbfmodel()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new rbfmodel(null);
            return new rbfmodel(_i_x_obj_copy_rbfmodel(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_rbfmodel(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_rbfmodel(void *x);
    private static _d_x_obj_copy_rbfmodel _i_x_obj_copy_rbfmodel = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_rbfmodel(void *x);
    private static _d_x_obj_free_rbfmodel _i_x_obj_free_rbfmodel = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_rbfreport
    {
        public x_int arows;
        public x_int acols;
        public x_int annz;
        public x_int iterationscount;
        public x_int nmv;
        public x_int terminationtype;
    }

    public class rbfreport : alglibobject
    {
        public int arows;
        public int acols;
        public int annz;
        public int iterationscount;
        public int nmv;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            rbfreport dst = new rbfreport();
            dst.arows = arows;
            dst.acols = acols;
            dst.annz = annz;
            dst.iterationscount = iterationscount;
            dst.nmv = nmv;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_rbfreport_init(ref x_rbfreport x)
    {
        x.arows.longval = 0;
        x.acols.longval = 0;
        x.annz.longval = 0;
        x.iterationscount.longval = 0;
        x.nmv.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_rbfreport_clear(ref x_rbfreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_rbfreport_init_from(ref x_rbfreport x, rbfreport v)
    {
        x.arows.longval = v.arows;
        x.acols.longval = v.acols;
        x.annz.longval = v.annz;
        x.iterationscount.longval = v.iterationscount;
        x.nmv.longval = v.nmv;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_rbfreport_to_record(ref x_rbfreport x, ref rbfreport v)
    {
        if( v==null )
            v = new rbfreport();
        v.arows = x.arows.intval; // long is silently truncated to int
        v.acols = x.acols.intval; // long is silently truncated to int
        v.annz = x.annz.intval; // long is silently truncated to int
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    public static unsafe void rbfserialize(rbfmodel obj, out string s_out)
    {
        byte *_error_msg = null;
        byte *_out = null;
        void *_x = obj.ptr;
        int _error_code = _i_x_rbfserialize(&_error_msg, &_x, &_out);
        if( _error_code!=X_OK )
            throw new alglibexception(_error_code==X_ASSERTION_FAILED
                ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                : "ALGLIB: unknown error during rbfserialize() call");
        s_out = Marshal.PtrToStringAnsi((IntPtr)_out);
        x_free((IntPtr)_out);
    }
    
    public static unsafe void rbfunserialize(string s_in, out rbfmodel obj)
    {
        byte *_error_msg = null;
        byte[] _ain = System.Text.Encoding.UTF8.GetBytes(s_in);
        fixed(byte *_pin = _ain )
        {
            byte *_in = _pin;
            void *_x = null;
            int _error_code = _i_x_rbfunserialize(&_error_msg, &_in, &_x);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_error_msg)
                    : "ALGLIB: unknown error during rbfunserialize() call");
            obj = new rbfmodel(_x);
        }
    }
    private static unsafe void _core_rbfcreate(int nx, int ny, out rbfmodel s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_nx = new x_int(nx);
        x_int _d_ny = new x_int(ny);
        void *_d_s = null;
        s = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_rbfcreate(&_s_errormsg, &_d_nx, &_d_ny, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfcreate' call");
            }
            s = new rbfmodel(_d_s);
        }
        finally
        {
            if( _d_s!=null && s==null)
                _i_x_obj_free_rbfmodel(_d_s); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void rbfcreate(int nx, int ny, out rbfmodel s)
    {
    _core_rbfcreate( nx,  ny, out  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rbfsetpoints(rbfmodel s, double[,] xy, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_matrix _d_xy = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_xy = xy){
                x_matrix_attach_to_array(ref _d_xy, _fp_xy, ap.rows(xy), ap.cols(xy));
                _error_code = _i_ser_rbfsetpoints(&_s_errormsg, &_d_s, &_d_xy, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfsetpoints' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_xy);
        }
        // This function returns no value.
    }
    public static void rbfsetpoints(rbfmodel s, double[,] xy, int n)
    {
    _core_rbfsetpoints( s,  xy,  n, alglibmode.serial);
    return;
    }
    public static void rbfsetpoints(rbfmodel s, double[,] xy)
    {
    int n;
    
    
    n = ap.rows(xy);
    
    _core_rbfsetpoints( s,  xy,  n, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_rbfsetalgoqnn(rbfmodel s, double q, double z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_q = q;
        double _d_z = z;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_rbfsetalgoqnn(&_s_errormsg, &_d_s, &_d_q, &_d_z);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfsetalgoqnn' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void rbfsetalgoqnn(rbfmodel s, double q, double z)
    {
    _core_rbfsetalgoqnn( s,  q,  z, alglibmode.serial);
    return;
    }
    public static void rbfsetalgoqnn(rbfmodel s)
    {
    double q;
    double z;
    
    
    q = 1.0;
    z = 5.0;
    
    _core_rbfsetalgoqnn( s,  q,  z, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, double lambdav, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        double _d_rbase = rbase;
        x_int _d_nlayers = new x_int(nlayers);
        double _d_lambdav = lambdav;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_rbfsetalgomultilayer(&_s_errormsg, &_d_s, &_d_rbase, &_d_nlayers, &_d_lambdav);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfsetalgomultilayer' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers, double lambdav)
    {
    _core_rbfsetalgomultilayer( s,  rbase,  nlayers,  lambdav, alglibmode.serial);
    return;
    }
    public static void rbfsetalgomultilayer(rbfmodel s, double rbase, int nlayers)
    {
    double lambdav;
    
    
    lambdav = 0.01;
    
    _core_rbfsetalgomultilayer( s,  rbase,  nlayers,  lambdav, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_rbfsetlinterm(rbfmodel s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_rbfsetlinterm(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfsetlinterm' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void rbfsetlinterm(rbfmodel s)
    {
    _core_rbfsetlinterm( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rbfsetconstterm(rbfmodel s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_rbfsetconstterm(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfsetconstterm' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void rbfsetconstterm(rbfmodel s)
    {
    _core_rbfsetconstterm( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rbfsetzeroterm(rbfmodel s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_rbfsetzeroterm(&_s_errormsg, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfsetzeroterm' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void rbfsetzeroterm(rbfmodel s)
    {
    _core_rbfsetzeroterm( s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rbfbuildmodel(rbfmodel s, out rbfreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_rbfreport _d_rep = new x_rbfreport();
        
        // Pack, call, unpack
        try
        {
            x_rbfreport_init(ref _d_rep);
            _error_code = _i_ser_rbfbuildmodel(&_s_errormsg, &_d_s, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfbuildmodel' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            rep = null;
            x_rbfreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_rbfreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void rbfbuildmodel(rbfmodel s, out rbfreport rep)
    {
    _core_rbfbuildmodel( s, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe double _core_rbfcalc2(rbfmodel s, double x0, double x1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_x1 = x1;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_rbfcalc2(&_s_errormsg, &_d_result, &_d_s, &_d_x0, &_d_x1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfcalc2' call");
            }
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double rbfcalc2(rbfmodel s, double x0, double x1)
    {
    double result = _core_rbfcalc2( s,  x0,  x1, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_rbfcalc3(rbfmodel s, double x0, double x1, double x2, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_s = s.ptr;
        double _d_x0 = x0;
        double _d_x1 = x1;
        double _d_x2 = x2;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_rbfcalc3(&_s_errormsg, &_d_result, &_d_s, &_d_x0, &_d_x1, &_d_x2);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfcalc3' call");
            }
            result = _d_result;
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double rbfcalc3(rbfmodel s, double x0, double x1, double x2)
    {
    double result = _core_rbfcalc3( s,  x0,  x1,  x2, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_rbfcalc(rbfmodel s, double[] x, out double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_ser_rbfcalc(&_s_errormsg, &_d_s, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfcalc' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void rbfcalc(rbfmodel s, double[] x, out double[] y)
    {
    _core_rbfcalc( s,  x, out  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rbfcalcbuf(rbfmodel s, double[] x, ref double[] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_rbfcalcbuf(&_s_errormsg, &_d_s, &_d_x, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfcalcbuf' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void rbfcalcbuf(rbfmodel s, double[] x, ref double[] y)
    {
    _core_rbfcalcbuf( s,  x, ref  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rbfgridcalc2(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[,] y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_vector _d_x0 = new x_vector();
        x_int _d_n0 = new x_int(n0);
        x_vector _d_x1 = new x_vector();
        x_int _d_n1 = new x_int(n1);
        x_matrix _d_y = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x0 = x0, _fp_x1 = x1){
                x_vector_attach_to_array(ref _d_x0, _fp_x0, ap.len(x0));
                x_vector_attach_to_array(ref _d_x1, _fp_x1, ap.len(x1));
                x_matrix_create_empty(ref _d_y, DT_REAL);
                y = null;
                _error_code = _i_ser_rbfgridcalc2(&_s_errormsg, &_d_s, &_d_x0, &_d_n0, &_d_x1, &_d_n1, &_d_y);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfgridcalc2' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_y.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_y, ref y);
            if( y == null )
                y = new double[0,0];
        }
        finally
        {
            x_vector_clear(ref _d_x0);
            x_vector_clear(ref _d_x1);
            x_matrix_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void rbfgridcalc2(rbfmodel s, double[] x0, int n0, double[] x1, int n1, out double[,] y)
    {
    _core_rbfgridcalc2( s,  x0,  n0,  x1,  n1, out  y, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rbfunpack(rbfmodel s, out int nx, out int ny, out double[,] xwr, out int nc, out double[,] v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_s = s.ptr;
        x_int _d_nx = new x_int();
        x_int _d_ny = new x_int();
        x_matrix _d_xwr = new x_matrix();
        x_int _d_nc = new x_int();
        x_matrix _d_v = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_xwr, DT_REAL);
            xwr = null;
            x_matrix_create_empty(ref _d_v, DT_REAL);
            v = null;
            _error_code = _i_ser_rbfunpack(&_s_errormsg, &_d_s, &_d_nx, &_d_ny, &_d_xwr, &_d_nc, &_d_v);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rbfunpack' call");
            }
            ap.assert(s.ptr==_d_s, "ALGLIB: internal error (reference changed for non-out X-object)");
            nx = _d_nx.intval;
            ny = _d_ny.intval;
            if( _d_xwr.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_xwr, ref xwr);
            if( xwr == null )
                xwr = new double[0,0];
            nc = _d_nc.intval;
            if( _d_v.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_v, ref v);
            if( v == null )
                v = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_xwr);
            x_matrix_clear(ref _d_v);
        }
        // This function returns no value.
    }
    public static void rbfunpack(rbfmodel s, out int nx, out int ny, out double[,] xwr, out int nc, out double[,] v)
    {
    _core_rbfunpack( s, out  nx, out  ny, out  xwr, out  nc, out  v, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage spline2d
    //
    

    public unsafe class spline2dinterpolant : alglibobject
    {
        public void *ptr;
        public spline2dinterpolant(void *x)
        {
            ptr = x;
        }
        ~spline2dinterpolant()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new spline2dinterpolant(null);
            return new spline2dinterpolant(_i_x_obj_copy_spline2dinterpolant(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_spline2dinterpolant(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_spline2dinterpolant(void *x);
    private static _d_x_obj_copy_spline2dinterpolant _i_x_obj_copy_spline2dinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_spline2dinterpolant(void *x);
    private static _d_x_obj_free_spline2dinterpolant _i_x_obj_free_spline2dinterpolant = null;
    private static unsafe double _core_spline2dcalc(spline2dinterpolant c, double x, double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline2dcalc(&_s_errormsg, &_d_result, &_d_c, &_d_x, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dcalc' call");
            }
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double spline2dcalc(spline2dinterpolant c, double x, double y)
    {
    double result = _core_spline2dcalc( c,  x,  y, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_spline2ddiff(spline2dinterpolant c, double x, double y, out double f, out double fx, out double fy, out double fxy, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        double _d_f = 0;
        double _d_fx = 0;
        double _d_fy = 0;
        double _d_fxy = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline2ddiff(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_f, &_d_fx, &_d_fy, &_d_fxy);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2ddiff' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            f = _d_f;
            fx = _d_fx;
            fy = _d_fy;
            fxy = _d_fxy;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spline2ddiff(spline2dinterpolant c, double x, double y, out double f, out double fx, out double fy, out double fxy)
    {
    _core_spline2ddiff( c,  x,  y, out  f, out  fx, out  fy, out  fxy, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dlintransxy(spline2dinterpolant c, double ax, double bx, double ay, double by, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_ax = ax;
        double _d_bx = bx;
        double _d_ay = ay;
        double _d_by = by;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline2dlintransxy(&_s_errormsg, &_d_c, &_d_ax, &_d_bx, &_d_ay, &_d_by);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dlintransxy' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spline2dlintransxy(spline2dinterpolant c, double ax, double bx, double ay, double by)
    {
    _core_spline2dlintransxy( c,  ax,  bx,  ay,  by, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dlintransf(spline2dinterpolant c, double a, double b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline2dlintransf(&_s_errormsg, &_d_c, &_d_a, &_d_b);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dlintransf' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spline2dlintransf(spline2dinterpolant c, double a, double b)
    {
    _core_spline2dlintransf( c,  a,  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dcopy(spline2dinterpolant c, out spline2dinterpolant cc, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        void *_d_cc = null;
        cc = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline2dcopy(&_s_errormsg, &_d_c, &_d_cc);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dcopy' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            cc = new spline2dinterpolant(_d_cc);
        }
        finally
        {
            if( _d_cc!=null && cc==null)
                _i_x_obj_free_spline2dinterpolant(_d_cc); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline2dcopy(spline2dinterpolant c, out spline2dinterpolant cc)
    {
    _core_spline2dcopy( c, out  cc, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dresamplebicubic(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_oldheight = new x_int(oldheight);
        x_int _d_oldwidth = new x_int(oldwidth);
        x_matrix _d_b = new x_matrix();
        x_int _d_newheight = new x_int(newheight);
        x_int _d_newwidth = new x_int(newwidth);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_b, DT_REAL);
                b = null;
                _error_code = _i_ser_spline2dresamplebicubic(&_s_errormsg, &_d_a, &_d_oldheight, &_d_oldwidth, &_d_b, &_d_newheight, &_d_newwidth);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dresamplebicubic' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void spline2dresamplebicubic(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth)
    {
    _core_spline2dresamplebicubic( a,  oldheight,  oldwidth, out  b,  newheight,  newwidth, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dresamplebilinear(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_oldheight = new x_int(oldheight);
        x_int _d_oldwidth = new x_int(oldwidth);
        x_matrix _d_b = new x_matrix();
        x_int _d_newheight = new x_int(newheight);
        x_int _d_newwidth = new x_int(newwidth);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_b, DT_REAL);
                b = null;
                _error_code = _i_ser_spline2dresamplebilinear(&_s_errormsg, &_d_a, &_d_oldheight, &_d_oldwidth, &_d_b, &_d_newheight, &_d_newwidth);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dresamplebilinear' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void spline2dresamplebilinear(double[,] a, int oldheight, int oldwidth, out double[,] b, int newheight, int newwidth)
    {
    _core_spline2dresamplebilinear( a,  oldheight,  oldwidth, out  b,  newheight,  newwidth, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dbuildbilinearv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_f = new x_vector();
        x_int _d_d = new x_int(d);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_ser_spline2dbuildbilinearv(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_f, &_d_d, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dbuildbilinearv' call");
            }
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline2dbuildbilinearv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c)
    {
    _core_spline2dbuildbilinearv( x,  n,  y,  m,  f,  d, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dbuildbicubicv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_f = new x_vector();
        x_int _d_d = new x_int(d);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_ser_spline2dbuildbicubicv(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_f, &_d_d, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dbuildbicubicv' call");
            }
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline2dbuildbicubicv(double[] x, int n, double[] y, int m, double[] f, int d, out spline2dinterpolant c)
    {
    _core_spline2dbuildbicubicv( x,  n,  y,  m,  f,  d, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dcalcvbuf(spline2dinterpolant c, double x, double y, ref double[] f, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_ser_spline2dcalcvbuf(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_f);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dcalcvbuf' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    public static void spline2dcalcvbuf(spline2dinterpolant c, double x, double y, ref double[] f)
    {
    _core_spline2dcalcvbuf( c,  x,  y, ref  f, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dcalcv(spline2dinterpolant c, double x, double y, out double[] f, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_f, DT_REAL);
            f = null;
            _error_code = _i_ser_spline2dcalcv(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_f);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dcalcv' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    public static void spline2dcalcv(spline2dinterpolant c, double x, double y, out double[] f)
    {
    _core_spline2dcalcv( c,  x,  y, out  f, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dunpackv(spline2dinterpolant c, out int m, out int n, out int d, out double[,] tbl, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        x_int _d_m = new x_int();
        x_int _d_n = new x_int();
        x_int _d_d = new x_int();
        x_matrix _d_tbl = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_tbl, DT_REAL);
            tbl = null;
            _error_code = _i_ser_spline2dunpackv(&_s_errormsg, &_d_c, &_d_m, &_d_n, &_d_d, &_d_tbl);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dunpackv' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            m = _d_m.intval;
            n = _d_n.intval;
            d = _d_d.intval;
            if( _d_tbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_tbl, ref tbl);
            if( tbl == null )
                tbl = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_tbl);
        }
        // This function returns no value.
    }
    public static void spline2dunpackv(spline2dinterpolant c, out int m, out int n, out int d, out double[,] tbl)
    {
    _core_spline2dunpackv( c, out  m, out  n, out  d, out  tbl, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dbuildbilinear(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_matrix _d_f = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_matrix_attach_to_array(ref _d_f, _fp_f, ap.rows(f), ap.cols(f));
                _error_code = _i_ser_spline2dbuildbilinear(&_s_errormsg, &_d_x, &_d_y, &_d_f, &_d_m, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dbuildbilinear' call");
            }
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_matrix_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline2dbuildbilinear(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c)
    {
    _core_spline2dbuildbilinear( x,  y,  f,  m,  n, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dbuildbicubic(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_vector _d_y = new x_vector();
        x_matrix _d_f = new x_matrix();
        x_int _d_m = new x_int(m);
        x_int _d_n = new x_int(n);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_matrix_attach_to_array(ref _d_f, _fp_f, ap.rows(f), ap.cols(f));
                _error_code = _i_ser_spline2dbuildbicubic(&_s_errormsg, &_d_x, &_d_y, &_d_f, &_d_m, &_d_n, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dbuildbicubic' call");
            }
            c = new spline2dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_matrix_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline2dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline2dbuildbicubic(double[] x, double[] y, double[,] f, int m, int n, out spline2dinterpolant c)
    {
    _core_spline2dbuildbicubic( x,  y,  f,  m,  n, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline2dunpack(spline2dinterpolant c, out int m, out int n, out double[,] tbl, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        x_int _d_m = new x_int();
        x_int _d_n = new x_int();
        x_matrix _d_tbl = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_tbl, DT_REAL);
            tbl = null;
            _error_code = _i_ser_spline2dunpack(&_s_errormsg, &_d_c, &_d_m, &_d_n, &_d_tbl);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline2dunpack' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            m = _d_m.intval;
            n = _d_n.intval;
            if( _d_tbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_tbl, ref tbl);
            if( tbl == null )
                tbl = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_tbl);
        }
        // This function returns no value.
    }
    public static void spline2dunpack(spline2dinterpolant c, out int m, out int n, out double[,] tbl)
    {
    _core_spline2dunpack( c, out  m, out  n, out  tbl, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage spline3d
    //
    

    public unsafe class spline3dinterpolant : alglibobject
    {
        public void *ptr;
        public spline3dinterpolant(void *x)
        {
            ptr = x;
        }
        ~spline3dinterpolant()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new spline3dinterpolant(null);
            return new spline3dinterpolant(_i_x_obj_copy_spline3dinterpolant(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_spline3dinterpolant(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_spline3dinterpolant(void *x);
    private static _d_x_obj_copy_spline3dinterpolant _i_x_obj_copy_spline3dinterpolant = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_spline3dinterpolant(void *x);
    private static _d_x_obj_free_spline3dinterpolant _i_x_obj_free_spline3dinterpolant = null;
    private static unsafe double _core_spline3dcalc(spline3dinterpolant c, double x, double y, double z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        double _d_z = z;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline3dcalc(&_s_errormsg, &_d_result, &_d_c, &_d_x, &_d_y, &_d_z);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline3dcalc' call");
            }
            result = _d_result;
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double spline3dcalc(spline3dinterpolant c, double x, double y, double z)
    {
    double result = _core_spline3dcalc( c,  x,  y,  z, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_spline3dlintransxyz(spline3dinterpolant c, double ax, double bx, double ay, double by, double az, double bz, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_ax = ax;
        double _d_bx = bx;
        double _d_ay = ay;
        double _d_by = by;
        double _d_az = az;
        double _d_bz = bz;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline3dlintransxyz(&_s_errormsg, &_d_c, &_d_ax, &_d_bx, &_d_ay, &_d_by, &_d_az, &_d_bz);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline3dlintransxyz' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spline3dlintransxyz(spline3dinterpolant c, double ax, double bx, double ay, double by, double az, double bz)
    {
    _core_spline3dlintransxyz( c,  ax,  bx,  ay,  by,  az,  bz, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline3dlintransf(spline3dinterpolant c, double a, double b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spline3dlintransf(&_s_errormsg, &_d_c, &_d_a, &_d_b);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline3dlintransf' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spline3dlintransf(spline3dinterpolant c, double a, double b)
    {
    _core_spline3dlintransf( c,  a,  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline3dresampletrilinear(double[] a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, out double[] b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_oldzcount = new x_int(oldzcount);
        x_int _d_oldycount = new x_int(oldycount);
        x_int _d_oldxcount = new x_int(oldxcount);
        x_int _d_newzcount = new x_int(newzcount);
        x_int _d_newycount = new x_int(newycount);
        x_int _d_newxcount = new x_int(newxcount);
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_create_empty(ref _d_b, DT_REAL);
                b = null;
                _error_code = _i_ser_spline3dresampletrilinear(&_s_errormsg, &_d_a, &_d_oldzcount, &_d_oldycount, &_d_oldxcount, &_d_newzcount, &_d_newycount, &_d_newxcount, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline3dresampletrilinear' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void spline3dresampletrilinear(double[] a, int oldzcount, int oldycount, int oldxcount, int newzcount, int newycount, int newxcount, out double[] b)
    {
    _core_spline3dresampletrilinear( a,  oldzcount,  oldycount,  oldxcount,  newzcount,  newycount,  newxcount, out  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline3dbuildtrilinearv(double[] x, int n, double[] y, int m, double[] z, int l, double[] f, int d, out spline3dinterpolant c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        x_vector _d_z = new x_vector();
        x_int _d_l = new x_int(l);
        x_vector _d_f = new x_vector();
        x_int _d_d = new x_int(d);
        void *_d_c = null;
        c = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y, _fp_z = z, _fp_f = f){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                x_vector_attach_to_array(ref _d_z, _fp_z, ap.len(z));
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_ser_spline3dbuildtrilinearv(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_z, &_d_l, &_d_f, &_d_d, &_d_c);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline3dbuildtrilinearv' call");
            }
            c = new spline3dinterpolant(_d_c);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
            x_vector_clear(ref _d_z);
            x_vector_clear(ref _d_f);
            if( _d_c!=null && c==null)
                _i_x_obj_free_spline3dinterpolant(_d_c); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void spline3dbuildtrilinearv(double[] x, int n, double[] y, int m, double[] z, int l, double[] f, int d, out spline3dinterpolant c)
    {
    _core_spline3dbuildtrilinearv( x,  n,  y,  m,  z,  l,  f,  d, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline3dcalcvbuf(spline3dinterpolant c, double x, double y, double z, ref double[] f, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        double _d_z = z;
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_f = f){
                x_vector_attach_to_array(ref _d_f, _fp_f, ap.len(f));
                _error_code = _i_ser_spline3dcalcvbuf(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_z, &_d_f);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline3dcalcvbuf' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    public static void spline3dcalcvbuf(spline3dinterpolant c, double x, double y, double z, ref double[] f)
    {
    _core_spline3dcalcvbuf( c,  x,  y,  z, ref  f, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline3dcalcv(spline3dinterpolant c, double x, double y, double z, out double[] f, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        double _d_x = x;
        double _d_y = y;
        double _d_z = z;
        x_vector _d_f = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_f, DT_REAL);
            f = null;
            _error_code = _i_ser_spline3dcalcv(&_s_errormsg, &_d_c, &_d_x, &_d_y, &_d_z, &_d_f);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline3dcalcv' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_f.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_f, ref f);
            if( f == null )
                f = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_f);
        }
        // This function returns no value.
    }
    public static void spline3dcalcv(spline3dinterpolant c, double x, double y, double z, out double[] f)
    {
    _core_spline3dcalcv( c,  x,  y,  z, out  f, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spline3dunpackv(spline3dinterpolant c, out int n, out int m, out int l, out int d, out int stype, out double[,] tbl, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_c = c.ptr;
        x_int _d_n = new x_int();
        x_int _d_m = new x_int();
        x_int _d_l = new x_int();
        x_int _d_d = new x_int();
        x_int _d_stype = new x_int();
        x_matrix _d_tbl = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            x_matrix_create_empty(ref _d_tbl, DT_REAL);
            tbl = null;
            _error_code = _i_ser_spline3dunpackv(&_s_errormsg, &_d_c, &_d_n, &_d_m, &_d_l, &_d_d, &_d_stype, &_d_tbl);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spline3dunpackv' call");
            }
            ap.assert(c.ptr==_d_c, "ALGLIB: internal error (reference changed for non-out X-object)");
            n = _d_n.intval;
            m = _d_m.intval;
            l = _d_l.intval;
            d = _d_d.intval;
            stype = _d_stype.intval;
            if( _d_tbl.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_tbl, ref tbl);
            if( tbl == null )
                tbl = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_tbl);
        }
        // This function returns no value.
    }
    public static void spline3dunpackv(spline3dinterpolant c, out int n, out int m, out int l, out int d, out int stype, out double[,] tbl)
    {
    _core_spline3dunpackv( c, out  n, out  m, out  l, out  d, out  stype, out  tbl, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage matdet
    //
    
    private static unsafe double _core_rmatrixludet(double[,] a, int[] pivots, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_vector _d_pivots = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_pivots, pivots, X_CREATE);
                _error_code = _i_ser_rmatrixludet(&_s_errormsg, &_d_result, &_d_a, &_d_pivots, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixludet' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
        }
        return result;
    }
    public static double rmatrixludet(double[,] a, int[] pivots, int n)
    {
    double result = _core_rmatrixludet( a,  pivots,  n, alglibmode.serial);
    return result;
    }
    public static double rmatrixludet(double[,] a, int[] pivots)
    {
    int n;
    
    if( (ap.rows(a)!=ap.cols(a)) || (ap.rows(a)!=ap.len(pivots)))
        throw new alglibexception("Error while calling 'rmatrixludet': looks like one of arguments has wrong size");
    
    n = ap.rows(a);
    
    double result = _core_rmatrixludet( a,  pivots,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_rmatrixdet(double[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_rmatrixdet(&_s_errormsg, &_d_result, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixdet' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double rmatrixdet(double[,] a, int n)
    {
    double result = _core_rmatrixdet( a,  n, alglibmode.serial);
    return result;
    }
    public static double rmatrixdet(double[,] a)
    {
    int n;
    
    if( (ap.rows(a)!=ap.cols(a)))
        throw new alglibexception("Error while calling 'rmatrixdet': looks like one of arguments has wrong size");
    
    n = ap.rows(a);
    
    double result = _core_rmatrixdet( a,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe complex _core_cmatrixludet(complex[,] a, int[] pivots, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        alglib.complex result;
        alglib.complex _d_result;
        x_matrix _d_a = new x_matrix();
        x_vector _d_pivots = new x_vector();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                _d_result.x = 0;
                _d_result.y = 0;
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_vector_from_array(ref _d_pivots, pivots, X_CREATE);
                _error_code = _i_ser_cmatrixludet(&_s_errormsg, &_d_result, &_d_a, &_d_pivots, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixludet' call");
            }
            result.x = _d_result.x;
            result.y = _d_result.y;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_vector_clear(ref _d_pivots);
        }
        return result;
    }
    public static alglib.complex cmatrixludet(complex[,] a, int[] pivots, int n)
    {
    alglib.complex result = _core_cmatrixludet( a,  pivots,  n, alglibmode.serial);
    return result;
    }
    public static alglib.complex cmatrixludet(complex[,] a, int[] pivots)
    {
    int n;
    
    if( (ap.rows(a)!=ap.cols(a)) || (ap.rows(a)!=ap.len(pivots)))
        throw new alglibexception("Error while calling 'cmatrixludet': looks like one of arguments has wrong size");
    
    n = ap.rows(a);
    
    alglib.complex result = _core_cmatrixludet( a,  pivots,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe complex _core_cmatrixdet(complex[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        alglib.complex result;
        alglib.complex _d_result;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(alglib.complex* _fp_a = a){
                _d_result.x = 0;
                _d_result.y = 0;
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_cmatrixdet(&_s_errormsg, &_d_result, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'cmatrixdet' call");
            }
            result.x = _d_result.x;
            result.y = _d_result.y;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static alglib.complex cmatrixdet(complex[,] a, int n)
    {
    alglib.complex result = _core_cmatrixdet( a,  n, alglibmode.serial);
    return result;
    }
    public static alglib.complex cmatrixdet(complex[,] a)
    {
    int n;
    
    if( (ap.rows(a)!=ap.cols(a)))
        throw new alglibexception("Error while calling 'cmatrixdet': looks like one of arguments has wrong size");
    
    n = ap.rows(a);
    
    alglib.complex result = _core_cmatrixdet( a,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_spdmatrixcholeskydet(double[,] a, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_spdmatrixcholeskydet(&_s_errormsg, &_d_result, &_d_a, &_d_n);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixcholeskydet' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double spdmatrixcholeskydet(double[,] a, int n)
    {
    double result = _core_spdmatrixcholeskydet( a,  n, alglibmode.serial);
    return result;
    }
    public static double spdmatrixcholeskydet(double[,] a)
    {
    int n;
    
    if( (ap.rows(a)!=ap.cols(a)))
        throw new alglibexception("Error while calling 'spdmatrixcholeskydet': looks like one of arguments has wrong size");
    
    n = ap.rows(a);
    
    double result = _core_spdmatrixcholeskydet( a,  n, alglibmode.serial);
    
    return result;
    }
    private static unsafe double _core_spdmatrixdet(double[,] a, int n, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                _error_code = _i_ser_spdmatrixdet(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spdmatrixdet' call");
            }
            result = _d_result;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
        }
        return result;
    }
    public static double spdmatrixdet(double[,] a, int n, bool isupper)
    {
    double result = _core_spdmatrixdet( a,  n,  isupper, alglibmode.serial);
    return result;
    }
    public static double spdmatrixdet(double[,] a)
    {
    int n;
    bool isupper;
    
    if( !alglib.ap.issymmetric(a) )
        throw new alglibexception("'a' parameter is not symmetric matrix");
    if( (ap.rows(a)!=ap.cols(a)))
        throw new alglibexception("Error while calling 'spdmatrixdet': looks like one of arguments has wrong size");
    
    n = ap.rows(a);
    isupper = false;
    
    double result = _core_spdmatrixdet( a,  n,  isupper, alglibmode.serial);
    
    return result;
    }
    
    
    //
    // Subpackage spdgevd
    //
    
    private static unsafe bool _core_smatrixgevd(double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int zneeded, int problemtype, out double[] d, out double[,] z, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isuppera = (byte)(isuppera ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        byte _d_isupperb = (byte)(isupperb ? 1 : 0);
        x_int _d_zneeded = new x_int(zneeded);
        x_int _d_problemtype = new x_int(problemtype);
        x_vector _d_d = new x_vector();
        x_matrix _d_z = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_vector_create_empty(ref _d_d, DT_REAL);
                d = null;
                x_matrix_create_empty(ref _d_z, DT_REAL);
                z = null;
                _error_code = _i_ser_smatrixgevd(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isuppera, &_d_b, &_d_isupperb, &_d_zneeded, &_d_problemtype, &_d_d, &_d_z);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixgevd' call");
            }
            result = _d_result!=0;
            if( _d_d.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_d, ref d);
            if( d == null )
                d = new double[0];
            if( _d_z.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_z, ref z);
            if( z == null )
                z = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_vector_clear(ref _d_d);
            x_matrix_clear(ref _d_z);
        }
        return result;
    }
    public static bool smatrixgevd(double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int zneeded, int problemtype, out double[] d, out double[,] z)
    {
    bool result = _core_smatrixgevd( a,  n,  isuppera,  b,  isupperb,  zneeded,  problemtype, out  d, out  z, alglibmode.serial);
    return result;
    }
    private static unsafe bool _core_smatrixgevdreduce(ref double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int problemtype, out double[,] r, out bool isupperr, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        byte _d_isuppera = (byte)(isuppera ? 1 : 0);
        x_matrix _d_b = new x_matrix();
        byte _d_isupperb = (byte)(isupperb ? 1 : 0);
        x_int _d_problemtype = new x_int(problemtype);
        x_matrix _d_r = new x_matrix();
        byte _d_isupperr = (byte)0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a, _fp_b = b){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_attach_to_array(ref _d_b, _fp_b, ap.rows(b), ap.cols(b));
                x_matrix_create_empty(ref _d_r, DT_REAL);
                r = null;
                _error_code = _i_ser_smatrixgevdreduce(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_isuppera, &_d_b, &_d_isupperb, &_d_problemtype, &_d_r, &_d_isupperr);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'smatrixgevdreduce' call");
            }
            result = _d_result!=0;
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_r.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_r, ref r);
            if( r == null )
                r = new double[0,0];
            isupperr = _d_isupperr!=0;
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_b);
            x_matrix_clear(ref _d_r);
        }
        return result;
    }
    public static bool smatrixgevdreduce(ref double[,] a, int n, bool isuppera, double[,] b, bool isupperb, int problemtype, out double[,] r, out bool isupperr)
    {
    bool result = _core_smatrixgevdreduce(ref  a,  n,  isuppera,  b,  isupperb,  problemtype, out  r, out  isupperr, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage inverseupdate
    //
    
    private static unsafe void _core_rmatrixinvupdatesimple(ref double[,] inva, int n, int updrow, int updcolumn, double updval, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_inva = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_updrow = new x_int(updrow);
        x_int _d_updcolumn = new x_int(updcolumn);
        double _d_updval = updval;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_inva = inva){
                x_matrix_attach_to_array(ref _d_inva, _fp_inva, ap.rows(inva), ap.cols(inva));
                _error_code = _i_ser_rmatrixinvupdatesimple(&_s_errormsg, &_d_inva, &_d_n, &_d_updrow, &_d_updcolumn, &_d_updval);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixinvupdatesimple' call");
            }
            if( _d_inva.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_inva, ref inva);
            if( inva == null )
                inva = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_inva);
        }
        // This function returns no value.
    }
    public static void rmatrixinvupdatesimple(ref double[,] inva, int n, int updrow, int updcolumn, double updval)
    {
    _core_rmatrixinvupdatesimple(ref  inva,  n,  updrow,  updcolumn,  updval, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixinvupdaterow(ref double[,] inva, int n, int updrow, double[] v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_inva = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_updrow = new x_int(updrow);
        x_vector _d_v = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_inva = inva, _fp_v = v){
                x_matrix_attach_to_array(ref _d_inva, _fp_inva, ap.rows(inva), ap.cols(inva));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_ser_rmatrixinvupdaterow(&_s_errormsg, &_d_inva, &_d_n, &_d_updrow, &_d_v);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixinvupdaterow' call");
            }
            if( _d_inva.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_inva, ref inva);
            if( inva == null )
                inva = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_inva);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    public static void rmatrixinvupdaterow(ref double[,] inva, int n, int updrow, double[] v)
    {
    _core_rmatrixinvupdaterow(ref  inva,  n,  updrow,  v, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixinvupdatecolumn(ref double[,] inva, int n, int updcolumn, double[] u, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_inva = new x_matrix();
        x_int _d_n = new x_int(n);
        x_int _d_updcolumn = new x_int(updcolumn);
        x_vector _d_u = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_inva = inva, _fp_u = u){
                x_matrix_attach_to_array(ref _d_inva, _fp_inva, ap.rows(inva), ap.cols(inva));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                _error_code = _i_ser_rmatrixinvupdatecolumn(&_s_errormsg, &_d_inva, &_d_n, &_d_updcolumn, &_d_u);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixinvupdatecolumn' call");
            }
            if( _d_inva.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_inva, ref inva);
            if( inva == null )
                inva = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_inva);
            x_vector_clear(ref _d_u);
        }
        // This function returns no value.
    }
    public static void rmatrixinvupdatecolumn(ref double[,] inva, int n, int updcolumn, double[] u)
    {
    _core_rmatrixinvupdatecolumn(ref  inva,  n,  updcolumn,  u, alglibmode.serial);
    return;
    }
    private static unsafe void _core_rmatrixinvupdateuv(ref double[,] inva, int n, double[] u, double[] v, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_matrix _d_inva = new x_matrix();
        x_int _d_n = new x_int(n);
        x_vector _d_u = new x_vector();
        x_vector _d_v = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_inva = inva, _fp_u = u, _fp_v = v){
                x_matrix_attach_to_array(ref _d_inva, _fp_inva, ap.rows(inva), ap.cols(inva));
                x_vector_attach_to_array(ref _d_u, _fp_u, ap.len(u));
                x_vector_attach_to_array(ref _d_v, _fp_v, ap.len(v));
                _error_code = _i_ser_rmatrixinvupdateuv(&_s_errormsg, &_d_inva, &_d_n, &_d_u, &_d_v);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixinvupdateuv' call");
            }
            if( _d_inva.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_inva, ref inva);
            if( inva == null )
                inva = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_inva);
            x_vector_clear(ref _d_u);
            x_vector_clear(ref _d_v);
        }
        // This function returns no value.
    }
    public static void rmatrixinvupdateuv(ref double[,] inva, int n, double[] u, double[] v)
    {
    _core_rmatrixinvupdateuv(ref  inva,  n,  u,  v, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage schur
    //
    
    private static unsafe bool _core_rmatrixschur(ref double[,] a, int n, out double[,] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        x_matrix _d_a = new x_matrix();
        x_int _d_n = new x_int(n);
        x_matrix _d_s = new x_matrix();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_matrix_attach_to_array(ref _d_a, _fp_a, ap.rows(a), ap.cols(a));
                x_matrix_create_empty(ref _d_s, DT_REAL);
                s = null;
                _error_code = _i_ser_rmatrixschur(&_s_errormsg, &_d_result, &_d_a, &_d_n, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'rmatrixschur' call");
            }
            result = _d_result!=0;
            if( _d_a.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_a, ref a);
            if( a == null )
                a = new double[0,0];
            if( _d_s.last_action==ACT_NEW_LOCATION )
                x_matrix_to_array(ref _d_s, ref s);
            if( s == null )
                s = new double[0,0];
        }
        finally
        {
            x_matrix_clear(ref _d_a);
            x_matrix_clear(ref _d_s);
        }
        return result;
    }
    public static bool rmatrixschur(ref double[,] a, int n, out double[,] s)
    {
    bool result = _core_rmatrixschur(ref  a,  n, out  s, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage mincomp
    //
    

    public unsafe class minasastate : alglibobject
    {
        public void *ptr;
        public minasastate(void *x)
        {
            ptr = x;
        }
        ~minasastate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new minasastate(null);
            return new minasastate(_i_x_obj_copy_minasastate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_minasastate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minasastate(void *x);
    private static _d_x_obj_copy_minasastate _i_x_obj_copy_minasastate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_minasastate(void *x);
    private static _d_x_obj_free_minasastate _i_x_obj_free_minasastate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minasastate_get_needfg(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minasastate_set_needfg(void *x, byte *dst);
    private static _d_x_minasastate_get_needfg _i_x_minasastate_get_needfg = null;
    private static _d_x_minasastate_set_needfg _i_x_minasastate_set_needfg = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minasastate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minasastate_set_xupdated(void *x, byte *dst);
    private static _d_x_minasastate_get_xupdated _i_x_minasastate_get_xupdated = null;
    private static _d_x_minasastate_set_xupdated _i_x_minasastate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minasastate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minasastate_set_f(void *x, double *dst);
    private static _d_x_minasastate_get_f _i_x_minasastate_get_f = null;
    private static _d_x_minasastate_set_f _i_x_minasastate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minasastate_get_g(void *x, x_vector *dst);
    private static _d_x_minasastate_get_g _i_x_minasastate_get_g = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minasastate_get_x(void *x, x_vector *dst);
    private static _d_x_minasastate_get_x _i_x_minasastate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minasareport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int terminationtype;
        public x_int activeconstraints;
    }

    public class minasareport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int terminationtype;
        public int activeconstraints;
        public override alglib.alglibobject make_copy()
        {
            minasareport dst = new minasareport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.terminationtype = terminationtype;
            dst.activeconstraints = activeconstraints;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minasareport_init(ref x_minasareport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.terminationtype.longval = 0;
        x.activeconstraints.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minasareport_clear(ref x_minasareport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minasareport_init_from(ref x_minasareport x, minasareport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.terminationtype.longval = v.terminationtype;
        x.activeconstraints.longval = v.activeconstraints;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minasareport_to_record(ref x_minasareport x, ref minasareport v)
    {
        if( v==null )
            v = new minasareport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.activeconstraints = x.activeconstraints.intval; // long is silently truncated to int
    }
    private static unsafe void _core_minlbfgssetdefaultpreconditioner(minlbfgsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minlbfgssetdefaultpreconditioner(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetdefaultpreconditioner' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minlbfgssetdefaultpreconditioner(minlbfgsstate state)
    {
    _core_minlbfgssetdefaultpreconditioner( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minlbfgssetcholeskypreconditioner(minlbfgsstate state, double[,] p, bool isupper, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_p = new x_matrix();
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_p = p){
                x_matrix_attach_to_array(ref _d_p, _fp_p, ap.rows(p), ap.cols(p));
                _error_code = _i_ser_minlbfgssetcholeskypreconditioner(&_s_errormsg, &_d_state, &_d_p, &_d_isupper);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minlbfgssetcholeskypreconditioner' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_p);
        }
        // This function returns no value.
    }
    public static void minlbfgssetcholeskypreconditioner(minlbfgsstate state, double[,] p, bool isupper)
    {
    _core_minlbfgssetcholeskypreconditioner( state,  p,  isupper, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetbarrierwidth(minbleicstate state, double mu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_mu = mu;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicsetbarrierwidth(&_s_errormsg, &_d_state, &_d_mu);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetbarrierwidth' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicsetbarrierwidth(minbleicstate state, double mu)
    {
    _core_minbleicsetbarrierwidth( state,  mu, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minbleicsetbarrierdecay(minbleicstate state, double mudecay, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_mudecay = mudecay;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minbleicsetbarrierdecay(&_s_errormsg, &_d_state, &_d_mudecay);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minbleicsetbarrierdecay' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minbleicsetbarrierdecay(minbleicstate state, double mudecay)
    {
    _core_minbleicsetbarrierdecay( state,  mudecay, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minasacreate(int n, double[] x, double[] bndl, double[] bndu, out minasastate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_ser_minasacreate(&_s_errormsg, &_d_n, &_d_x, &_d_bndl, &_d_bndu, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasacreate' call");
            }
            state = new minasastate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minasastate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minasacreate(int n, double[] x, double[] bndl, double[] bndu, out minasastate state)
    {
    _core_minasacreate( n,  x,  bndl,  bndu, out  state, alglibmode.serial);
    return;
    }
    public static void minasacreate(double[] x, double[] bndl, double[] bndu, out minasastate state)
    {
    int n;
    
    if( (ap.len(x)!=ap.len(bndl)) || (ap.len(x)!=ap.len(bndu)))
        throw new alglibexception("Error while calling 'minasacreate': looks like one of arguments has wrong size");
    
    n = ap.len(x);
    
    _core_minasacreate( n,  x,  bndl,  bndu, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minasasetcond(minasastate state, double epsg, double epsf, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minasasetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasasetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minasasetcond(minasastate state, double epsg, double epsf, double epsx, int maxits)
    {
    _core_minasasetcond( state,  epsg,  epsf,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minasasetxrep(minasastate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minasasetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasasetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minasasetxrep(minasastate state, bool needxrep)
    {
    _core_minasasetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minasasetalgorithm(minasastate state, int algotype, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_algotype = new x_int(algotype);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minasasetalgorithm(&_s_errormsg, &_d_state, &_d_algotype);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasasetalgorithm' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minasasetalgorithm(minasastate state, int algotype)
    {
    _core_minasasetalgorithm( state,  algotype, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minasasetstpmax(minasastate state, double stpmax, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minasasetstpmax(&_s_errormsg, &_d_state, &_d_stpmax);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasasetstpmax' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minasasetstpmax(minasastate state, double stpmax)
    {
    _core_minasasetstpmax( state,  stpmax, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_minasaiteration(minasastate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minasaiteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasaiteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool minasaiteration(minasastate state)
    {
    bool result = _core_minasaiteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void minasaoptimize(minasastate state, ndimensional_grad grad, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_g = new x_vector();
        double[] _cs_g = null;
        byte _xc_needfg= 0;
    
        //
        // Check correctness of delegates
        //
        if( grad==null )
            throw new alglibexception("ALGLIB: error in 'minasaoptimize()' (grad is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_g, DT_REAL);
        _i_x_minasastate_get_x(_state, &_xc_arg);
        _i_x_minasastate_get_g(_state, &_xc_g);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_g = new double[_xc_g.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minasaiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minasaiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minasastate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minasastate_get_needfg(_state, &_xc_needfg);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfg!=0 )
            {
                grad(_cs_arg, ref _cs_f, _cs_g, obj);
                _i_x_minasastate_set_f(_state, &_cs_f);
                x_vector_from_array(ref _xc_g, _cs_g, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minasastate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minasaoptimize' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_minasaresults(minasastate state, out double[] x, out minasareport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minasareport _d_rep = new x_minasareport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minasareport_init(ref _d_rep);
            _error_code = _i_ser_minasaresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasaresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minasareport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minasareport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minasaresults(minasastate state, out double[] x, out minasareport rep)
    {
    _core_minasaresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minasaresultsbuf(minasastate state, ref double[] x, minasareport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minasareport _d_rep = new x_minasareport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minasareport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_minasaresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasaresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minasareport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minasareport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minasaresultsbuf(minasastate state, ref double[] x, minasareport rep)
    {
    _core_minasaresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minasarestartfrom(minasastate state, double[] x, double[] bndl, double[] bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_ser_minasarestartfrom(&_s_errormsg, &_d_state, &_d_x, &_d_bndl, &_d_bndu);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minasarestartfrom' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    public static void minasarestartfrom(minasastate state, double[] x, double[] bndl, double[] bndu)
    {
    _core_minasarestartfrom( state,  x,  bndl,  bndu, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage minnlc
    //
    

    public unsafe class minnlcstate : alglibobject
    {
        public void *ptr;
        public minnlcstate(void *x)
        {
            ptr = x;
        }
        ~minnlcstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new minnlcstate(null);
            return new minnlcstate(_i_x_obj_copy_minnlcstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_minnlcstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minnlcstate(void *x);
    private static _d_x_obj_copy_minnlcstate _i_x_obj_copy_minnlcstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_minnlcstate(void *x);
    private static _d_x_obj_free_minnlcstate _i_x_obj_free_minnlcstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_get_needfi(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_set_needfi(void *x, byte *dst);
    private static _d_x_minnlcstate_get_needfi _i_x_minnlcstate_get_needfi = null;
    private static _d_x_minnlcstate_set_needfi _i_x_minnlcstate_set_needfi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_get_needfij(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_set_needfij(void *x, byte *dst);
    private static _d_x_minnlcstate_get_needfij _i_x_minnlcstate_get_needfij = null;
    private static _d_x_minnlcstate_set_needfij _i_x_minnlcstate_set_needfij = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minnlcstate_get_xupdated _i_x_minnlcstate_get_xupdated = null;
    private static _d_x_minnlcstate_set_xupdated _i_x_minnlcstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_set_f(void *x, double *dst);
    private static _d_x_minnlcstate_get_f _i_x_minnlcstate_get_f = null;
    private static _d_x_minnlcstate_set_f _i_x_minnlcstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_get_fi(void *x, x_vector *dst);
    private static _d_x_minnlcstate_get_fi _i_x_minnlcstate_get_fi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_get_j(void *x, x_matrix *dst);
    private static _d_x_minnlcstate_get_j _i_x_minnlcstate_get_j = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnlcstate_get_x(void *x, x_vector *dst);
    private static _d_x_minnlcstate_get_x _i_x_minnlcstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minnlcreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public x_int varidx;
        public x_int funcidx;
        public x_int terminationtype;
        public x_int dbgphase0its;
    }

    public class minnlcreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public int varidx;
        public int funcidx;
        public int terminationtype;
        public int dbgphase0its;
        public override alglib.alglibobject make_copy()
        {
            minnlcreport dst = new minnlcreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.varidx = varidx;
            dst.funcidx = funcidx;
            dst.terminationtype = terminationtype;
            dst.dbgphase0its = dbgphase0its;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minnlcreport_init(ref x_minnlcreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.varidx.longval = 0;
        x.funcidx.longval = 0;
        x.terminationtype.longval = 0;
        x.dbgphase0its.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minnlcreport_clear(ref x_minnlcreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minnlcreport_init_from(ref x_minnlcreport x, minnlcreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.varidx.longval = v.varidx;
        x.funcidx.longval = v.funcidx;
        x.terminationtype.longval = v.terminationtype;
        x.dbgphase0its.longval = v.dbgphase0its;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minnlcreport_to_record(ref x_minnlcreport x, ref minnlcreport v)
    {
        if( v==null )
            v = new minnlcreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.funcidx = x.funcidx.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.dbgphase0its = x.dbgphase0its.intval; // long is silently truncated to int
    }
    private static unsafe void _core_minnlccreate(int n, double[] x, out minnlcstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minnlccreate(&_s_errormsg, &_d_n, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlccreate' call");
            }
            state = new minnlcstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minnlcstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minnlccreate(int n, double[] x, out minnlcstate state)
    {
    _core_minnlccreate( n,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minnlccreate(double[] x, out minnlcstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minnlccreate( n,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minnlccreatef(int n, double[] x, double diffstep, out minnlcstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minnlccreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlccreatef' call");
            }
            state = new minnlcstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minnlcstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minnlccreatef(int n, double[] x, double diffstep, out minnlcstate state)
    {
    _core_minnlccreatef( n,  x,  diffstep, out  state, alglibmode.serial);
    return;
    }
    public static void minnlccreatef(double[] x, double diffstep, out minnlcstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minnlccreatef( n,  x,  diffstep, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minnlcsetbc(minnlcstate state, double[] bndl, double[] bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_ser_minnlcsetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetbc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    public static void minnlcsetbc(minnlcstate state, double[] bndl, double[] bndu)
    {
    _core_minnlcsetbc( state,  bndl,  bndu, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetlc(minnlcstate state, double[,] c, int[] ct, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_ser_minnlcsetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetlc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    public static void minnlcsetlc(minnlcstate state, double[,] c, int[] ct, int k)
    {
    _core_minnlcsetlc( state,  c,  ct,  k, alglibmode.serial);
    return;
    }
    public static void minnlcsetlc(minnlcstate state, double[,] c, int[] ct)
    {
    int k;
    
    if( (ap.rows(c)!=ap.len(ct)))
        throw new alglibexception("Error while calling 'minnlcsetlc': looks like one of arguments has wrong size");
    
    k = ap.rows(c);
    
    _core_minnlcsetlc( state,  c,  ct,  k, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minnlcsetnlc(minnlcstate state, int nlec, int nlic, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_nlec = new x_int(nlec);
        x_int _d_nlic = new x_int(nlic);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlcsetnlc(&_s_errormsg, &_d_state, &_d_nlec, &_d_nlic);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetnlc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnlcsetnlc(minnlcstate state, int nlec, int nlic)
    {
    _core_minnlcsetnlc( state,  nlec,  nlic, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetcond(minnlcstate state, double epsg, double epsf, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsg = epsg;
        double _d_epsf = epsf;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlcsetcond(&_s_errormsg, &_d_state, &_d_epsg, &_d_epsf, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnlcsetcond(minnlcstate state, double epsg, double epsf, double epsx, int maxits)
    {
    _core_minnlcsetcond( state,  epsg,  epsf,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetscale(minnlcstate state, double[] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_ser_minnlcsetscale(&_s_errormsg, &_d_state, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    public static void minnlcsetscale(minnlcstate state, double[] s)
    {
    _core_minnlcsetscale( state,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetprecinexact(minnlcstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlcsetprecinexact(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetprecinexact' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnlcsetprecinexact(minnlcstate state)
    {
    _core_minnlcsetprecinexact( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetprecexactlowrank(minnlcstate state, int updatefreq, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_updatefreq = new x_int(updatefreq);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlcsetprecexactlowrank(&_s_errormsg, &_d_state, &_d_updatefreq);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetprecexactlowrank' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnlcsetprecexactlowrank(minnlcstate state, int updatefreq)
    {
    _core_minnlcsetprecexactlowrank( state,  updatefreq, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetprecnone(minnlcstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlcsetprecnone(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetprecnone' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnlcsetprecnone(minnlcstate state)
    {
    _core_minnlcsetprecnone( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetalgoaul(minnlcstate state, double rho, int itscnt, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_rho = rho;
        x_int _d_itscnt = new x_int(itscnt);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlcsetalgoaul(&_s_errormsg, &_d_state, &_d_rho, &_d_itscnt);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetalgoaul' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnlcsetalgoaul(minnlcstate state, double rho, int itscnt)
    {
    _core_minnlcsetalgoaul( state,  rho,  itscnt, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetxrep(minnlcstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlcsetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnlcsetxrep(minnlcstate state, bool needxrep)
    {
    _core_minnlcsetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_minnlciteration(minnlcstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlciteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlciteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool minnlciteration(minnlcstate state)
    {
    bool result = _core_minnlciteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void minnlcoptimize(minnlcstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        byte _xc_needfi= 0;
    
        //
        // Check correctness of delegates
        //
        if( fvec==null )
            throw new alglibexception("ALGLIB: error in 'minnlcoptimize()' (fvec is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        _i_x_minnlcstate_get_x(_state, &_xc_arg);
        _i_x_minnlcstate_get_fi(_state, &_xc_fi);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minnlciteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minnlciteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minnlcstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minnlcstate_get_needfi(_state, &_xc_needfi);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfi!=0 )
            {
                fvec(_cs_arg, _cs_fi, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minnlcstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minnlcoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void minnlcoptimize(minnlcstate state, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minnlcoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minnlcstate_get_x(_state, &_xc_arg);
        _i_x_minnlcstate_get_fi(_state, &_xc_fi);
        _i_x_minnlcstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minnlciteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minnlciteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minnlcstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minnlcstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minnlcstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minnlcoptimize' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_minnlcresults(minnlcstate state, out double[] x, out minnlcreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minnlcreport _d_rep = new x_minnlcreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minnlcreport_init(ref _d_rep);
            _error_code = _i_ser_minnlcresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minnlcreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minnlcreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minnlcresults(minnlcstate state, out double[] x, out minnlcreport rep)
    {
    _core_minnlcresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcresultsbuf(minnlcstate state, ref double[] x, minnlcreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minnlcreport _d_rep = new x_minnlcreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minnlcreport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_minnlcresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minnlcreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minnlcreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minnlcresultsbuf(minnlcstate state, ref double[] x, minnlcreport rep)
    {
    _core_minnlcresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcrestartfrom(minnlcstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minnlcrestartfrom(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcrestartfrom' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void minnlcrestartfrom(minnlcstate state, double[] x)
    {
    _core_minnlcrestartfrom( state,  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnlcsetgradientcheck(minnlcstate state, double teststep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_teststep = teststep;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnlcsetgradientcheck(&_s_errormsg, &_d_state, &_d_teststep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnlcsetgradientcheck' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnlcsetgradientcheck(minnlcstate state, double teststep)
    {
    _core_minnlcsetgradientcheck( state,  teststep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage minns
    //
    

    public unsafe class minnsstate : alglibobject
    {
        public void *ptr;
        public minnsstate(void *x)
        {
            ptr = x;
        }
        ~minnsstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new minnsstate(null);
            return new minnsstate(_i_x_obj_copy_minnsstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_minnsstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_minnsstate(void *x);
    private static _d_x_obj_copy_minnsstate _i_x_obj_copy_minnsstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_minnsstate(void *x);
    private static _d_x_obj_free_minnsstate _i_x_obj_free_minnsstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_get_needfi(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_set_needfi(void *x, byte *dst);
    private static _d_x_minnsstate_get_needfi _i_x_minnsstate_get_needfi = null;
    private static _d_x_minnsstate_set_needfi _i_x_minnsstate_set_needfi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_get_needfij(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_set_needfij(void *x, byte *dst);
    private static _d_x_minnsstate_get_needfij _i_x_minnsstate_get_needfij = null;
    private static _d_x_minnsstate_set_needfij _i_x_minnsstate_set_needfij = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_set_xupdated(void *x, byte *dst);
    private static _d_x_minnsstate_get_xupdated _i_x_minnsstate_get_xupdated = null;
    private static _d_x_minnsstate_set_xupdated _i_x_minnsstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_set_f(void *x, double *dst);
    private static _d_x_minnsstate_get_f _i_x_minnsstate_get_f = null;
    private static _d_x_minnsstate_set_f _i_x_minnsstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_get_fi(void *x, x_vector *dst);
    private static _d_x_minnsstate_get_fi _i_x_minnsstate_get_fi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_get_j(void *x, x_matrix *dst);
    private static _d_x_minnsstate_get_j _i_x_minnsstate_get_j = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_minnsstate_get_x(void *x, x_vector *dst);
    private static _d_x_minnsstate_get_x _i_x_minnsstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_minnsreport
    {
        public x_int iterationscount;
        public x_int nfev;
        public double cerr;
        public double lcerr;
        public double nlcerr;
        public x_int terminationtype;
        public x_int varidx;
        public x_int funcidx;
    }

    public class minnsreport : alglibobject
    {
        public int iterationscount;
        public int nfev;
        public double cerr;
        public double lcerr;
        public double nlcerr;
        public int terminationtype;
        public int varidx;
        public int funcidx;
        public override alglib.alglibobject make_copy()
        {
            minnsreport dst = new minnsreport();
            dst.iterationscount = iterationscount;
            dst.nfev = nfev;
            dst.cerr = cerr;
            dst.lcerr = lcerr;
            dst.nlcerr = nlcerr;
            dst.terminationtype = terminationtype;
            dst.varidx = varidx;
            dst.funcidx = funcidx;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_minnsreport_init(ref x_minnsreport x)
    {
        x.iterationscount.longval = 0;
        x.nfev.longval = 0;
        x.cerr = 0;
        x.lcerr = 0;
        x.nlcerr = 0;
        x.terminationtype.longval = 0;
        x.varidx.longval = 0;
        x.funcidx.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_minnsreport_clear(ref x_minnsreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_minnsreport_init_from(ref x_minnsreport x, minnsreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfev.longval = v.nfev;
        x.cerr = v.cerr;
        x.lcerr = v.lcerr;
        x.nlcerr = v.nlcerr;
        x.terminationtype.longval = v.terminationtype;
        x.varidx.longval = v.varidx;
        x.funcidx.longval = v.funcidx;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_minnsreport_to_record(ref x_minnsreport x, ref minnsreport v)
    {
        if( v==null )
            v = new minnsreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfev = x.nfev.intval; // long is silently truncated to int
        v.cerr = x.cerr;
        v.lcerr = x.lcerr;
        v.nlcerr = x.nlcerr;
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.varidx = x.varidx.intval; // long is silently truncated to int
        v.funcidx = x.funcidx.intval; // long is silently truncated to int
    }
    private static unsafe void _core_minnscreate(int n, double[] x, out minnsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minnscreate(&_s_errormsg, &_d_n, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnscreate' call");
            }
            state = new minnsstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minnsstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minnscreate(int n, double[] x, out minnsstate state)
    {
    _core_minnscreate( n,  x, out  state, alglibmode.serial);
    return;
    }
    public static void minnscreate(double[] x, out minnsstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minnscreate( n,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minnscreatef(int n, double[] x, double diffstep, out minnsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        double _d_diffstep = diffstep;
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minnscreatef(&_s_errormsg, &_d_n, &_d_x, &_d_diffstep, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnscreatef' call");
            }
            state = new minnsstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_minnsstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void minnscreatef(int n, double[] x, double diffstep, out minnsstate state)
    {
    _core_minnscreatef( n,  x,  diffstep, out  state, alglibmode.serial);
    return;
    }
    public static void minnscreatef(double[] x, double diffstep, out minnsstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_minnscreatef( n,  x,  diffstep, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minnssetbc(minnsstate state, double[] bndl, double[] bndu, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_bndl = new x_vector();
        x_vector _d_bndu = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_bndl = bndl, _fp_bndu = bndu){
                x_vector_attach_to_array(ref _d_bndl, _fp_bndl, ap.len(bndl));
                x_vector_attach_to_array(ref _d_bndu, _fp_bndu, ap.len(bndu));
                _error_code = _i_ser_minnssetbc(&_s_errormsg, &_d_state, &_d_bndl, &_d_bndu);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnssetbc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_bndl);
            x_vector_clear(ref _d_bndu);
        }
        // This function returns no value.
    }
    public static void minnssetbc(minnsstate state, double[] bndl, double[] bndu)
    {
    _core_minnssetbc( state,  bndl,  bndu, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnssetlc(minnsstate state, double[,] c, int[] ct, int k, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_matrix _d_c = new x_matrix();
        x_vector _d_ct = new x_vector();
        x_int _d_k = new x_int(k);
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_matrix_attach_to_array(ref _d_c, _fp_c, ap.rows(c), ap.cols(c));
                x_vector_from_array(ref _d_ct, ct, X_CREATE);
                _error_code = _i_ser_minnssetlc(&_s_errormsg, &_d_state, &_d_c, &_d_ct, &_d_k);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnssetlc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_matrix_clear(ref _d_c);
            x_vector_clear(ref _d_ct);
        }
        // This function returns no value.
    }
    public static void minnssetlc(minnsstate state, double[,] c, int[] ct, int k)
    {
    _core_minnssetlc( state,  c,  ct,  k, alglibmode.serial);
    return;
    }
    public static void minnssetlc(minnsstate state, double[,] c, int[] ct)
    {
    int k;
    
    if( (ap.rows(c)!=ap.len(ct)))
        throw new alglibexception("Error while calling 'minnssetlc': looks like one of arguments has wrong size");
    
    k = ap.rows(c);
    
    _core_minnssetlc( state,  c,  ct,  k, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_minnssetnlc(minnsstate state, int nlec, int nlic, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_nlec = new x_int(nlec);
        x_int _d_nlic = new x_int(nlic);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnssetnlc(&_s_errormsg, &_d_state, &_d_nlec, &_d_nlic);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnssetnlc' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnssetnlc(minnsstate state, int nlec, int nlic)
    {
    _core_minnssetnlc( state,  nlec,  nlic, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnssetcond(minnsstate state, double epsx, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsx = epsx;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnssetcond(&_s_errormsg, &_d_state, &_d_epsx, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnssetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnssetcond(minnsstate state, double epsx, int maxits)
    {
    _core_minnssetcond( state,  epsx,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnssetscale(minnsstate state, double[] s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_s = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_s = s){
                x_vector_attach_to_array(ref _d_s, _fp_s, ap.len(s));
                _error_code = _i_ser_minnssetscale(&_s_errormsg, &_d_state, &_d_s);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnssetscale' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_s);
        }
        // This function returns no value.
    }
    public static void minnssetscale(minnsstate state, double[] s)
    {
    _core_minnssetscale( state,  s, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnssetalgoags(minnsstate state, double radius, double penalty, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_radius = radius;
        double _d_penalty = penalty;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnssetalgoags(&_s_errormsg, &_d_state, &_d_radius, &_d_penalty);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnssetalgoags' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnssetalgoags(minnsstate state, double radius, double penalty)
    {
    _core_minnssetalgoags( state,  radius,  penalty, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnssetxrep(minnsstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnssetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnssetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnssetxrep(minnsstate state, bool needxrep)
    {
    _core_minnssetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnsrequesttermination(minnsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnsrequesttermination(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnsrequesttermination' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void minnsrequesttermination(minnsstate state)
    {
    _core_minnsrequesttermination( state, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_minnsiteration(minnsstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_minnsiteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnsiteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool minnsiteration(minnsstate state)
    {
    bool result = _core_minnsiteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void minnsoptimize(minnsstate state, ndimensional_fvec  fvec, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        byte _xc_needfi= 0;
    
        //
        // Check correctness of delegates
        //
        if( fvec==null )
            throw new alglibexception("ALGLIB: error in 'minnsoptimize()' (fvec is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        _i_x_minnsstate_get_x(_state, &_xc_arg);
        _i_x_minnsstate_get_fi(_state, &_xc_fi);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minnsiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minnsiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minnsstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minnsstate_get_needfi(_state, &_xc_needfi);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfi!=0 )
            {
                fvec(_cs_arg, _cs_fi, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minnsstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minnsoptimize' (some derivatives were not provided?)");
        }
    }
    public static unsafe void minnsoptimize(minnsstate state, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'minnsoptimize()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_minnsstate_get_x(_state, &_xc_arg);
        _i_x_minnsstate_get_fi(_state, &_xc_fi);
        _i_x_minnsstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_minnsiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'minnsiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_minnsstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_minnsstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_minnsstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'minnsoptimize' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_minnsresults(minnsstate state, out double[] x, out minnsreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minnsreport _d_rep = new x_minnsreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_minnsreport_init(ref _d_rep);
            _error_code = _i_ser_minnsresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnsresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_minnsreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minnsreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minnsresults(minnsstate state, out double[] x, out minnsreport rep)
    {
    _core_minnsresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnsresultsbuf(minnsstate state, ref double[] x, minnsreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_minnsreport _d_rep = new x_minnsreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_minnsreport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_minnsresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnsresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_minnsreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_minnsreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void minnsresultsbuf(minnsstate state, ref double[] x, minnsreport rep)
    {
    _core_minnsresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_minnsrestartfrom(minnsstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_minnsrestartfrom(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'minnsrestartfrom' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void minnsrestartfrom(minnsstate state, double[] x)
    {
    _core_minnsrestartfrom( state,  x, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage lincg
    //
    

    public unsafe class lincgstate : alglibobject
    {
        public void *ptr;
        public lincgstate(void *x)
        {
            ptr = x;
        }
        ~lincgstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new lincgstate(null);
            return new lincgstate(_i_x_obj_copy_lincgstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_lincgstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_lincgstate(void *x);
    private static _d_x_obj_copy_lincgstate _i_x_obj_copy_lincgstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_lincgstate(void *x);
    private static _d_x_obj_free_lincgstate _i_x_obj_free_lincgstate = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_lincgreport
    {
        public x_int iterationscount;
        public x_int nmv;
        public x_int terminationtype;
        public double r2;
    }

    public class lincgreport : alglibobject
    {
        public int iterationscount;
        public int nmv;
        public int terminationtype;
        public double r2;
        public override alglib.alglibobject make_copy()
        {
            lincgreport dst = new lincgreport();
            dst.iterationscount = iterationscount;
            dst.nmv = nmv;
            dst.terminationtype = terminationtype;
            dst.r2 = r2;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_lincgreport_init(ref x_lincgreport x)
    {
        x.iterationscount.longval = 0;
        x.nmv.longval = 0;
        x.terminationtype.longval = 0;
        x.r2 = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_lincgreport_clear(ref x_lincgreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_lincgreport_init_from(ref x_lincgreport x, lincgreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nmv.longval = v.nmv;
        x.terminationtype.longval = v.terminationtype;
        x.r2 = v.r2;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_lincgreport_to_record(ref x_lincgreport x, ref lincgreport v)
    {
        if( v==null )
            v = new lincgreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nmv = x.nmv.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
        v.r2 = x.r2;
    }
    private static unsafe void _core_lincgcreate(int n, out lincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lincgcreate(&_s_errormsg, &_d_n, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgcreate' call");
            }
            state = new lincgstate(_d_state);
        }
        finally
        {
            if( _d_state!=null && state==null)
                _i_x_obj_free_lincgstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void lincgcreate(int n, out lincgstate state)
    {
    _core_lincgcreate( n, out  state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgsetstartingpoint(lincgstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_lincgsetstartingpoint(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgsetstartingpoint' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void lincgsetstartingpoint(lincgstate state, double[] x)
    {
    _core_lincgsetstartingpoint( state,  x, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgsetprecunit(lincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lincgsetprecunit(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgsetprecunit' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lincgsetprecunit(lincgstate state)
    {
    _core_lincgsetprecunit( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgsetprecdiag(lincgstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lincgsetprecdiag(&_s_errormsg, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgsetprecdiag' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lincgsetprecdiag(lincgstate state)
    {
    _core_lincgsetprecdiag( state, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgsetcond(lincgstate state, double epsf, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsf = epsf;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lincgsetcond(&_s_errormsg, &_d_state, &_d_epsf, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgsetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lincgsetcond(lincgstate state, double epsf, int maxits)
    {
    _core_lincgsetcond( state,  epsf,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgsolvesparse(lincgstate state, sparsematrix a, bool isupper, double[] b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        void *_d_a = a.ptr;
        byte _d_isupper = (byte)(isupper ? 1 : 0);
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_b = b){
                x_vector_attach_to_array(ref _d_b, _fp_b, ap.len(b));
                _error_code = _i_ser_lincgsolvesparse(&_s_errormsg, &_d_state, &_d_a, &_d_isupper, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgsolvesparse' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            ap.assert(a.ptr==_d_a, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void lincgsolvesparse(lincgstate state, sparsematrix a, bool isupper, double[] b)
    {
    _core_lincgsolvesparse( state,  a,  isupper,  b, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgresults(lincgstate state, out double[] x, out lincgreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_lincgreport _d_rep = new x_lincgreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_lincgreport_init(ref _d_rep);
            _error_code = _i_ser_lincgresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_lincgreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_lincgreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void lincgresults(lincgstate state, out double[] x, out lincgreport rep)
    {
    _core_lincgresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgsetrestartfreq(lincgstate state, int srf, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_srf = new x_int(srf);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lincgsetrestartfreq(&_s_errormsg, &_d_state, &_d_srf);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgsetrestartfreq' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lincgsetrestartfreq(lincgstate state, int srf)
    {
    _core_lincgsetrestartfreq( state,  srf, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgsetrupdatefreq(lincgstate state, int freq, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_int _d_freq = new x_int(freq);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lincgsetrupdatefreq(&_s_errormsg, &_d_state, &_d_freq);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgsetrupdatefreq' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lincgsetrupdatefreq(lincgstate state, int freq)
    {
    _core_lincgsetrupdatefreq( state,  freq, alglibmode.serial);
    return;
    }
    private static unsafe void _core_lincgsetxrep(lincgstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_lincgsetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'lincgsetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void lincgsetxrep(lincgstate state, bool needxrep)
    {
    _core_lincgsetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage nleq
    //
    

    public unsafe class nleqstate : alglibobject
    {
        public void *ptr;
        public nleqstate(void *x)
        {
            ptr = x;
        }
        ~nleqstate()
        {
            _deallocate();
        }
        public override alglib.alglibobject make_copy()
        {
            if( ptr==null )
                return new nleqstate(null);
            return new nleqstate(_i_x_obj_copy_nleqstate(ptr));
        }
        public override void _deallocate()
        {
            if( ptr!=null )
                _i_x_obj_free_nleqstate(ptr);
            ptr = null;
        }
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate void* _d_x_obj_copy_nleqstate(void *x);
    private static _d_x_obj_copy_nleqstate _i_x_obj_copy_nleqstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_obj_free_nleqstate(void *x);
    private static _d_x_obj_free_nleqstate _i_x_obj_free_nleqstate = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_get_needf(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_set_needf(void *x, byte *dst);
    private static _d_x_nleqstate_get_needf _i_x_nleqstate_get_needf = null;
    private static _d_x_nleqstate_set_needf _i_x_nleqstate_set_needf = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_get_needfij(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_set_needfij(void *x, byte *dst);
    private static _d_x_nleqstate_get_needfij _i_x_nleqstate_get_needfij = null;
    private static _d_x_nleqstate_set_needfij _i_x_nleqstate_set_needfij = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_get_xupdated(void *x, byte *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_set_xupdated(void *x, byte *dst);
    private static _d_x_nleqstate_get_xupdated _i_x_nleqstate_get_xupdated = null;
    private static _d_x_nleqstate_set_xupdated _i_x_nleqstate_set_xupdated = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_get_f(void *x, double *dst);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_set_f(void *x, double *dst);
    private static _d_x_nleqstate_get_f _i_x_nleqstate_get_f = null;
    private static _d_x_nleqstate_set_f _i_x_nleqstate_set_f = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_get_fi(void *x, x_vector *dst);
    private static _d_x_nleqstate_get_fi _i_x_nleqstate_get_fi = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_get_j(void *x, x_matrix *dst);
    private static _d_x_nleqstate_get_j _i_x_nleqstate_get_j = null;
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_nleqstate_get_x(void *x, x_vector *dst);
    private static _d_x_nleqstate_get_x _i_x_nleqstate_get_x = null;

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_nleqreport
    {
        public x_int iterationscount;
        public x_int nfunc;
        public x_int njac;
        public x_int terminationtype;
    }

    public class nleqreport : alglibobject
    {
        public int iterationscount;
        public int nfunc;
        public int njac;
        public int terminationtype;
        public override alglib.alglibobject make_copy()
        {
            nleqreport dst = new nleqreport();
            dst.iterationscount = iterationscount;
            dst.nfunc = nfunc;
            dst.njac = njac;
            dst.terminationtype = terminationtype;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_nleqreport_init(ref x_nleqreport x)
    {
        x.iterationscount.longval = 0;
        x.nfunc.longval = 0;
        x.njac.longval = 0;
        x.terminationtype.longval = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_nleqreport_clear(ref x_nleqreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_nleqreport_init_from(ref x_nleqreport x, nleqreport v)
    {
        x.iterationscount.longval = v.iterationscount;
        x.nfunc.longval = v.nfunc;
        x.njac.longval = v.njac;
        x.terminationtype.longval = v.terminationtype;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_nleqreport_to_record(ref x_nleqreport x, ref nleqreport v)
    {
        if( v==null )
            v = new nleqreport();
        v.iterationscount = x.iterationscount.intval; // long is silently truncated to int
        v.nfunc = x.nfunc.intval; // long is silently truncated to int
        v.njac = x.njac.intval; // long is silently truncated to int
        v.terminationtype = x.terminationtype.intval; // long is silently truncated to int
    }
    private static unsafe void _core_nleqcreatelm(int n, int m, double[] x, out nleqstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_int _d_m = new x_int(m);
        x_vector _d_x = new x_vector();
        void *_d_state = null;
        state = null;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_nleqcreatelm(&_s_errormsg, &_d_n, &_d_m, &_d_x, &_d_state);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'nleqcreatelm' call");
            }
            state = new nleqstate(_d_state);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            if( _d_state!=null && state==null)
                _i_x_obj_free_nleqstate(_d_state); // on exception clean up X objects which were not attached to C# objects
        }
        // This function returns no value.
    }
    public static void nleqcreatelm(int n, int m, double[] x, out nleqstate state)
    {
    _core_nleqcreatelm( n,  m,  x, out  state, alglibmode.serial);
    return;
    }
    public static void nleqcreatelm(int m, double[] x, out nleqstate state)
    {
    int n;
    
    
    n = ap.len(x);
    
    _core_nleqcreatelm( n,  m,  x, out  state, alglibmode.serial);
    
    return;
    }
    private static unsafe void _core_nleqsetcond(nleqstate state, double epsf, int maxits, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_epsf = epsf;
        x_int _d_maxits = new x_int(maxits);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_nleqsetcond(&_s_errormsg, &_d_state, &_d_epsf, &_d_maxits);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'nleqsetcond' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void nleqsetcond(nleqstate state, double epsf, int maxits)
    {
    _core_nleqsetcond( state,  epsf,  maxits, alglibmode.serial);
    return;
    }
    private static unsafe void _core_nleqsetxrep(nleqstate state, bool needxrep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        byte _d_needxrep = (byte)(needxrep ? 1 : 0);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_nleqsetxrep(&_s_errormsg, &_d_state, &_d_needxrep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'nleqsetxrep' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void nleqsetxrep(nleqstate state, bool needxrep)
    {
    _core_nleqsetxrep( state,  needxrep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_nleqsetstpmax(nleqstate state, double stpmax, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        double _d_stpmax = stpmax;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_nleqsetstpmax(&_s_errormsg, &_d_state, &_d_stpmax);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'nleqsetstpmax' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void nleqsetstpmax(nleqstate state, double stpmax)
    {
    _core_nleqsetstpmax( state,  stpmax, alglibmode.serial);
    return;
    }
    private static unsafe bool _core_nleqiteration(nleqstate state, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        bool result;
        byte _d_result = (byte)0;
        void *_d_state = state.ptr;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_nleqiteration(&_s_errormsg, &_d_result, &_d_state);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'nleqiteration' call");
            }
            result = _d_result!=0;
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static bool nleqiteration(nleqstate state)
    {
    bool result = _core_nleqiteration( state, alglibmode.serial);
    return result;
    }
    public static unsafe void nleqsolve(nleqstate state, ndimensional_func func, ndimensional_jac  jac, ndimensional_rep rep, object obj)
    {
        byte *_s_errormsg = null;
        int _error_code = 0;
        byte _b_result = (byte)0;
        byte _xc_xupdated = 0;
        void *_state = state.ptr;
        x_vector _xc_arg = new x_vector();
        double[] _cs_arg = null;
        double _cs_f = 0;
        x_vector _xc_fi = new x_vector();
        double[] _cs_fi = null;
        x_matrix _xc_j = new x_matrix();
        double[,] _cs_j = null;
        byte _xc_needf= 0;
        byte _xc_needfij= 0;
    
        //
        // Check correctness of delegates
        //
        if( func==null )
            throw new alglibexception("ALGLIB: error in 'nleqsolve()' (func is null)");
        if( jac==null )
            throw new alglibexception("ALGLIB: error in 'nleqsolve()' (jac is null)");
    
        //
        // Attach x-structures to internal arrays
        //
        x_vector_create_empty(ref _xc_arg, DT_REAL);
        x_vector_create_empty(ref _xc_fi, DT_REAL);
        x_matrix_create_empty(ref _xc_j, DT_REAL);
        _i_x_nleqstate_get_x(_state, &_xc_arg);
        _i_x_nleqstate_get_fi(_state, &_xc_fi);
        _i_x_nleqstate_get_j(_state, &_xc_j);
        _cs_arg = new double[_xc_arg.cnt];
        _cs_fi = new double[_xc_fi.cnt];
        _cs_j = new double[_xc_j.rows,_xc_j.cols];
    
        //
        // Main loop
        //
        for(;;)
        {
            //
            // Call iteration function.
            // Terminate iterations if it returned false.
            //
            _error_code = _i_ser_nleqiteration(&_s_errormsg, &_b_result, &_state);
            if( _error_code!=X_OK )
                throw new alglibexception(_error_code==X_ASSERTION_FAILED
                    ? Marshal.PtrToStringAnsi((IntPtr)_s_errormsg)
                    : "ALGLIB: unknown error during 'nleqiteration' call");
            ap.assert(_state==state.ptr, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _b_result==0 )
                break;
            
            //
            // Reverse communication interface:
            // * fetch flags
            // * make delegate calls
            //
            _i_x_nleqstate_get_xupdated(_state, &_xc_xupdated);
            _i_x_nleqstate_get_needf(_state, &_xc_needf);
            _i_x_nleqstate_get_needfij(_state, &_xc_needfij);
            x_vector_to_array(ref _xc_arg, ref _cs_arg);
            if( _xc_needf!=0 )
            {
                func(_cs_arg, ref _cs_f, obj);
                _i_x_nleqstate_set_f(_state, &_cs_f);
                continue;
            }
            if( _xc_needfij!=0 )
            {
                jac(_cs_arg, _cs_fi, _cs_j, obj);
                x_vector_from_array(ref _xc_fi, _cs_fi, X_REWRITE);
                x_matrix_from_array(ref _xc_j,  _cs_j,  X_REWRITE);
                continue;
            }
            if( _xc_xupdated!=0 )
            {
                if( rep!=null )
                {
                    double _local_f;
                    _i_x_nleqstate_get_f(_state, &_local_f);
                    rep(_cs_arg, _local_f, obj);
                }
                continue;
            }
            throw new alglibexception("ALGLIB: error in 'nleqsolve' (some derivatives were not provided?)");
        }
    }
    private static unsafe void _core_nleqresults(nleqstate state, out double[] x, out nleqreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_nleqreport _d_rep = new x_nleqreport();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_x, DT_REAL);
            x = null;
            x_nleqreport_init(ref _d_rep);
            _error_code = _i_ser_nleqresults(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'nleqresults' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            rep = null;
            x_nleqreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_nleqreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void nleqresults(nleqstate state, out double[] x, out nleqreport rep)
    {
    _core_nleqresults( state, out  x, out  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_nleqresultsbuf(nleqstate state, ref double[] x, nleqreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        x_nleqreport _d_rep = new x_nleqreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_nleqreport_init_from(ref _d_rep, rep);
                _error_code = _i_ser_nleqresultsbuf(&_s_errormsg, &_d_state, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'nleqresultsbuf' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new double[0];
            x_nleqreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_nleqreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void nleqresultsbuf(nleqstate state, ref double[] x, nleqreport rep)
    {
    _core_nleqresultsbuf( state, ref  x,  rep, alglibmode.serial);
    return;
    }
    private static unsafe void _core_nleqrestartfrom(nleqstate state, double[] x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        void *_d_state = state.ptr;
        x_vector _d_x = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_nleqrestartfrom(&_s_errormsg, &_d_state, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'nleqrestartfrom' call");
            }
            ap.assert(state.ptr==_d_state, "ALGLIB: internal error (reference changed for non-out X-object)");
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void nleqrestartfrom(nleqstate state, double[] x)
    {
    _core_nleqrestartfrom( state,  x, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage polynomialsolver
    //
    

    [StructLayout(LayoutKind.Sequential, Pack=8)]
    private struct x_polynomialsolverreport
    {
        public double maxerr;
    }

    public class polynomialsolverreport : alglibobject
    {
        public double maxerr;
        public override alglib.alglibobject make_copy()
        {
            polynomialsolverreport dst = new polynomialsolverreport();
            dst.maxerr = maxerr;
            return dst;
        }
    }

    // This function initializes X-structure (its previous content is ignored)
    private static void x_polynomialsolverreport_init(ref x_polynomialsolverreport x)
    {
        x.maxerr = 0;
    }

    // This function finalizes fields of X-structure (however, memory occupied by structure itself is not freed)
    // After destruction structure becomes unusable and should be re-initialized if you want to use it
    private static void x_polynomialsolverreport_clear(ref x_polynomialsolverreport x)
    {
    }

    // This function initializes X-structure by appropriate C# instance
    // (previous content of X structure is ignored)
    private static void x_polynomialsolverreport_init_from(ref x_polynomialsolverreport x, polynomialsolverreport v)
    {
        x.maxerr = v.maxerr;
    }

    // This function initializes C# structure by appropriate X instance
    // (previous content of C# structure is ignored).
    // This function may accept null v, in this case v is automatically allocated with new().
    private static void x_polynomialsolverreport_to_record(ref x_polynomialsolverreport x, ref polynomialsolverreport v)
    {
        if( v==null )
            v = new polynomialsolverreport();
        v.maxerr = x.maxerr;
    }
    private static unsafe void _core_polynomialsolve(double[] a, int n, out complex[] x, out polynomialsolverreport rep, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_x = new x_vector();
        x_polynomialsolverreport _d_rep = new x_polynomialsolverreport();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_create_empty(ref _d_x, DT_COMPLEX);
                x = null;
                x_polynomialsolverreport_init(ref _d_rep);
                _error_code = _i_ser_polynomialsolve(&_s_errormsg, &_d_a, &_d_n, &_d_x, &_d_rep);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'polynomialsolve' call");
            }
            if( _d_x.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_x, ref x);
            if( x == null )
                x = new alglib.complex[0];
            rep = null;
            x_polynomialsolverreport_to_record(ref _d_rep, ref rep);
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_x);
            x_polynomialsolverreport_clear(ref _d_rep);
        }
        // This function returns no value.
    }
    public static void polynomialsolve(double[] a, int n, out complex[] x, out polynomialsolverreport rep)
    {
    _core_polynomialsolve( a,  n, out  x, out  rep, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage airyf
    //
    
    private static unsafe void _core_airy(double x, out double ai, out double aip, out double bi, out double bip, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_x = x;
        double _d_ai = 0;
        double _d_aip = 0;
        double _d_bi = 0;
        double _d_bip = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_airy(&_s_errormsg, &_d_x, &_d_ai, &_d_aip, &_d_bi, &_d_bip);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'airy' call");
            }
            ai = _d_ai;
            aip = _d_aip;
            bi = _d_bi;
            bip = _d_bip;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void airy(double x, out double ai, out double aip, out double bi, out double bip)
    {
    _core_airy( x, out  ai, out  aip, out  bi, out  bip, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage bessel
    //
    
    private static unsafe double _core_besselj0(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besselj0(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besselj0' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besselj0(double x)
    {
    double result = _core_besselj0( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_besselj1(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besselj1(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besselj1' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besselj1(double x)
    {
    double result = _core_besselj1( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_besseljn(int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besseljn(&_s_errormsg, &_d_result, &_d_n, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besseljn' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besseljn(int n, double x)
    {
    double result = _core_besseljn( n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_bessely0(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_bessely0(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'bessely0' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double bessely0(double x)
    {
    double result = _core_bessely0( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_bessely1(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_bessely1(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'bessely1' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double bessely1(double x)
    {
    double result = _core_bessely1( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_besselyn(int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besselyn(&_s_errormsg, &_d_result, &_d_n, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besselyn' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besselyn(int n, double x)
    {
    double result = _core_besselyn( n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_besseli0(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besseli0(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besseli0' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besseli0(double x)
    {
    double result = _core_besseli0( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_besseli1(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besseli1(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besseli1' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besseli1(double x)
    {
    double result = _core_besseli1( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_besselk0(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besselk0(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besselk0' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besselk0(double x)
    {
    double result = _core_besselk0( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_besselk1(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besselk1(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besselk1' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besselk1(double x)
    {
    double result = _core_besselk1( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_besselkn(int nn, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_nn = new x_int(nn);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_besselkn(&_s_errormsg, &_d_result, &_d_nn, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'besselkn' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double besselkn(int nn, double x)
    {
    double result = _core_besselkn( nn,  x, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage betaf
    //
    
    private static unsafe double _core_beta(double a, double b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_beta(&_s_errormsg, &_d_result, &_d_a, &_d_b);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'beta' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double beta(double a, double b)
    {
    double result = _core_beta( a,  b, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage ibetaf
    //
    
    private static unsafe double _core_incompletebeta(double a, double b, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_incompletebeta(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'incompletebeta' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double incompletebeta(double a, double b, double x)
    {
    double result = _core_incompletebeta( a,  b,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_invincompletebeta(double a, double b, double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_a = a;
        double _d_b = b;
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_invincompletebeta(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'invincompletebeta' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double invincompletebeta(double a, double b, double y)
    {
    double result = _core_invincompletebeta( a,  b,  y, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage binomialdistr
    //
    
    private static unsafe double _core_binomialdistribution(int k, int n, double p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        x_int _d_n = new x_int(n);
        double _d_p = p;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_binomialdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_n, &_d_p);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'binomialdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double binomialdistribution(int k, int n, double p)
    {
    double result = _core_binomialdistribution( k,  n,  p, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_binomialcdistribution(int k, int n, double p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        x_int _d_n = new x_int(n);
        double _d_p = p;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_binomialcdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_n, &_d_p);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'binomialcdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double binomialcdistribution(int k, int n, double p)
    {
    double result = _core_binomialcdistribution( k,  n,  p, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_invbinomialdistribution(int k, int n, double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        x_int _d_n = new x_int(n);
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_invbinomialdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_n, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'invbinomialdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double invbinomialdistribution(int k, int n, double y)
    {
    double result = _core_invbinomialdistribution( k,  n,  y, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage chebyshev
    //
    
    private static unsafe double _core_chebyshevcalculate(int r, int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_r = new x_int(r);
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_chebyshevcalculate(&_s_errormsg, &_d_result, &_d_r, &_d_n, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'chebyshevcalculate' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double chebyshevcalculate(int r, int n, double x)
    {
    double result = _core_chebyshevcalculate( r,  n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_chebyshevsum(double[] c, int r, int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_c = new x_vector();
        x_int _d_r = new x_int(r);
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_chebyshevsum(&_s_errormsg, &_d_result, &_d_c, &_d_r, &_d_n, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'chebyshevsum' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        return result;
    }
    public static double chebyshevsum(double[] c, int r, int n, double x)
    {
    double result = _core_chebyshevsum( c,  r,  n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_chebyshevcoefficients(int n, out double[] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            _error_code = _i_ser_chebyshevcoefficients(&_s_errormsg, &_d_n, &_d_c);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'chebyshevcoefficients' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void chebyshevcoefficients(int n, out double[] c)
    {
    _core_chebyshevcoefficients( n, out  c, alglibmode.serial);
    return;
    }
    private static unsafe void _core_fromchebyshev(double[] a, int n, out double[] b, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_a = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_b = new x_vector();
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_a = a){
                x_vector_attach_to_array(ref _d_a, _fp_a, ap.len(a));
                x_vector_create_empty(ref _d_b, DT_REAL);
                b = null;
                _error_code = _i_ser_fromchebyshev(&_s_errormsg, &_d_a, &_d_n, &_d_b);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fromchebyshev' call");
            }
            if( _d_b.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_b, ref b);
            if( b == null )
                b = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_a);
            x_vector_clear(ref _d_b);
        }
        // This function returns no value.
    }
    public static void fromchebyshev(double[] a, int n, out double[] b)
    {
    _core_fromchebyshev( a,  n, out  b, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage chisquaredistr
    //
    
    private static unsafe double _core_chisquaredistribution(double v, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_v = v;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_chisquaredistribution(&_s_errormsg, &_d_result, &_d_v, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'chisquaredistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double chisquaredistribution(double v, double x)
    {
    double result = _core_chisquaredistribution( v,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_chisquarecdistribution(double v, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_v = v;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_chisquarecdistribution(&_s_errormsg, &_d_result, &_d_v, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'chisquarecdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double chisquarecdistribution(double v, double x)
    {
    double result = _core_chisquarecdistribution( v,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_invchisquaredistribution(double v, double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_v = v;
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_invchisquaredistribution(&_s_errormsg, &_d_result, &_d_v, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'invchisquaredistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double invchisquaredistribution(double v, double y)
    {
    double result = _core_invchisquaredistribution( v,  y, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage dawson
    //
    
    private static unsafe double _core_dawsonintegral(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_dawsonintegral(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'dawsonintegral' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double dawsonintegral(double x)
    {
    double result = _core_dawsonintegral( x, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage elliptic
    //
    
    private static unsafe double _core_ellipticintegralk(double m, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_ellipticintegralk(&_s_errormsg, &_d_result, &_d_m);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'ellipticintegralk' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double ellipticintegralk(double m)
    {
    double result = _core_ellipticintegralk( m, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_ellipticintegralkhighprecision(double m1, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_m1 = m1;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_ellipticintegralkhighprecision(&_s_errormsg, &_d_result, &_d_m1);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'ellipticintegralkhighprecision' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double ellipticintegralkhighprecision(double m1)
    {
    double result = _core_ellipticintegralkhighprecision( m1, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_incompleteellipticintegralk(double phi, double m, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_phi = phi;
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_incompleteellipticintegralk(&_s_errormsg, &_d_result, &_d_phi, &_d_m);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'incompleteellipticintegralk' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double incompleteellipticintegralk(double phi, double m)
    {
    double result = _core_incompleteellipticintegralk( phi,  m, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_ellipticintegrale(double m, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_ellipticintegrale(&_s_errormsg, &_d_result, &_d_m);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'ellipticintegrale' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double ellipticintegrale(double m)
    {
    double result = _core_ellipticintegrale( m, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_incompleteellipticintegrale(double phi, double m, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_phi = phi;
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_incompleteellipticintegrale(&_s_errormsg, &_d_result, &_d_phi, &_d_m);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'incompleteellipticintegrale' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double incompleteellipticintegrale(double phi, double m)
    {
    double result = _core_incompleteellipticintegrale( phi,  m, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage expintegrals
    //
    
    private static unsafe double _core_exponentialintegralei(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_exponentialintegralei(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'exponentialintegralei' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double exponentialintegralei(double x)
    {
    double result = _core_exponentialintegralei( x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_exponentialintegralen(double x, int n, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        x_int _d_n = new x_int(n);
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_exponentialintegralen(&_s_errormsg, &_d_result, &_d_x, &_d_n);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'exponentialintegralen' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double exponentialintegralen(double x, int n)
    {
    double result = _core_exponentialintegralen( x,  n, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage fdistr
    //
    
    private static unsafe double _core_fdistribution(int a, int b, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_a = new x_int(a);
        x_int _d_b = new x_int(b);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_fdistribution(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double fdistribution(int a, int b, double x)
    {
    double result = _core_fdistribution( a,  b,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_fcdistribution(int a, int b, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_a = new x_int(a);
        x_int _d_b = new x_int(b);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_fcdistribution(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fcdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double fcdistribution(int a, int b, double x)
    {
    double result = _core_fcdistribution( a,  b,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_invfdistribution(int a, int b, double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_a = new x_int(a);
        x_int _d_b = new x_int(b);
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_invfdistribution(&_s_errormsg, &_d_result, &_d_a, &_d_b, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'invfdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double invfdistribution(int a, int b, double y)
    {
    double result = _core_invfdistribution( a,  b,  y, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage fresnel
    //
    
    private static unsafe void _core_fresnelintegral(double x, ref double c, ref double s, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_x = x;
        double _d_c = c;
        double _d_s = s;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_fresnelintegral(&_s_errormsg, &_d_x, &_d_c, &_d_s);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'fresnelintegral' call");
            }
            c = _d_c;
            s = _d_s;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void fresnelintegral(double x, ref double c, ref double s)
    {
    _core_fresnelintegral( x, ref  c, ref  s, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage hermite
    //
    
    private static unsafe double _core_hermitecalculate(int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hermitecalculate(&_s_errormsg, &_d_result, &_d_n, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hermitecalculate' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double hermitecalculate(int n, double x)
    {
    double result = _core_hermitecalculate( n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_hermitesum(double[] c, int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_hermitesum(&_s_errormsg, &_d_result, &_d_c, &_d_n, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hermitesum' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        return result;
    }
    public static double hermitesum(double[] c, int n, double x)
    {
    double result = _core_hermitesum( c,  n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_hermitecoefficients(int n, out double[] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            _error_code = _i_ser_hermitecoefficients(&_s_errormsg, &_d_n, &_d_c);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hermitecoefficients' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void hermitecoefficients(int n, out double[] c)
    {
    _core_hermitecoefficients( n, out  c, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage jacobianelliptic
    //
    
    private static unsafe void _core_jacobianellipticfunctions(double u, double m, out double sn, out double cn, out double dn, out double ph, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_u = u;
        double _d_m = m;
        double _d_sn = 0;
        double _d_cn = 0;
        double _d_dn = 0;
        double _d_ph = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_jacobianellipticfunctions(&_s_errormsg, &_d_u, &_d_m, &_d_sn, &_d_cn, &_d_dn, &_d_ph);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'jacobianellipticfunctions' call");
            }
            sn = _d_sn;
            cn = _d_cn;
            dn = _d_dn;
            ph = _d_ph;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void jacobianellipticfunctions(double u, double m, out double sn, out double cn, out double dn, out double ph)
    {
    _core_jacobianellipticfunctions( u,  m, out  sn, out  cn, out  dn, out  ph, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage laguerre
    //
    
    private static unsafe double _core_laguerrecalculate(int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_laguerrecalculate(&_s_errormsg, &_d_result, &_d_n, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'laguerrecalculate' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double laguerrecalculate(int n, double x)
    {
    double result = _core_laguerrecalculate( n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_laguerresum(double[] c, int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_laguerresum(&_s_errormsg, &_d_result, &_d_c, &_d_n, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'laguerresum' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        return result;
    }
    public static double laguerresum(double[] c, int n, double x)
    {
    double result = _core_laguerresum( c,  n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_laguerrecoefficients(int n, out double[] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            _error_code = _i_ser_laguerrecoefficients(&_s_errormsg, &_d_n, &_d_c);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'laguerrecoefficients' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void laguerrecoefficients(int n, out double[] c)
    {
    _core_laguerrecoefficients( n, out  c, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage legendre
    //
    
    private static unsafe double _core_legendrecalculate(int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_legendrecalculate(&_s_errormsg, &_d_result, &_d_n, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'legendrecalculate' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double legendrecalculate(int n, double x)
    {
    double result = _core_legendrecalculate( n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_legendresum(double[] c, int n, double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_vector _d_c = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_c = c){
                x_vector_attach_to_array(ref _d_c, _fp_c, ap.len(c));
                _error_code = _i_ser_legendresum(&_s_errormsg, &_d_result, &_d_c, &_d_n, &_d_x);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'legendresum' call");
            }
            result = _d_result;
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        return result;
    }
    public static double legendresum(double[] c, int n, double x)
    {
    double result = _core_legendresum( c,  n,  x, alglibmode.serial);
    return result;
    }
    private static unsafe void _core_legendrecoefficients(int n, out double[] c, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_int _d_n = new x_int(n);
        x_vector _d_c = new x_vector();
        
        // Pack, call, unpack
        try
        {
            x_vector_create_empty(ref _d_c, DT_REAL);
            c = null;
            _error_code = _i_ser_legendrecoefficients(&_s_errormsg, &_d_n, &_d_c);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'legendrecoefficients' call");
            }
            if( _d_c.last_action==ACT_NEW_LOCATION )
                x_vector_to_array(ref _d_c, ref c);
            if( c == null )
                c = new double[0];
        }
        finally
        {
            x_vector_clear(ref _d_c);
        }
        // This function returns no value.
    }
    public static void legendrecoefficients(int n, out double[] c)
    {
    _core_legendrecoefficients( n, out  c, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage poissondistr
    //
    
    private static unsafe double _core_poissondistribution(int k, double m, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_poissondistribution(&_s_errormsg, &_d_result, &_d_k, &_d_m);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'poissondistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double poissondistribution(int k, double m)
    {
    double result = _core_poissondistribution( k,  m, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_poissoncdistribution(int k, double m, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_m = m;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_poissoncdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_m);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'poissoncdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double poissoncdistribution(int k, double m)
    {
    double result = _core_poissoncdistribution( k,  m, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_invpoissondistribution(int k, double y, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_y = y;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_invpoissondistribution(&_s_errormsg, &_d_result, &_d_k, &_d_y);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'invpoissondistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double invpoissondistribution(int k, double y)
    {
    double result = _core_invpoissondistribution( k,  y, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage psif
    //
    
    private static unsafe double _core_psi(double x, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        double _d_x = x;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_psi(&_s_errormsg, &_d_result, &_d_x);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'psi' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double psi(double x)
    {
    double result = _core_psi( x, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage studenttdistr
    //
    
    private static unsafe double _core_studenttdistribution(int k, double t, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_t = t;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_studenttdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_t);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'studenttdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double studenttdistribution(int k, double t)
    {
    double result = _core_studenttdistribution( k,  t, alglibmode.serial);
    return result;
    }
    private static unsafe double _core_invstudenttdistribution(int k, double p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double result;
        double _d_result = 0;
        x_int _d_k = new x_int(k);
        double _d_p = p;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_invstudenttdistribution(&_s_errormsg, &_d_result, &_d_k, &_d_p);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'invstudenttdistribution' call");
            }
            result = _d_result;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        return result;
    }
    public static double invstudenttdistribution(int k, double p)
    {
    double result = _core_invstudenttdistribution( k,  p, alglibmode.serial);
    return result;
    }
    
    
    //
    // Subpackage trigintegrals
    //
    
    private static unsafe void _core_sinecosineintegrals(double x, out double si, out double ci, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_x = x;
        double _d_si = 0;
        double _d_ci = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_sinecosineintegrals(&_s_errormsg, &_d_x, &_d_si, &_d_ci);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'sinecosineintegrals' call");
            }
            si = _d_si;
            ci = _d_ci;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void sinecosineintegrals(double x, out double si, out double ci)
    {
    _core_sinecosineintegrals( x, out  si, out  ci, alglibmode.serial);
    return;
    }
    private static unsafe void _core_hyperbolicsinecosineintegrals(double x, out double shi, out double chi, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_x = x;
        double _d_shi = 0;
        double _d_chi = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_hyperbolicsinecosineintegrals(&_s_errormsg, &_d_x, &_d_shi, &_d_chi);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'hyperbolicsinecosineintegrals' call");
            }
            shi = _d_shi;
            chi = _d_chi;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void hyperbolicsinecosineintegrals(double x, out double shi, out double chi)
    {
    _core_hyperbolicsinecosineintegrals( x, out  shi, out  chi, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage correlationtests
    //
    
    private static unsafe void _core_pearsoncorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_r = r;
        x_int _d_n = new x_int(n);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_pearsoncorrelationsignificance(&_s_errormsg, &_d_r, &_d_n, &_d_bothtails, &_d_lefttail, &_d_righttail);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'pearsoncorrelationsignificance' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void pearsoncorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail)
    {
    _core_pearsoncorrelationsignificance( r,  n, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    private static unsafe void _core_spearmanrankcorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        double _d_r = r;
        x_int _d_n = new x_int(n);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {

            _error_code = _i_ser_spearmanrankcorrelationsignificance(&_s_errormsg, &_d_r, &_d_n, &_d_bothtails, &_d_lefttail, &_d_righttail);
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'spearmanrankcorrelationsignificance' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            // No dynamically allocated data to clear
        }
        // This function returns no value.
    }
    public static void spearmanrankcorrelationsignificance(double r, int n, out double bothtails, out double lefttail, out double righttail)
    {
    _core_spearmanrankcorrelationsignificance( r,  n, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage jarquebera
    //
    
    private static unsafe void _core_jarqueberatest(double[] x, int n, out double p, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_p = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_jarqueberatest(&_s_errormsg, &_d_x, &_d_n, &_d_p);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'jarqueberatest' call");
            }
            p = _d_p;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void jarqueberatest(double[] x, int n, out double p)
    {
    _core_jarqueberatest( x,  n, out  p, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage mannwhitneyu
    //
    
    private static unsafe void _core_mannwhitneyutest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_mannwhitneyutest(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_bothtails, &_d_lefttail, &_d_righttail);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'mannwhitneyutest' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void mannwhitneyutest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail)
    {
    _core_mannwhitneyutest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage stest
    //
    
    private static unsafe void _core_onesamplesigntest(double[] x, int n, double median, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_median = median;
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_onesamplesigntest(&_s_errormsg, &_d_x, &_d_n, &_d_median, &_d_bothtails, &_d_lefttail, &_d_righttail);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'onesamplesigntest' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void onesamplesigntest(double[] x, int n, double median, out double bothtails, out double lefttail, out double righttail)
    {
    _core_onesamplesigntest( x,  n,  median, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage studentttests
    //
    
    private static unsafe void _core_studentttest1(double[] x, int n, double mean, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_mean = mean;
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_studentttest1(&_s_errormsg, &_d_x, &_d_n, &_d_mean, &_d_bothtails, &_d_lefttail, &_d_righttail);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'studentttest1' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void studentttest1(double[] x, int n, double mean, out double bothtails, out double lefttail, out double righttail)
    {
    _core_studentttest1( x,  n,  mean, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    private static unsafe void _core_studentttest2(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_studentttest2(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_bothtails, &_d_lefttail, &_d_righttail);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'studentttest2' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void studentttest2(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail)
    {
    _core_studentttest2( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    private static unsafe void _core_unequalvariancettest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_unequalvariancettest(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_bothtails, &_d_lefttail, &_d_righttail);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'unequalvariancettest' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void unequalvariancettest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail)
    {
    _core_unequalvariancettest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage variancetests
    //
    
    private static unsafe void _core_ftest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        x_vector _d_y = new x_vector();
        x_int _d_m = new x_int(m);
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x, _fp_y = y){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                x_vector_attach_to_array(ref _d_y, _fp_y, ap.len(y));
                _error_code = _i_ser_ftest(&_s_errormsg, &_d_x, &_d_n, &_d_y, &_d_m, &_d_bothtails, &_d_lefttail, &_d_righttail);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'ftest' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
            x_vector_clear(ref _d_y);
        }
        // This function returns no value.
    }
    public static void ftest(double[] x, int n, double[] y, int m, out double bothtails, out double lefttail, out double righttail)
    {
    _core_ftest( x,  n,  y,  m, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    private static unsafe void _core_onesamplevariancetest(double[] x, int n, double variance, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_variance = variance;
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_onesamplevariancetest(&_s_errormsg, &_d_x, &_d_n, &_d_variance, &_d_bothtails, &_d_lefttail, &_d_righttail);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'onesamplevariancetest' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void onesamplevariancetest(double[] x, int n, double variance, out double bothtails, out double lefttail, out double righttail)
    {
    _core_onesamplevariancetest( x,  n,  variance, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage wsr
    //
    
    private static unsafe void _core_wilcoxonsignedranktest(double[] x, int n, double e, out double bothtails, out double lefttail, out double righttail, alglibmode _alglib_mode)
    {
        // primary initialization
        if( hAlglibDL==IntPtr.Zero )
            activatealglibcore();
        
        // Locals
        byte *_s_errormsg = null;
        int _error_code = 0;
        x_vector _d_x = new x_vector();
        x_int _d_n = new x_int(n);
        double _d_e = e;
        double _d_bothtails = 0;
        double _d_lefttail = 0;
        double _d_righttail = 0;
        
        // Pack, call, unpack
        try
        {
            fixed(double* _fp_x = x){
                x_vector_attach_to_array(ref _d_x, _fp_x, ap.len(x));
                _error_code = _i_ser_wilcoxonsignedranktest(&_s_errormsg, &_d_x, &_d_n, &_d_e, &_d_bothtails, &_d_lefttail, &_d_righttail);
            }
            if( _error_code!=X_OK )
            {
                if( _error_code==X_ASSERTION_FAILED )
                    throw new alglibexception(Marshal.PtrToStringAnsi((IntPtr)_s_errormsg));
                else
                    throw new alglibexception("ALGLIB: unknown error during 'wilcoxonsignedranktest' call");
            }
            bothtails = _d_bothtails;
            lefttail = _d_lefttail;
            righttail = _d_righttail;
        }
        finally
        {
            x_vector_clear(ref _d_x);
        }
        // This function returns no value.
    }
    public static void wilcoxonsignedranktest(double[] x, int n, double e, out double bothtails, out double lefttail, out double righttail)
    {
    _core_wilcoxonsignedranktest( x,  n,  e, out  bothtails, out  lefttail, out  righttail, alglibmode.serial);
    return;
    }
    
    
    //
    // Subpackage alglibbasics
    //
    
    
    //
    // This section holds pointers to ALGLIB functions and declarations
    // of appropriate types.
    //
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_malloc(out IntPtr p, long size);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate int _d_x_free(IntPtr p);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    private unsafe delegate byte _d_x_setnworkers(long nworkers);
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate long _d_x_alloc_counter();
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public  unsafe delegate void _d_x_alloc_counter_activate();
    private static _d_x_malloc                  x_malloc        = null;
    private static _d_x_free                    x_free          = null;
    private static _d_x_setnworkers             x_setnworkers   = null;
    public  static _d_x_alloc_counter           x_alloc_counter   = null;
    public  static _d_x_alloc_counter_activate  x_alloc_counter_activate   = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrndrandomize(byte **error_msg, void **state);
        private static _d_hqrndrandomize _i_ser_hqrndrandomize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrndseed(byte **error_msg, x_int *s1, x_int *s2, void **state);
        private static _d_hqrndseed _i_ser_hqrndseed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrnduniformr(byte **error_msg, double *result, void **state);
        private static _d_hqrnduniformr _i_ser_hqrnduniformr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrnduniformi(byte **error_msg, x_int *result, void **state, x_int *n);
        private static _d_hqrnduniformi _i_ser_hqrnduniformi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrndnormal(byte **error_msg, double *result, void **state);
        private static _d_hqrndnormal _i_ser_hqrndnormal = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrndunit2(byte **error_msg, void **state, double *x, double *y);
        private static _d_hqrndunit2 _i_ser_hqrndunit2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrndnormal2(byte **error_msg, void **state, double *x1, double *x2);
        private static _d_hqrndnormal2 _i_ser_hqrndnormal2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrndexponential(byte **error_msg, double *result, void **state, double *lambdav);
        private static _d_hqrndexponential _i_ser_hqrndexponential = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrnddiscrete(byte **error_msg, double *result, void **state, x_vector *x, x_int *n);
        private static _d_hqrnddiscrete _i_ser_hqrnddiscrete = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hqrndcontinuous(byte **error_msg, double *result, void **state, x_vector *x, x_int *n);
        private static _d_hqrndcontinuous _i_ser_hqrndcontinuous = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_kdtreeserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_kdtreeunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_kdtreeserialize   _i_x_kdtreeserialize   = null;
        private static _d_x_kdtreeunserialize _i_x_kdtreeunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreebuild(byte **error_msg, x_matrix *xy, x_int *n, x_int *nx, x_int *ny, x_int *normtype, void **kdt);
        private static _d_kdtreebuild _i_ser_kdtreebuild = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreebuildtagged(byte **error_msg, x_matrix *xy, x_vector *tags, x_int *n, x_int *nx, x_int *ny, x_int *normtype, void **kdt);
        private static _d_kdtreebuildtagged _i_ser_kdtreebuildtagged = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryknn(byte **error_msg, x_int *result, void **kdt, x_vector *x, x_int *k, byte *selfmatch);
        private static _d_kdtreequeryknn _i_ser_kdtreequeryknn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryrnn(byte **error_msg, x_int *result, void **kdt, x_vector *x, double *r, byte *selfmatch);
        private static _d_kdtreequeryrnn _i_ser_kdtreequeryrnn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryaknn(byte **error_msg, x_int *result, void **kdt, x_vector *x, x_int *k, byte *selfmatch, double *eps);
        private static _d_kdtreequeryaknn _i_ser_kdtreequeryaknn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryresultsx(byte **error_msg, void **kdt, x_matrix *x);
        private static _d_kdtreequeryresultsx _i_ser_kdtreequeryresultsx = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryresultsxy(byte **error_msg, void **kdt, x_matrix *xy);
        private static _d_kdtreequeryresultsxy _i_ser_kdtreequeryresultsxy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryresultstags(byte **error_msg, void **kdt, x_vector *tags);
        private static _d_kdtreequeryresultstags _i_ser_kdtreequeryresultstags = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryresultsdistances(byte **error_msg, void **kdt, x_vector *r);
        private static _d_kdtreequeryresultsdistances _i_ser_kdtreequeryresultsdistances = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryresultsxi(byte **error_msg, void **kdt, x_matrix *x);
        private static _d_kdtreequeryresultsxi _i_ser_kdtreequeryresultsxi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryresultsxyi(byte **error_msg, void **kdt, x_matrix *xy);
        private static _d_kdtreequeryresultsxyi _i_ser_kdtreequeryresultsxyi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryresultstagsi(byte **error_msg, void **kdt, x_vector *tags);
        private static _d_kdtreequeryresultstagsi _i_ser_kdtreequeryresultstagsi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kdtreequeryresultsdistancesi(byte **error_msg, void **kdt, x_vector *r);
        private static _d_kdtreequeryresultsdistancesi _i_ser_kdtreequeryresultsdistancesi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebuginitrecord1(byte **error_msg, x_xdebugrecord1 *rec1);
        private static _d_xdebuginitrecord1 _i_ser_xdebuginitrecord1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugb1count(byte **error_msg, x_int *result, x_vector *a);
        private static _d_xdebugb1count _i_ser_xdebugb1count = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugb1not(byte **error_msg, x_vector *a);
        private static _d_xdebugb1not _i_ser_xdebugb1not = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugb1appendcopy(byte **error_msg, x_vector *a);
        private static _d_xdebugb1appendcopy _i_ser_xdebugb1appendcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugb1outeven(byte **error_msg, x_int *n, x_vector *a);
        private static _d_xdebugb1outeven _i_ser_xdebugb1outeven = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugi1sum(byte **error_msg, x_int *result, x_vector *a);
        private static _d_xdebugi1sum _i_ser_xdebugi1sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugi1neg(byte **error_msg, x_vector *a);
        private static _d_xdebugi1neg _i_ser_xdebugi1neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugi1appendcopy(byte **error_msg, x_vector *a);
        private static _d_xdebugi1appendcopy _i_ser_xdebugi1appendcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugi1outeven(byte **error_msg, x_int *n, x_vector *a);
        private static _d_xdebugi1outeven _i_ser_xdebugi1outeven = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugr1sum(byte **error_msg, double *result, x_vector *a);
        private static _d_xdebugr1sum _i_ser_xdebugr1sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugr1neg(byte **error_msg, x_vector *a);
        private static _d_xdebugr1neg _i_ser_xdebugr1neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugr1appendcopy(byte **error_msg, x_vector *a);
        private static _d_xdebugr1appendcopy _i_ser_xdebugr1appendcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugr1outeven(byte **error_msg, x_int *n, x_vector *a);
        private static _d_xdebugr1outeven _i_ser_xdebugr1outeven = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugc1sum(byte **error_msg, alglib.complex *result, x_vector *a);
        private static _d_xdebugc1sum _i_ser_xdebugc1sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugc1neg(byte **error_msg, x_vector *a);
        private static _d_xdebugc1neg _i_ser_xdebugc1neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugc1appendcopy(byte **error_msg, x_vector *a);
        private static _d_xdebugc1appendcopy _i_ser_xdebugc1appendcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugc1outeven(byte **error_msg, x_int *n, x_vector *a);
        private static _d_xdebugc1outeven _i_ser_xdebugc1outeven = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugb2count(byte **error_msg, x_int *result, x_matrix *a);
        private static _d_xdebugb2count _i_ser_xdebugb2count = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugb2not(byte **error_msg, x_matrix *a);
        private static _d_xdebugb2not _i_ser_xdebugb2not = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugb2transpose(byte **error_msg, x_matrix *a);
        private static _d_xdebugb2transpose _i_ser_xdebugb2transpose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugb2outsin(byte **error_msg, x_int *m, x_int *n, x_matrix *a);
        private static _d_xdebugb2outsin _i_ser_xdebugb2outsin = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugi2sum(byte **error_msg, x_int *result, x_matrix *a);
        private static _d_xdebugi2sum _i_ser_xdebugi2sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugi2neg(byte **error_msg, x_matrix *a);
        private static _d_xdebugi2neg _i_ser_xdebugi2neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugi2transpose(byte **error_msg, x_matrix *a);
        private static _d_xdebugi2transpose _i_ser_xdebugi2transpose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugi2outsin(byte **error_msg, x_int *m, x_int *n, x_matrix *a);
        private static _d_xdebugi2outsin _i_ser_xdebugi2outsin = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugr2sum(byte **error_msg, double *result, x_matrix *a);
        private static _d_xdebugr2sum _i_ser_xdebugr2sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugr2neg(byte **error_msg, x_matrix *a);
        private static _d_xdebugr2neg _i_ser_xdebugr2neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugr2transpose(byte **error_msg, x_matrix *a);
        private static _d_xdebugr2transpose _i_ser_xdebugr2transpose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugr2outsin(byte **error_msg, x_int *m, x_int *n, x_matrix *a);
        private static _d_xdebugr2outsin _i_ser_xdebugr2outsin = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugc2sum(byte **error_msg, alglib.complex *result, x_matrix *a);
        private static _d_xdebugc2sum _i_ser_xdebugc2sum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugc2neg(byte **error_msg, x_matrix *a);
        private static _d_xdebugc2neg _i_ser_xdebugc2neg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugc2transpose(byte **error_msg, x_matrix *a);
        private static _d_xdebugc2transpose _i_ser_xdebugc2transpose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugc2outsincos(byte **error_msg, x_int *m, x_int *n, x_matrix *a);
        private static _d_xdebugc2outsincos _i_ser_xdebugc2outsincos = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_xdebugmaskedbiasedproductsum(byte **error_msg, double *result, x_int *m, x_int *n, x_matrix *a, x_matrix *b, x_matrix *c);
        private static _d_xdebugmaskedbiasedproductsum _i_ser_xdebugmaskedbiasedproductsum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixtranspose(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_matrix *b, x_int *ib, x_int *jb);
        private static _d_cmatrixtranspose _i_ser_cmatrixtranspose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixtranspose(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_matrix *b, x_int *ib, x_int *jb);
        private static _d_rmatrixtranspose _i_ser_rmatrixtranspose = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixenforcesymmetricity(byte **error_msg, x_matrix *a, x_int *n, byte *isupper);
        private static _d_rmatrixenforcesymmetricity _i_ser_rmatrixenforcesymmetricity = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixcopy(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_matrix *b, x_int *ib, x_int *jb);
        private static _d_cmatrixcopy _i_ser_cmatrixcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixcopy(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_matrix *b, x_int *ib, x_int *jb);
        private static _d_rmatrixcopy _i_ser_rmatrixcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixrank1(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_vector *u, x_int *iu, x_vector *v, x_int *iv);
        private static _d_cmatrixrank1 _i_ser_cmatrixrank1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixrank1(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_vector *u, x_int *iu, x_vector *v, x_int *iv);
        private static _d_rmatrixrank1 _i_ser_rmatrixrank1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixmv(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_int *opa, x_vector *x, x_int *ix, x_vector *y, x_int *iy);
        private static _d_cmatrixmv _i_ser_cmatrixmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixmv(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *ia, x_int *ja, x_int *opa, x_vector *x, x_int *ix, x_vector *y, x_int *iy);
        private static _d_rmatrixmv _i_ser_rmatrixmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixrighttrsm(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *i1, x_int *j1, byte *isupper, byte *isunit, x_int *optype, x_matrix *x, x_int *i2, x_int *j2);
        private static _d_cmatrixrighttrsm _i_ser_cmatrixrighttrsm = null;
        private static _d_cmatrixrighttrsm _i_smp_cmatrixrighttrsm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlefttrsm(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *i1, x_int *j1, byte *isupper, byte *isunit, x_int *optype, x_matrix *x, x_int *i2, x_int *j2);
        private static _d_cmatrixlefttrsm _i_ser_cmatrixlefttrsm = null;
        private static _d_cmatrixlefttrsm _i_smp_cmatrixlefttrsm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixrighttrsm(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *i1, x_int *j1, byte *isupper, byte *isunit, x_int *optype, x_matrix *x, x_int *i2, x_int *j2);
        private static _d_rmatrixrighttrsm _i_ser_rmatrixrighttrsm = null;
        private static _d_rmatrixrighttrsm _i_smp_rmatrixrighttrsm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlefttrsm(byte **error_msg, x_int *m, x_int *n, x_matrix *a, x_int *i1, x_int *j1, byte *isupper, byte *isunit, x_int *optype, x_matrix *x, x_int *i2, x_int *j2);
        private static _d_rmatrixlefttrsm _i_ser_rmatrixlefttrsm = null;
        private static _d_rmatrixlefttrsm _i_smp_rmatrixlefttrsm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixherk(byte **error_msg, x_int *n, x_int *k, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, double *beta, x_matrix *c, x_int *ic, x_int *jc, byte *isupper);
        private static _d_cmatrixherk _i_ser_cmatrixherk = null;
        private static _d_cmatrixherk _i_smp_cmatrixherk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixsyrk(byte **error_msg, x_int *n, x_int *k, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, double *beta, x_matrix *c, x_int *ic, x_int *jc, byte *isupper);
        private static _d_rmatrixsyrk _i_ser_rmatrixsyrk = null;
        private static _d_rmatrixsyrk _i_smp_rmatrixsyrk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixgemm(byte **error_msg, x_int *m, x_int *n, x_int *k, alglib.complex *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, x_matrix *b, x_int *ib, x_int *jb, x_int *optypeb, alglib.complex *beta, x_matrix *c, x_int *ic, x_int *jc);
        private static _d_cmatrixgemm _i_ser_cmatrixgemm = null;
        private static _d_cmatrixgemm _i_smp_cmatrixgemm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixgemm(byte **error_msg, x_int *m, x_int *n, x_int *k, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, x_matrix *b, x_int *ib, x_int *jb, x_int *optypeb, double *beta, x_matrix *c, x_int *ic, x_int *jc);
        private static _d_rmatrixgemm _i_ser_rmatrixgemm = null;
        private static _d_rmatrixgemm _i_smp_rmatrixgemm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixsyrk(byte **error_msg, x_int *n, x_int *k, double *alpha, x_matrix *a, x_int *ia, x_int *ja, x_int *optypea, double *beta, x_matrix *c, x_int *ic, x_int *jc, byte *isupper);
        private static _d_cmatrixsyrk _i_ser_cmatrixsyrk = null;
        private static _d_cmatrixsyrk _i_smp_cmatrixsyrk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_samplemoments(byte **error_msg, x_vector *x, x_int *n, double *mean, double *variance, double *skewness, double *kurtosis);
        private static _d_samplemoments _i_ser_samplemoments = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_samplemean(byte **error_msg, double *result, x_vector *x, x_int *n);
        private static _d_samplemean _i_ser_samplemean = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_samplevariance(byte **error_msg, double *result, x_vector *x, x_int *n);
        private static _d_samplevariance _i_ser_samplevariance = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sampleskewness(byte **error_msg, double *result, x_vector *x, x_int *n);
        private static _d_sampleskewness _i_ser_sampleskewness = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_samplekurtosis(byte **error_msg, double *result, x_vector *x, x_int *n);
        private static _d_samplekurtosis _i_ser_samplekurtosis = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sampleadev(byte **error_msg, x_vector *x, x_int *n, double *adev);
        private static _d_sampleadev _i_ser_sampleadev = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_samplemedian(byte **error_msg, x_vector *x, x_int *n, double *median);
        private static _d_samplemedian _i_ser_samplemedian = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_samplepercentile(byte **error_msg, x_vector *x, x_int *n, double *p, double *v);
        private static _d_samplepercentile _i_ser_samplepercentile = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cov2(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n);
        private static _d_cov2 _i_ser_cov2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pearsoncorr2(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n);
        private static _d_pearsoncorr2 _i_ser_pearsoncorr2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spearmancorr2(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n);
        private static _d_spearmancorr2 _i_ser_spearmancorr2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_covm(byte **error_msg, x_matrix *x, x_int *n, x_int *m, x_matrix *c);
        private static _d_covm _i_ser_covm = null;
        private static _d_covm _i_smp_covm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pearsoncorrm(byte **error_msg, x_matrix *x, x_int *n, x_int *m, x_matrix *c);
        private static _d_pearsoncorrm _i_ser_pearsoncorrm = null;
        private static _d_pearsoncorrm _i_smp_pearsoncorrm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spearmancorrm(byte **error_msg, x_matrix *x, x_int *n, x_int *m, x_matrix *c);
        private static _d_spearmancorrm _i_ser_spearmancorrm = null;
        private static _d_spearmancorrm _i_smp_spearmancorrm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_covm2(byte **error_msg, x_matrix *x, x_matrix *y, x_int *n, x_int *m1, x_int *m2, x_matrix *c);
        private static _d_covm2 _i_ser_covm2 = null;
        private static _d_covm2 _i_smp_covm2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pearsoncorrm2(byte **error_msg, x_matrix *x, x_matrix *y, x_int *n, x_int *m1, x_int *m2, x_matrix *c);
        private static _d_pearsoncorrm2 _i_ser_pearsoncorrm2 = null;
        private static _d_pearsoncorrm2 _i_smp_pearsoncorrm2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spearmancorrm2(byte **error_msg, x_matrix *x, x_matrix *y, x_int *n, x_int *m1, x_int *m2, x_matrix *c);
        private static _d_spearmancorrm2 _i_ser_spearmancorrm2 = null;
        private static _d_spearmancorrm2 _i_smp_spearmancorrm2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rankdata(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nfeatures);
        private static _d_rankdata _i_ser_rankdata = null;
        private static _d_rankdata _i_smp_rankdata = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rankdatacentered(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nfeatures);
        private static _d_rankdatacentered _i_ser_rankdatacentered = null;
        private static _d_rankdatacentered _i_smp_rankdatacentered = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pearsoncorrelation(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n);
        private static _d_pearsoncorrelation _i_ser_pearsoncorrelation = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spearmanrankcorrelation(byte **error_msg, double *result, x_vector *x, x_vector *y, x_int *n);
        private static _d_spearmanrankcorrelation _i_ser_spearmanrankcorrelation = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dsoptimalsplit2(byte **error_msg, x_vector *a, x_vector *c, x_int *n, x_int *info, double *threshold, double *pal, double *pbl, double *par, double *pbr, double *cve);
        private static _d_dsoptimalsplit2 _i_ser_dsoptimalsplit2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dsoptimalsplit2fast(byte **error_msg, x_vector *a, x_vector *c, x_vector *tiesbuf, x_vector *cntbuf, x_vector *bufr, x_vector *bufi, x_int *n, x_int *nc, double *alpha, x_int *info, double *threshold, double *rms, double *cvrms);
        private static _d_dsoptimalsplit2fast _i_ser_dsoptimalsplit2fast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizercreate(byte **error_msg, void **s);
        private static _d_clusterizercreate _i_ser_clusterizercreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizersetpoints(byte **error_msg, void **s, x_matrix *xy, x_int *npoints, x_int *nfeatures, x_int *disttype);
        private static _d_clusterizersetpoints _i_ser_clusterizersetpoints = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizersetdistances(byte **error_msg, void **s, x_matrix *d, x_int *npoints, byte *isupper);
        private static _d_clusterizersetdistances _i_ser_clusterizersetdistances = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizersetahcalgo(byte **error_msg, void **s, x_int *algo);
        private static _d_clusterizersetahcalgo _i_ser_clusterizersetahcalgo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizersetkmeanslimits(byte **error_msg, void **s, x_int *restarts, x_int *maxits);
        private static _d_clusterizersetkmeanslimits _i_ser_clusterizersetkmeanslimits = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizersetkmeansinit(byte **error_msg, void **s, x_int *initalgo);
        private static _d_clusterizersetkmeansinit _i_ser_clusterizersetkmeansinit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizerrunahc(byte **error_msg, void **s, x_ahcreport *rep);
        private static _d_clusterizerrunahc _i_ser_clusterizerrunahc = null;
        private static _d_clusterizerrunahc _i_smp_clusterizerrunahc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizerrunkmeans(byte **error_msg, void **s, x_int *k, x_kmeansreport *rep);
        private static _d_clusterizerrunkmeans _i_ser_clusterizerrunkmeans = null;
        private static _d_clusterizerrunkmeans _i_smp_clusterizerrunkmeans = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizergetdistances(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nfeatures, x_int *disttype, x_matrix *d);
        private static _d_clusterizergetdistances _i_ser_clusterizergetdistances = null;
        private static _d_clusterizergetdistances _i_smp_clusterizergetdistances = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizergetkclusters(byte **error_msg, x_ahcreport *rep, x_int *k, x_vector *cidx, x_vector *cz);
        private static _d_clusterizergetkclusters _i_ser_clusterizergetkclusters = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizerseparatedbydist(byte **error_msg, x_ahcreport *rep, double *r, x_int *k, x_vector *cidx, x_vector *cz);
        private static _d_clusterizerseparatedbydist _i_ser_clusterizerseparatedbydist = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_clusterizerseparatedbycorr(byte **error_msg, x_ahcreport *rep, double *r, x_int *k, x_vector *cidx, x_vector *cz);
        private static _d_clusterizerseparatedbycorr _i_ser_clusterizerseparatedbycorr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_kmeansgenerate(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *k, x_int *restarts, x_int *info, x_matrix *c, x_vector *xyc);
        private static _d_kmeansgenerate _i_ser_kmeansgenerate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_dfserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_dfunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_dfserialize   _i_x_dfserialize   = null;
        private static _d_x_dfunserialize _i_x_dfunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfbuildrandomdecisionforest(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *ntrees, double *r, x_int *info, void **df, x_dfreport *rep);
        private static _d_dfbuildrandomdecisionforest _i_ser_dfbuildrandomdecisionforest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfbuildrandomdecisionforestx1(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *ntrees, x_int *nrndvars, double *r, x_int *info, void **df, x_dfreport *rep);
        private static _d_dfbuildrandomdecisionforestx1 _i_ser_dfbuildrandomdecisionforestx1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfprocess(byte **error_msg, void **df, x_vector *x, x_vector *y);
        private static _d_dfprocess _i_ser_dfprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfprocessi(byte **error_msg, void **df, x_vector *x, x_vector *y);
        private static _d_dfprocessi _i_ser_dfprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfrelclserror(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints);
        private static _d_dfrelclserror _i_ser_dfrelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfavgce(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints);
        private static _d_dfavgce _i_ser_dfavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfrmserror(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints);
        private static _d_dfrmserror _i_ser_dfrmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfavgerror(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints);
        private static _d_dfavgerror _i_ser_dfavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dfavgrelerror(byte **error_msg, double *result, void **df, x_matrix *xy, x_int *npoints);
        private static _d_dfavgrelerror _i_ser_dfavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gammafunction(byte **error_msg, double *result, double *x);
        private static _d_gammafunction _i_ser_gammafunction = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lngamma(byte **error_msg, double *result, double *x, double *sgngam);
        private static _d_lngamma _i_ser_lngamma = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_errorfunction(byte **error_msg, double *result, double *x);
        private static _d_errorfunction _i_ser_errorfunction = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_errorfunctionc(byte **error_msg, double *result, double *x);
        private static _d_errorfunctionc _i_ser_errorfunctionc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_normaldistribution(byte **error_msg, double *result, double *x);
        private static _d_normaldistribution _i_ser_normaldistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_inverf(byte **error_msg, double *result, double *e);
        private static _d_inverf _i_ser_inverf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_invnormaldistribution(byte **error_msg, double *result, double *y0);
        private static _d_invnormaldistribution _i_ser_invnormaldistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_incompletegamma(byte **error_msg, double *result, double *a, double *x);
        private static _d_incompletegamma _i_ser_incompletegamma = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_incompletegammac(byte **error_msg, double *result, double *a, double *x);
        private static _d_incompletegammac _i_ser_incompletegammac = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_invincompletegammac(byte **error_msg, double *result, double *a, double *y0);
        private static _d_invincompletegammac _i_ser_invincompletegammac = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixqr(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau);
        private static _d_rmatrixqr _i_ser_rmatrixqr = null;
        private static _d_rmatrixqr _i_smp_rmatrixqr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau);
        private static _d_rmatrixlq _i_ser_rmatrixlq = null;
        private static _d_rmatrixlq _i_smp_rmatrixlq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixqr(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau);
        private static _d_cmatrixqr _i_ser_cmatrixqr = null;
        private static _d_cmatrixqr _i_smp_cmatrixqr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau);
        private static _d_cmatrixlq _i_ser_cmatrixlq = null;
        private static _d_cmatrixlq _i_smp_cmatrixlq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixqrunpackq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, x_int *qcolumns, x_matrix *q);
        private static _d_rmatrixqrunpackq _i_ser_rmatrixqrunpackq = null;
        private static _d_rmatrixqrunpackq _i_smp_rmatrixqrunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixqrunpackr(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_matrix *r);
        private static _d_rmatrixqrunpackr _i_ser_rmatrixqrunpackr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlqunpackq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, x_int *qrows, x_matrix *q);
        private static _d_rmatrixlqunpackq _i_ser_rmatrixlqunpackq = null;
        private static _d_rmatrixlqunpackq _i_smp_rmatrixlqunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlqunpackl(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_matrix *l);
        private static _d_rmatrixlqunpackl _i_ser_rmatrixlqunpackl = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixqrunpackq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, x_int *qcolumns, x_matrix *q);
        private static _d_cmatrixqrunpackq _i_ser_cmatrixqrunpackq = null;
        private static _d_cmatrixqrunpackq _i_smp_cmatrixqrunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixqrunpackr(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_matrix *r);
        private static _d_cmatrixqrunpackr _i_ser_cmatrixqrunpackr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlqunpackq(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tau, x_int *qrows, x_matrix *q);
        private static _d_cmatrixlqunpackq _i_ser_cmatrixlqunpackq = null;
        private static _d_cmatrixlqunpackq _i_smp_cmatrixlqunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlqunpackl(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_matrix *l);
        private static _d_cmatrixlqunpackl _i_ser_cmatrixlqunpackl = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixbd(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *tauq, x_vector *taup);
        private static _d_rmatrixbd _i_ser_rmatrixbd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixbdunpackq(byte **error_msg, x_matrix *qp, x_int *m, x_int *n, x_vector *tauq, x_int *qcolumns, x_matrix *q);
        private static _d_rmatrixbdunpackq _i_ser_rmatrixbdunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixbdmultiplybyq(byte **error_msg, x_matrix *qp, x_int *m, x_int *n, x_vector *tauq, x_matrix *z, x_int *zrows, x_int *zcolumns, byte *fromtheright, byte *dotranspose);
        private static _d_rmatrixbdmultiplybyq _i_ser_rmatrixbdmultiplybyq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixbdunpackpt(byte **error_msg, x_matrix *qp, x_int *m, x_int *n, x_vector *taup, x_int *ptrows, x_matrix *pt);
        private static _d_rmatrixbdunpackpt _i_ser_rmatrixbdunpackpt = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixbdmultiplybyp(byte **error_msg, x_matrix *qp, x_int *m, x_int *n, x_vector *taup, x_matrix *z, x_int *zrows, x_int *zcolumns, byte *fromtheright, byte *dotranspose);
        private static _d_rmatrixbdmultiplybyp _i_ser_rmatrixbdmultiplybyp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixbdunpackdiagonals(byte **error_msg, x_matrix *b, x_int *m, x_int *n, byte *isupper, x_vector *d, x_vector *e);
        private static _d_rmatrixbdunpackdiagonals _i_ser_rmatrixbdunpackdiagonals = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixhessenberg(byte **error_msg, x_matrix *a, x_int *n, x_vector *tau);
        private static _d_rmatrixhessenberg _i_ser_rmatrixhessenberg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixhessenbergunpackq(byte **error_msg, x_matrix *a, x_int *n, x_vector *tau, x_matrix *q);
        private static _d_rmatrixhessenbergunpackq _i_ser_rmatrixhessenbergunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixhessenbergunpackh(byte **error_msg, x_matrix *a, x_int *n, x_matrix *h);
        private static _d_rmatrixhessenbergunpackh _i_ser_rmatrixhessenbergunpackh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixtd(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *tau, x_vector *d, x_vector *e);
        private static _d_smatrixtd _i_ser_smatrixtd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixtdunpackq(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *tau, x_matrix *q);
        private static _d_smatrixtdunpackq _i_ser_smatrixtdunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hmatrixtd(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *tau, x_vector *d, x_vector *e);
        private static _d_hmatrixtd _i_ser_hmatrixtd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hmatrixtdunpackq(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *tau, x_matrix *q);
        private static _d_hmatrixtdunpackq _i_ser_hmatrixtdunpackq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixbdsvd(byte **error_msg, byte *result, x_vector *d, x_vector *e, x_int *n, byte *isupper, byte *isfractionalaccuracyrequired, x_matrix *u, x_int *nru, x_matrix *c, x_int *ncc, x_matrix *vt, x_int *ncvt);
        private static _d_rmatrixbdsvd _i_ser_rmatrixbdsvd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixsvd(byte **error_msg, byte *result, x_matrix *a, x_int *m, x_int *n, x_int *uneeded, x_int *vtneeded, x_int *additionalmemory, x_vector *w, x_matrix *u, x_matrix *vt);
        private static _d_rmatrixsvd _i_ser_rmatrixsvd = null;
        private static _d_rmatrixsvd _i_smp_rmatrixsvd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lrbuild(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *info, void **lm, x_lrreport *ar);
        private static _d_lrbuild _i_ser_lrbuild = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lrbuilds(byte **error_msg, x_matrix *xy, x_vector *s, x_int *npoints, x_int *nvars, x_int *info, void **lm, x_lrreport *ar);
        private static _d_lrbuilds _i_ser_lrbuilds = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lrbuildzs(byte **error_msg, x_matrix *xy, x_vector *s, x_int *npoints, x_int *nvars, x_int *info, void **lm, x_lrreport *ar);
        private static _d_lrbuildzs _i_ser_lrbuildzs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lrbuildz(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *info, void **lm, x_lrreport *ar);
        private static _d_lrbuildz _i_ser_lrbuildz = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lrunpack(byte **error_msg, void **lm, x_vector *v, x_int *nvars);
        private static _d_lrunpack _i_ser_lrunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lrpack(byte **error_msg, x_vector *v, x_int *nvars, void **lm);
        private static _d_lrpack _i_ser_lrpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lrprocess(byte **error_msg, double *result, void **lm, x_vector *x);
        private static _d_lrprocess _i_ser_lrprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lrrmserror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints);
        private static _d_lrrmserror _i_ser_lrrmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lravgerror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints);
        private static _d_lravgerror _i_ser_lravgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lravgrelerror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints);
        private static _d_lravgrelerror _i_ser_lravgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_filtersma(byte **error_msg, x_vector *x, x_int *n, x_int *k);
        private static _d_filtersma _i_ser_filtersma = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_filterema(byte **error_msg, x_vector *x, x_int *n, double *alpha);
        private static _d_filterema _i_ser_filterema = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_filterlrma(byte **error_msg, x_vector *x, x_int *n, x_int *k);
        private static _d_filterlrma _i_ser_filterlrma = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixevd(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, x_vector *d, x_matrix *z);
        private static _d_smatrixevd _i_ser_smatrixevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixevdr(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, double *b1, double *b2, x_int *m, x_vector *w, x_matrix *z);
        private static _d_smatrixevdr _i_ser_smatrixevdr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixevdi(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, x_int *i1, x_int *i2, x_vector *w, x_matrix *z);
        private static _d_smatrixevdi _i_ser_smatrixevdi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hmatrixevd(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, x_vector *d, x_matrix *z);
        private static _d_hmatrixevd _i_ser_hmatrixevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hmatrixevdr(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, double *b1, double *b2, x_int *m, x_vector *w, x_matrix *z);
        private static _d_hmatrixevdr _i_ser_hmatrixevdr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hmatrixevdi(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *zneeded, byte *isupper, x_int *i1, x_int *i2, x_vector *w, x_matrix *z);
        private static _d_hmatrixevdi _i_ser_hmatrixevdi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixtdevd(byte **error_msg, byte *result, x_vector *d, x_vector *e, x_int *n, x_int *zneeded, x_matrix *z);
        private static _d_smatrixtdevd _i_ser_smatrixtdevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixtdevdr(byte **error_msg, byte *result, x_vector *d, x_vector *e, x_int *n, x_int *zneeded, double *a, double *b, x_int *m, x_matrix *z);
        private static _d_smatrixtdevdr _i_ser_smatrixtdevdr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixtdevdi(byte **error_msg, byte *result, x_vector *d, x_vector *e, x_int *n, x_int *zneeded, x_int *i1, x_int *i2, x_matrix *z);
        private static _d_smatrixtdevdi _i_ser_smatrixtdevdi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixevd(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_int *vneeded, x_vector *wr, x_vector *wi, x_matrix *vl, x_matrix *vr);
        private static _d_rmatrixevd _i_ser_rmatrixevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixrndorthogonal(byte **error_msg, x_int *n, x_matrix *a);
        private static _d_rmatrixrndorthogonal _i_ser_rmatrixrndorthogonal = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a);
        private static _d_rmatrixrndcond _i_ser_rmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixrndorthogonal(byte **error_msg, x_int *n, x_matrix *a);
        private static _d_cmatrixrndorthogonal _i_ser_cmatrixrndorthogonal = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a);
        private static _d_cmatrixrndcond _i_ser_cmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a);
        private static _d_smatrixrndcond _i_ser_smatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a);
        private static _d_spdmatrixrndcond _i_ser_spdmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a);
        private static _d_hmatrixrndcond _i_ser_hmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixrndcond(byte **error_msg, x_int *n, double *c, x_matrix *a);
        private static _d_hpdmatrixrndcond _i_ser_hpdmatrixrndcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixrndorthogonalfromtheright(byte **error_msg, x_matrix *a, x_int *m, x_int *n);
        private static _d_rmatrixrndorthogonalfromtheright _i_ser_rmatrixrndorthogonalfromtheright = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixrndorthogonalfromtheleft(byte **error_msg, x_matrix *a, x_int *m, x_int *n);
        private static _d_rmatrixrndorthogonalfromtheleft _i_ser_rmatrixrndorthogonalfromtheleft = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixrndorthogonalfromtheright(byte **error_msg, x_matrix *a, x_int *m, x_int *n);
        private static _d_cmatrixrndorthogonalfromtheright _i_ser_cmatrixrndorthogonalfromtheright = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixrndorthogonalfromtheleft(byte **error_msg, x_matrix *a, x_int *m, x_int *n);
        private static _d_cmatrixrndorthogonalfromtheleft _i_ser_cmatrixrndorthogonalfromtheleft = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixrndmultiply(byte **error_msg, x_matrix *a, x_int *n);
        private static _d_smatrixrndmultiply _i_ser_smatrixrndmultiply = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hmatrixrndmultiply(byte **error_msg, x_matrix *a, x_int *n);
        private static _d_hmatrixrndmultiply _i_ser_hmatrixrndmultiply = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecreate(byte **error_msg, x_int *m, x_int *n, x_int *k, void **s);
        private static _d_sparsecreate _i_ser_sparsecreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecreatebuf(byte **error_msg, x_int *m, x_int *n, x_int *k, void **s);
        private static _d_sparsecreatebuf _i_ser_sparsecreatebuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecreatecrs(byte **error_msg, x_int *m, x_int *n, x_vector *ner, void **s);
        private static _d_sparsecreatecrs _i_ser_sparsecreatecrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecreatecrsbuf(byte **error_msg, x_int *m, x_int *n, x_vector *ner, void **s);
        private static _d_sparsecreatecrsbuf _i_ser_sparsecreatecrsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecreatesks(byte **error_msg, x_int *m, x_int *n, x_vector *d, x_vector *u, void **s);
        private static _d_sparsecreatesks _i_ser_sparsecreatesks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecreatesksbuf(byte **error_msg, x_int *m, x_int *n, x_vector *d, x_vector *u, void **s);
        private static _d_sparsecreatesksbuf _i_ser_sparsecreatesksbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopy(byte **error_msg, void **s0, void **s1);
        private static _d_sparsecopy _i_ser_sparsecopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopybuf(byte **error_msg, void **s0, void **s1);
        private static _d_sparsecopybuf _i_ser_sparsecopybuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseswap(byte **error_msg, void **s0, void **s1);
        private static _d_sparseswap _i_ser_sparseswap = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseadd(byte **error_msg, void **s, x_int *i, x_int *j, double *v);
        private static _d_sparseadd _i_ser_sparseadd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseset(byte **error_msg, void **s, x_int *i, x_int *j, double *v);
        private static _d_sparseset _i_ser_sparseset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseget(byte **error_msg, double *result, void **s, x_int *i, x_int *j);
        private static _d_sparseget _i_ser_sparseget = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsegetdiagonal(byte **error_msg, double *result, void **s, x_int *i);
        private static _d_sparsegetdiagonal _i_ser_sparsegetdiagonal = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsemv(byte **error_msg, void **s, x_vector *x, x_vector *y);
        private static _d_sparsemv _i_ser_sparsemv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsemtv(byte **error_msg, void **s, x_vector *x, x_vector *y);
        private static _d_sparsemtv _i_ser_sparsemtv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsemv2(byte **error_msg, void **s, x_vector *x, x_vector *y0, x_vector *y1);
        private static _d_sparsemv2 _i_ser_sparsemv2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsesmv(byte **error_msg, void **s, byte *isupper, x_vector *x, x_vector *y);
        private static _d_sparsesmv _i_ser_sparsesmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsevsmv(byte **error_msg, double *result, void **s, byte *isupper, x_vector *x);
        private static _d_sparsevsmv _i_ser_sparsevsmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsemm(byte **error_msg, void **s, x_matrix *a, x_int *k, x_matrix *b);
        private static _d_sparsemm _i_ser_sparsemm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsemtm(byte **error_msg, void **s, x_matrix *a, x_int *k, x_matrix *b);
        private static _d_sparsemtm _i_ser_sparsemtm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsemm2(byte **error_msg, void **s, x_matrix *a, x_int *k, x_matrix *b0, x_matrix *b1);
        private static _d_sparsemm2 _i_ser_sparsemm2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsesmm(byte **error_msg, void **s, byte *isupper, x_matrix *a, x_int *k, x_matrix *b);
        private static _d_sparsesmm _i_ser_sparsesmm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsetrmv(byte **error_msg, void **s, byte *isupper, byte *isunit, x_int *optype, x_vector *x, x_vector *y);
        private static _d_sparsetrmv _i_ser_sparsetrmv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsetrsv(byte **error_msg, void **s, byte *isupper, byte *isunit, x_int *optype, x_vector *x);
        private static _d_sparsetrsv _i_ser_sparsetrsv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseresizematrix(byte **error_msg, void **s);
        private static _d_sparseresizematrix _i_ser_sparseresizematrix = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseenumerate(byte **error_msg, byte *result, void **s, x_int *t0, x_int *t1, x_int *i, x_int *j, double *v);
        private static _d_sparseenumerate _i_ser_sparseenumerate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparserewriteexisting(byte **error_msg, byte *result, void **s, x_int *i, x_int *j, double *v);
        private static _d_sparserewriteexisting _i_ser_sparserewriteexisting = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsegetrow(byte **error_msg, void **s, x_int *i, x_vector *irow);
        private static _d_sparsegetrow _i_ser_sparsegetrow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsegetcompressedrow(byte **error_msg, void **s, x_int *i, x_vector *colidx, x_vector *vals, x_int *nzcnt);
        private static _d_sparsegetcompressedrow _i_ser_sparsegetcompressedrow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsetransposesks(byte **error_msg, void **s);
        private static _d_sparsetransposesks _i_ser_sparsetransposesks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseconvertto(byte **error_msg, void **s0, x_int *fmt);
        private static _d_sparseconvertto _i_ser_sparseconvertto = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopytobuf(byte **error_msg, void **s0, x_int *fmt, void **s1);
        private static _d_sparsecopytobuf _i_ser_sparsecopytobuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseconverttohash(byte **error_msg, void **s);
        private static _d_sparseconverttohash _i_ser_sparseconverttohash = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopytohash(byte **error_msg, void **s0, void **s1);
        private static _d_sparsecopytohash _i_ser_sparsecopytohash = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopytohashbuf(byte **error_msg, void **s0, void **s1);
        private static _d_sparsecopytohashbuf _i_ser_sparsecopytohashbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseconverttocrs(byte **error_msg, void **s);
        private static _d_sparseconverttocrs _i_ser_sparseconverttocrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopytocrs(byte **error_msg, void **s0, void **s1);
        private static _d_sparsecopytocrs _i_ser_sparsecopytocrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopytocrsbuf(byte **error_msg, void **s0, void **s1);
        private static _d_sparsecopytocrsbuf _i_ser_sparsecopytocrsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseconverttosks(byte **error_msg, void **s);
        private static _d_sparseconverttosks _i_ser_sparseconverttosks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopytosks(byte **error_msg, void **s0, void **s1);
        private static _d_sparsecopytosks _i_ser_sparsecopytosks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecopytosksbuf(byte **error_msg, void **s0, void **s1);
        private static _d_sparsecopytosksbuf _i_ser_sparsecopytosksbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsegetmatrixtype(byte **error_msg, x_int *result, void **s);
        private static _d_sparsegetmatrixtype _i_ser_sparsegetmatrixtype = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseishash(byte **error_msg, byte *result, void **s);
        private static _d_sparseishash _i_ser_sparseishash = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseiscrs(byte **error_msg, byte *result, void **s);
        private static _d_sparseiscrs _i_ser_sparseiscrs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparseissks(byte **error_msg, byte *result, void **s);
        private static _d_sparseissks _i_ser_sparseissks = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsefree(byte **error_msg, void **s);
        private static _d_sparsefree _i_ser_sparsefree = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsegetnrows(byte **error_msg, x_int *result, void **s);
        private static _d_sparsegetnrows _i_ser_sparsegetnrows = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsegetncols(byte **error_msg, x_int *result, void **s);
        private static _d_sparsegetncols _i_ser_sparsegetncols = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsegetuppercount(byte **error_msg, x_int *result, void **s);
        private static _d_sparsegetuppercount _i_ser_sparsegetuppercount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsegetlowercount(byte **error_msg, x_int *result, void **s);
        private static _d_sparsegetlowercount _i_ser_sparsegetlowercount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlu(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *pivots);
        private static _d_rmatrixlu _i_ser_rmatrixlu = null;
        private static _d_rmatrixlu _i_smp_rmatrixlu = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlu(byte **error_msg, x_matrix *a, x_int *m, x_int *n, x_vector *pivots);
        private static _d_cmatrixlu _i_ser_cmatrixlu = null;
        private static _d_cmatrixlu _i_smp_cmatrixlu = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixcholesky(byte **error_msg, byte *result, x_matrix *a, x_int *n, byte *isupper);
        private static _d_hpdmatrixcholesky _i_ser_hpdmatrixcholesky = null;
        private static _d_hpdmatrixcholesky _i_smp_hpdmatrixcholesky = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholesky(byte **error_msg, byte *result, x_matrix *a, x_int *n, byte *isupper);
        private static _d_spdmatrixcholesky _i_ser_spdmatrixcholesky = null;
        private static _d_spdmatrixcholesky _i_smp_spdmatrixcholesky = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskyupdateadd1(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *u);
        private static _d_spdmatrixcholeskyupdateadd1 _i_ser_spdmatrixcholeskyupdateadd1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskyupdatefix(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *fix);
        private static _d_spdmatrixcholeskyupdatefix _i_ser_spdmatrixcholeskyupdatefix = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskyupdateadd1buf(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *u, x_vector *bufr);
        private static _d_spdmatrixcholeskyupdateadd1buf _i_ser_spdmatrixcholeskyupdateadd1buf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskyupdatefixbuf(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *fix, x_vector *bufr);
        private static _d_spdmatrixcholeskyupdatefixbuf _i_ser_spdmatrixcholeskyupdatefixbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sparsecholeskyskyline(byte **error_msg, byte *result, void **a, x_int *n, byte *isupper);
        private static _d_sparsecholeskyskyline _i_ser_sparsecholeskyskyline = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixrcond1(byte **error_msg, double *result, x_matrix *a, x_int *n);
        private static _d_rmatrixrcond1 _i_ser_rmatrixrcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixrcondinf(byte **error_msg, double *result, x_matrix *a, x_int *n);
        private static _d_rmatrixrcondinf _i_ser_rmatrixrcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixrcond(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper);
        private static _d_spdmatrixrcond _i_ser_spdmatrixrcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixtrrcond1(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, byte *isunit);
        private static _d_rmatrixtrrcond1 _i_ser_rmatrixtrrcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixtrrcondinf(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, byte *isunit);
        private static _d_rmatrixtrrcondinf _i_ser_rmatrixtrrcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixrcond(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper);
        private static _d_hpdmatrixrcond _i_ser_hpdmatrixrcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixrcond1(byte **error_msg, double *result, x_matrix *a, x_int *n);
        private static _d_cmatrixrcond1 _i_ser_cmatrixrcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixrcondinf(byte **error_msg, double *result, x_matrix *a, x_int *n);
        private static _d_cmatrixrcondinf _i_ser_cmatrixrcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlurcond1(byte **error_msg, double *result, x_matrix *lua, x_int *n);
        private static _d_rmatrixlurcond1 _i_ser_rmatrixlurcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlurcondinf(byte **error_msg, double *result, x_matrix *lua, x_int *n);
        private static _d_rmatrixlurcondinf _i_ser_rmatrixlurcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskyrcond(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper);
        private static _d_spdmatrixcholeskyrcond _i_ser_spdmatrixcholeskyrcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixcholeskyrcond(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper);
        private static _d_hpdmatrixcholeskyrcond _i_ser_hpdmatrixcholeskyrcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlurcond1(byte **error_msg, double *result, x_matrix *lua, x_int *n);
        private static _d_cmatrixlurcond1 _i_ser_cmatrixlurcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlurcondinf(byte **error_msg, double *result, x_matrix *lua, x_int *n);
        private static _d_cmatrixlurcondinf _i_ser_cmatrixlurcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixtrrcond1(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, byte *isunit);
        private static _d_cmatrixtrrcond1 _i_ser_cmatrixtrrcond1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixtrrcondinf(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper, byte *isunit);
        private static _d_cmatrixtrrcondinf _i_ser_cmatrixtrrcondinf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixluinverse(byte **error_msg, x_matrix *a, x_vector *pivots, x_int *n, x_int *info, x_matinvreport *rep);
        private static _d_rmatrixluinverse _i_ser_rmatrixluinverse = null;
        private static _d_rmatrixluinverse _i_smp_rmatrixluinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixinverse(byte **error_msg, x_matrix *a, x_int *n, x_int *info, x_matinvreport *rep);
        private static _d_rmatrixinverse _i_ser_rmatrixinverse = null;
        private static _d_rmatrixinverse _i_smp_rmatrixinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixluinverse(byte **error_msg, x_matrix *a, x_vector *pivots, x_int *n, x_int *info, x_matinvreport *rep);
        private static _d_cmatrixluinverse _i_ser_cmatrixluinverse = null;
        private static _d_cmatrixluinverse _i_smp_cmatrixluinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixinverse(byte **error_msg, x_matrix *a, x_int *n, x_int *info, x_matinvreport *rep);
        private static _d_cmatrixinverse _i_ser_cmatrixinverse = null;
        private static _d_cmatrixinverse _i_smp_cmatrixinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskyinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_int *info, x_matinvreport *rep);
        private static _d_spdmatrixcholeskyinverse _i_ser_spdmatrixcholeskyinverse = null;
        private static _d_spdmatrixcholeskyinverse _i_smp_spdmatrixcholeskyinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_int *info, x_matinvreport *rep);
        private static _d_spdmatrixinverse _i_ser_spdmatrixinverse = null;
        private static _d_spdmatrixinverse _i_smp_spdmatrixinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixcholeskyinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_int *info, x_matinvreport *rep);
        private static _d_hpdmatrixcholeskyinverse _i_ser_hpdmatrixcholeskyinverse = null;
        private static _d_hpdmatrixcholeskyinverse _i_smp_hpdmatrixcholeskyinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_int *info, x_matinvreport *rep);
        private static _d_hpdmatrixinverse _i_ser_hpdmatrixinverse = null;
        private static _d_hpdmatrixinverse _i_smp_hpdmatrixinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixtrinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, byte *isunit, x_int *info, x_matinvreport *rep);
        private static _d_rmatrixtrinverse _i_ser_rmatrixtrinverse = null;
        private static _d_rmatrixtrinverse _i_smp_rmatrixtrinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixtrinverse(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, byte *isunit, x_int *info, x_matinvreport *rep);
        private static _d_cmatrixtrinverse _i_ser_cmatrixtrinverse = null;
        private static _d_cmatrixtrinverse _i_smp_cmatrixtrinverse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fisherlda(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *info, x_vector *w);
        private static _d_fisherlda _i_ser_fisherlda = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fisherldan(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *info, x_matrix *w);
        private static _d_fisherldan _i_ser_fisherldan = null;
        private static _d_fisherldan _i_smp_fisherldan = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_mlpserialize   _i_x_mlpserialize   = null;
        private static _d_x_mlpunserialize _i_x_mlpunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreate0(byte **error_msg, x_int *nin, x_int *nout, void **network);
        private static _d_mlpcreate0 _i_ser_mlpcreate0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreate1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, void **network);
        private static _d_mlpcreate1 _i_ser_mlpcreate1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreate2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, void **network);
        private static _d_mlpcreate2 _i_ser_mlpcreate2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreateb0(byte **error_msg, x_int *nin, x_int *nout, double *b, double *d, void **network);
        private static _d_mlpcreateb0 _i_ser_mlpcreateb0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreateb1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, double *b, double *d, void **network);
        private static _d_mlpcreateb1 _i_ser_mlpcreateb1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreateb2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, double *b, double *d, void **network);
        private static _d_mlpcreateb2 _i_ser_mlpcreateb2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreater0(byte **error_msg, x_int *nin, x_int *nout, double *a, double *b, void **network);
        private static _d_mlpcreater0 _i_ser_mlpcreater0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreater1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, double *a, double *b, void **network);
        private static _d_mlpcreater1 _i_ser_mlpcreater1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreater2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, double *a, double *b, void **network);
        private static _d_mlpcreater2 _i_ser_mlpcreater2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreatec0(byte **error_msg, x_int *nin, x_int *nout, void **network);
        private static _d_mlpcreatec0 _i_ser_mlpcreatec0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreatec1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, void **network);
        private static _d_mlpcreatec1 _i_ser_mlpcreatec1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreatec2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, void **network);
        private static _d_mlpcreatec2 _i_ser_mlpcreatec2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcopy(byte **error_msg, void **network1, void **network2);
        private static _d_mlpcopy _i_ser_mlpcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcopytunableparameters(byte **error_msg, void **network1, void **network2);
        private static _d_mlpcopytunableparameters _i_ser_mlpcopytunableparameters = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlprandomize(byte **error_msg, void **network);
        private static _d_mlprandomize _i_ser_mlprandomize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlprandomizefull(byte **error_msg, void **network);
        private static _d_mlprandomizefull _i_ser_mlprandomizefull = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpinitpreprocessor(byte **error_msg, void **network, x_matrix *xy, x_int *ssize);
        private static _d_mlpinitpreprocessor _i_ser_mlpinitpreprocessor = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpproperties(byte **error_msg, void **network, x_int *nin, x_int *nout, x_int *wcount);
        private static _d_mlpproperties _i_ser_mlpproperties = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetinputscount(byte **error_msg, x_int *result, void **network);
        private static _d_mlpgetinputscount _i_ser_mlpgetinputscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetoutputscount(byte **error_msg, x_int *result, void **network);
        private static _d_mlpgetoutputscount _i_ser_mlpgetoutputscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetweightscount(byte **error_msg, x_int *result, void **network);
        private static _d_mlpgetweightscount _i_ser_mlpgetweightscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpissoftmax(byte **error_msg, byte *result, void **network);
        private static _d_mlpissoftmax _i_ser_mlpissoftmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetlayerscount(byte **error_msg, x_int *result, void **network);
        private static _d_mlpgetlayerscount _i_ser_mlpgetlayerscount = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetlayersize(byte **error_msg, x_int *result, void **network, x_int *k);
        private static _d_mlpgetlayersize _i_ser_mlpgetlayersize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetinputscaling(byte **error_msg, void **network, x_int *i, double *mean, double *sigma);
        private static _d_mlpgetinputscaling _i_ser_mlpgetinputscaling = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetoutputscaling(byte **error_msg, void **network, x_int *i, double *mean, double *sigma);
        private static _d_mlpgetoutputscaling _i_ser_mlpgetoutputscaling = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetneuroninfo(byte **error_msg, void **network, x_int *k, x_int *i, x_int *fkind, double *threshold);
        private static _d_mlpgetneuroninfo _i_ser_mlpgetneuroninfo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgetweight(byte **error_msg, double *result, void **network, x_int *k0, x_int *i0, x_int *k1, x_int *i1);
        private static _d_mlpgetweight _i_ser_mlpgetweight = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetinputscaling(byte **error_msg, void **network, x_int *i, double *mean, double *sigma);
        private static _d_mlpsetinputscaling _i_ser_mlpsetinputscaling = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetoutputscaling(byte **error_msg, void **network, x_int *i, double *mean, double *sigma);
        private static _d_mlpsetoutputscaling _i_ser_mlpsetoutputscaling = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetneuroninfo(byte **error_msg, void **network, x_int *k, x_int *i, x_int *fkind, double *threshold);
        private static _d_mlpsetneuroninfo _i_ser_mlpsetneuroninfo = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetweight(byte **error_msg, void **network, x_int *k0, x_int *i0, x_int *k1, x_int *i1, double *w);
        private static _d_mlpsetweight _i_ser_mlpsetweight = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpactivationfunction(byte **error_msg, double *net, x_int *k, double *f, double *df, double *d2f);
        private static _d_mlpactivationfunction _i_ser_mlpactivationfunction = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpprocess(byte **error_msg, void **network, x_vector *x, x_vector *y);
        private static _d_mlpprocess _i_ser_mlpprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpprocessi(byte **error_msg, void **network, x_vector *x, x_vector *y);
        private static _d_mlpprocessi _i_ser_mlpprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlperror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints);
        private static _d_mlperror _i_ser_mlperror = null;
        private static _d_mlperror _i_smp_mlperror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlperrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints);
        private static _d_mlperrorsparse _i_ser_mlperrorsparse = null;
        private static _d_mlperrorsparse _i_smp_mlperrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlperrorn(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *ssize);
        private static _d_mlperrorn _i_ser_mlperrorn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpclserror(byte **error_msg, x_int *result, void **network, x_matrix *xy, x_int *npoints);
        private static _d_mlpclserror _i_ser_mlpclserror = null;
        private static _d_mlpclserror _i_smp_mlpclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlprelclserror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints);
        private static _d_mlprelclserror _i_ser_mlprelclserror = null;
        private static _d_mlprelclserror _i_smp_mlprelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlprelclserrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints);
        private static _d_mlprelclserrorsparse _i_ser_mlprelclserrorsparse = null;
        private static _d_mlprelclserrorsparse _i_smp_mlprelclserrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpavgce(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints);
        private static _d_mlpavgce _i_ser_mlpavgce = null;
        private static _d_mlpavgce _i_smp_mlpavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpavgcesparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints);
        private static _d_mlpavgcesparse _i_ser_mlpavgcesparse = null;
        private static _d_mlpavgcesparse _i_smp_mlpavgcesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlprmserror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints);
        private static _d_mlprmserror _i_ser_mlprmserror = null;
        private static _d_mlprmserror _i_smp_mlprmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlprmserrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints);
        private static _d_mlprmserrorsparse _i_ser_mlprmserrorsparse = null;
        private static _d_mlprmserrorsparse _i_smp_mlprmserrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpavgerror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints);
        private static _d_mlpavgerror _i_ser_mlpavgerror = null;
        private static _d_mlpavgerror _i_smp_mlpavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpavgerrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints);
        private static _d_mlpavgerrorsparse _i_ser_mlpavgerrorsparse = null;
        private static _d_mlpavgerrorsparse _i_smp_mlpavgerrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpavgrelerror(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *npoints);
        private static _d_mlpavgrelerror _i_ser_mlpavgrelerror = null;
        private static _d_mlpavgrelerror _i_smp_mlpavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpavgrelerrorsparse(byte **error_msg, double *result, void **network, void **xy, x_int *npoints);
        private static _d_mlpavgrelerrorsparse _i_ser_mlpavgrelerrorsparse = null;
        private static _d_mlpavgrelerrorsparse _i_smp_mlpavgrelerrorsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgrad(byte **error_msg, void **network, x_vector *x, x_vector *desiredy, double *e, x_vector *grad);
        private static _d_mlpgrad _i_ser_mlpgrad = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgradn(byte **error_msg, void **network, x_vector *x, x_vector *desiredy, double *e, x_vector *grad);
        private static _d_mlpgradn _i_ser_mlpgradn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgradbatch(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, double *e, x_vector *grad);
        private static _d_mlpgradbatch _i_ser_mlpgradbatch = null;
        private static _d_mlpgradbatch _i_smp_mlpgradbatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgradbatchsparse(byte **error_msg, void **network, void **xy, x_int *ssize, double *e, x_vector *grad);
        private static _d_mlpgradbatchsparse _i_ser_mlpgradbatchsparse = null;
        private static _d_mlpgradbatchsparse _i_smp_mlpgradbatchsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgradbatchsubset(byte **error_msg, void **network, x_matrix *xy, x_int *setsize, x_vector *idx, x_int *subsetsize, double *e, x_vector *grad);
        private static _d_mlpgradbatchsubset _i_ser_mlpgradbatchsubset = null;
        private static _d_mlpgradbatchsubset _i_smp_mlpgradbatchsubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgradbatchsparsesubset(byte **error_msg, void **network, void **xy, x_int *setsize, x_vector *idx, x_int *subsetsize, double *e, x_vector *grad);
        private static _d_mlpgradbatchsparsesubset _i_ser_mlpgradbatchsparsesubset = null;
        private static _d_mlpgradbatchsparsesubset _i_smp_mlpgradbatchsparsesubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpgradnbatch(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, double *e, x_vector *grad);
        private static _d_mlpgradnbatch _i_ser_mlpgradnbatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlphessiannbatch(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, double *e, x_vector *grad, x_matrix *h);
        private static _d_mlphessiannbatch _i_ser_mlphessiannbatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlphessianbatch(byte **error_msg, void **network, x_matrix *xy, x_int *ssize, double *e, x_vector *grad, x_matrix *h);
        private static _d_mlphessianbatch _i_ser_mlphessianbatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpallerrorssubset(byte **error_msg, void **network, x_matrix *xy, x_int *setsize, x_vector *subset, x_int *subsetsize, x_modelerrors *rep);
        private static _d_mlpallerrorssubset _i_ser_mlpallerrorssubset = null;
        private static _d_mlpallerrorssubset _i_smp_mlpallerrorssubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpallerrorssparsesubset(byte **error_msg, void **network, void **xy, x_int *setsize, x_vector *subset, x_int *subsetsize, x_modelerrors *rep);
        private static _d_mlpallerrorssparsesubset _i_ser_mlpallerrorssparsesubset = null;
        private static _d_mlpallerrorssparsesubset _i_smp_mlpallerrorssparsesubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlperrorsubset(byte **error_msg, double *result, void **network, x_matrix *xy, x_int *setsize, x_vector *subset, x_int *subsetsize);
        private static _d_mlperrorsubset _i_ser_mlperrorsubset = null;
        private static _d_mlperrorsubset _i_smp_mlperrorsubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlperrorsparsesubset(byte **error_msg, double *result, void **network, void **xy, x_int *setsize, x_vector *subset, x_int *subsetsize);
        private static _d_mlperrorsparsesubset _i_ser_mlperrorsparsesubset = null;
        private static _d_mlperrorsparsesubset _i_smp_mlperrorsparsesubset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixsolve(byte **error_msg, x_matrix *a, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_rmatrixsolve _i_ser_rmatrixsolve = null;
        private static _d_rmatrixsolve _i_smp_rmatrixsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixsolvefast(byte **error_msg, x_matrix *a, x_int *n, x_vector *b, x_int *info);
        private static _d_rmatrixsolvefast _i_ser_rmatrixsolvefast = null;
        private static _d_rmatrixsolvefast _i_smp_rmatrixsolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixsolvem(byte **error_msg, x_matrix *a, x_int *n, x_matrix *b, x_int *m, byte *rfs, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_rmatrixsolvem _i_ser_rmatrixsolvem = null;
        private static _d_rmatrixsolvem _i_smp_rmatrixsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixsolvemfast(byte **error_msg, x_matrix *a, x_int *n, x_matrix *b, x_int *m, x_int *info);
        private static _d_rmatrixsolvemfast _i_ser_rmatrixsolvemfast = null;
        private static _d_rmatrixsolvemfast _i_smp_rmatrixsolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlusolve(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_rmatrixlusolve _i_ser_rmatrixlusolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlusolvefast(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info);
        private static _d_rmatrixlusolvefast _i_ser_rmatrixlusolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlusolvem(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_rmatrixlusolvem _i_ser_rmatrixlusolvem = null;
        private static _d_rmatrixlusolvem _i_smp_rmatrixlusolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixlusolvemfast(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info);
        private static _d_rmatrixlusolvemfast _i_ser_rmatrixlusolvemfast = null;
        private static _d_rmatrixlusolvemfast _i_smp_rmatrixlusolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixmixedsolve(byte **error_msg, x_matrix *a, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_rmatrixmixedsolve _i_ser_rmatrixmixedsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixmixedsolvem(byte **error_msg, x_matrix *a, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_rmatrixmixedsolvem _i_ser_rmatrixmixedsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixsolvem(byte **error_msg, x_matrix *a, x_int *n, x_matrix *b, x_int *m, byte *rfs, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_cmatrixsolvem _i_ser_cmatrixsolvem = null;
        private static _d_cmatrixsolvem _i_smp_cmatrixsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixsolvemfast(byte **error_msg, x_matrix *a, x_int *n, x_matrix *b, x_int *m, x_int *info);
        private static _d_cmatrixsolvemfast _i_ser_cmatrixsolvemfast = null;
        private static _d_cmatrixsolvemfast _i_smp_cmatrixsolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixsolve(byte **error_msg, x_matrix *a, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_cmatrixsolve _i_ser_cmatrixsolve = null;
        private static _d_cmatrixsolve _i_smp_cmatrixsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixsolvefast(byte **error_msg, x_matrix *a, x_int *n, x_vector *b, x_int *info);
        private static _d_cmatrixsolvefast _i_ser_cmatrixsolvefast = null;
        private static _d_cmatrixsolvefast _i_smp_cmatrixsolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlusolvem(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_cmatrixlusolvem _i_ser_cmatrixlusolvem = null;
        private static _d_cmatrixlusolvem _i_smp_cmatrixlusolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlusolvemfast(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info);
        private static _d_cmatrixlusolvemfast _i_ser_cmatrixlusolvemfast = null;
        private static _d_cmatrixlusolvemfast _i_smp_cmatrixlusolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlusolve(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_cmatrixlusolve _i_ser_cmatrixlusolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixlusolvefast(byte **error_msg, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info);
        private static _d_cmatrixlusolvefast _i_ser_cmatrixlusolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixmixedsolvem(byte **error_msg, x_matrix *a, x_matrix *lua, x_vector *p, x_int *n, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_cmatrixmixedsolvem _i_ser_cmatrixmixedsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixmixedsolve(byte **error_msg, x_matrix *a, x_matrix *lua, x_vector *p, x_int *n, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_cmatrixmixedsolve _i_ser_cmatrixmixedsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixsolvem(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_spdmatrixsolvem _i_ser_spdmatrixsolvem = null;
        private static _d_spdmatrixsolvem _i_smp_spdmatrixsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixsolvemfast(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info);
        private static _d_spdmatrixsolvemfast _i_ser_spdmatrixsolvemfast = null;
        private static _d_spdmatrixsolvemfast _i_smp_spdmatrixsolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixsolve(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_spdmatrixsolve _i_ser_spdmatrixsolve = null;
        private static _d_spdmatrixsolve _i_smp_spdmatrixsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixsolvefast(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *b, x_int *info);
        private static _d_spdmatrixsolvefast _i_ser_spdmatrixsolvefast = null;
        private static _d_spdmatrixsolvefast _i_smp_spdmatrixsolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskysolvem(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_spdmatrixcholeskysolvem _i_ser_spdmatrixcholeskysolvem = null;
        private static _d_spdmatrixcholeskysolvem _i_smp_spdmatrixcholeskysolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskysolvemfast(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info);
        private static _d_spdmatrixcholeskysolvemfast _i_ser_spdmatrixcholeskysolvemfast = null;
        private static _d_spdmatrixcholeskysolvemfast _i_smp_spdmatrixcholeskysolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskysolve(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_spdmatrixcholeskysolve _i_ser_spdmatrixcholeskysolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskysolvefast(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_vector *b, x_int *info);
        private static _d_spdmatrixcholeskysolvefast _i_ser_spdmatrixcholeskysolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixsolvem(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_hpdmatrixsolvem _i_ser_hpdmatrixsolvem = null;
        private static _d_hpdmatrixsolvem _i_smp_hpdmatrixsolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixsolvemfast(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info);
        private static _d_hpdmatrixsolvemfast _i_ser_hpdmatrixsolvemfast = null;
        private static _d_hpdmatrixsolvemfast _i_smp_hpdmatrixsolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixsolve(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_hpdmatrixsolve _i_ser_hpdmatrixsolve = null;
        private static _d_hpdmatrixsolve _i_smp_hpdmatrixsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixsolvefast(byte **error_msg, x_matrix *a, x_int *n, byte *isupper, x_vector *b, x_int *info);
        private static _d_hpdmatrixsolvefast _i_ser_hpdmatrixsolvefast = null;
        private static _d_hpdmatrixsolvefast _i_smp_hpdmatrixsolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixcholeskysolvem(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info, x_densesolverreport *rep, x_matrix *x);
        private static _d_hpdmatrixcholeskysolvem _i_ser_hpdmatrixcholeskysolvem = null;
        private static _d_hpdmatrixcholeskysolvem _i_smp_hpdmatrixcholeskysolvem = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixcholeskysolvemfast(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_matrix *b, x_int *m, x_int *info);
        private static _d_hpdmatrixcholeskysolvemfast _i_ser_hpdmatrixcholeskysolvemfast = null;
        private static _d_hpdmatrixcholeskysolvemfast _i_smp_hpdmatrixcholeskysolvemfast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixcholeskysolve(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_vector *b, x_int *info, x_densesolverreport *rep, x_vector *x);
        private static _d_hpdmatrixcholeskysolve _i_ser_hpdmatrixcholeskysolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hpdmatrixcholeskysolvefast(byte **error_msg, x_matrix *cha, x_int *n, byte *isupper, x_vector *b, x_int *info);
        private static _d_hpdmatrixcholeskysolvefast _i_ser_hpdmatrixcholeskysolvefast = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixsolvels(byte **error_msg, x_matrix *a, x_int *nrows, x_int *ncols, x_vector *b, double *threshold, x_int *info, x_densesolverlsreport *rep, x_vector *x);
        private static _d_rmatrixsolvels _i_ser_rmatrixsolvels = null;
        private static _d_rmatrixsolvels _i_smp_rmatrixsolvels = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnltrainh(byte **error_msg, x_matrix *xy, x_int *npoints, x_int *nvars, x_int *nclasses, x_int *info, void **lm, x_mnlreport *rep);
        private static _d_mnltrainh _i_ser_mnltrainh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlprocess(byte **error_msg, void **lm, x_vector *x, x_vector *y);
        private static _d_mnlprocess _i_ser_mnlprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlprocessi(byte **error_msg, void **lm, x_vector *x, x_vector *y);
        private static _d_mnlprocessi _i_ser_mnlprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlunpack(byte **error_msg, void **lm, x_matrix *a, x_int *nvars, x_int *nclasses);
        private static _d_mnlunpack _i_ser_mnlunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlpack(byte **error_msg, x_matrix *a, x_int *nvars, x_int *nclasses, void **lm);
        private static _d_mnlpack _i_ser_mnlpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlavgce(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints);
        private static _d_mnlavgce _i_ser_mnlavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlrelclserror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints);
        private static _d_mnlrelclserror _i_ser_mnlrelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlrmserror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints);
        private static _d_mnlrmserror _i_ser_mnlrmserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlavgerror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *npoints);
        private static _d_mnlavgerror _i_ser_mnlavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlavgrelerror(byte **error_msg, double *result, void **lm, x_matrix *xy, x_int *ssize);
        private static _d_mnlavgrelerror _i_ser_mnlavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mnlclserror(byte **error_msg, x_int *result, void **lm, x_matrix *xy, x_int *npoints);
        private static _d_mnlclserror _i_ser_mnlclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgcreate(byte **error_msg, x_int *n, x_vector *x, void **state);
        private static _d_mincgcreate _i_ser_mincgcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgcreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state);
        private static _d_mincgcreatef _i_ser_mincgcreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits);
        private static _d_mincgsetcond _i_ser_mincgsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetscale(byte **error_msg, void **state, x_vector *s);
        private static _d_mincgsetscale _i_ser_mincgsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_mincgsetxrep _i_ser_mincgsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetcgtype(byte **error_msg, void **state, x_int *cgtype);
        private static _d_mincgsetcgtype _i_ser_mincgsetcgtype = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetstpmax(byte **error_msg, void **state, double *stpmax);
        private static _d_mincgsetstpmax _i_ser_mincgsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsuggeststep(byte **error_msg, void **state, double *stp);
        private static _d_mincgsuggeststep _i_ser_mincgsuggeststep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetprecdefault(byte **error_msg, void **state);
        private static _d_mincgsetprecdefault _i_ser_mincgsetprecdefault = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetprecdiag(byte **error_msg, void **state, x_vector *d);
        private static _d_mincgsetprecdiag _i_ser_mincgsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetprecscale(byte **error_msg, void **state);
        private static _d_mincgsetprecscale _i_ser_mincgsetprecscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgiteration(byte **error_msg, byte *result, void **state);
        private static _d_mincgiteration _i_ser_mincgiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgresults(byte **error_msg, void **state, x_vector *x, x_mincgreport *rep);
        private static _d_mincgresults _i_ser_mincgresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgresultsbuf(byte **error_msg, void **state, x_vector *x, x_mincgreport *rep);
        private static _d_mincgresultsbuf _i_ser_mincgresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgrestartfrom(byte **error_msg, void **state, x_vector *x);
        private static _d_mincgrestartfrom _i_ser_mincgrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgrequesttermination(byte **error_msg, void **state);
        private static _d_mincgrequesttermination _i_ser_mincgrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mincgsetgradientcheck(byte **error_msg, void **state, double *teststep);
        private static _d_mincgsetgradientcheck _i_ser_mincgsetgradientcheck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleiccreate(byte **error_msg, x_int *n, x_vector *x, void **state);
        private static _d_minbleiccreate _i_ser_minbleiccreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleiccreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state);
        private static _d_minbleiccreatef _i_ser_minbleiccreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu);
        private static _d_minbleicsetbc _i_ser_minbleicsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k);
        private static _d_minbleicsetlc _i_ser_minbleicsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits);
        private static _d_minbleicsetcond _i_ser_minbleicsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetscale(byte **error_msg, void **state, x_vector *s);
        private static _d_minbleicsetscale _i_ser_minbleicsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetprecdefault(byte **error_msg, void **state);
        private static _d_minbleicsetprecdefault _i_ser_minbleicsetprecdefault = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetprecdiag(byte **error_msg, void **state, x_vector *d);
        private static _d_minbleicsetprecdiag _i_ser_minbleicsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetprecscale(byte **error_msg, void **state);
        private static _d_minbleicsetprecscale _i_ser_minbleicsetprecscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_minbleicsetxrep _i_ser_minbleicsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetstpmax(byte **error_msg, void **state, double *stpmax);
        private static _d_minbleicsetstpmax _i_ser_minbleicsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleiciteration(byte **error_msg, byte *result, void **state);
        private static _d_minbleiciteration _i_ser_minbleiciteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicresults(byte **error_msg, void **state, x_vector *x, x_minbleicreport *rep);
        private static _d_minbleicresults _i_ser_minbleicresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicresultsbuf(byte **error_msg, void **state, x_vector *x, x_minbleicreport *rep);
        private static _d_minbleicresultsbuf _i_ser_minbleicresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicrestartfrom(byte **error_msg, void **state, x_vector *x);
        private static _d_minbleicrestartfrom _i_ser_minbleicrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicrequesttermination(byte **error_msg, void **state);
        private static _d_minbleicrequesttermination _i_ser_minbleicrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetgradientcheck(byte **error_msg, void **state, double *teststep);
        private static _d_minbleicsetgradientcheck _i_ser_minbleicsetgradientcheck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdcreate(byte **error_msg, x_int *n, void **s);
        private static _d_mcpdcreate _i_ser_mcpdcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdcreateentry(byte **error_msg, x_int *n, x_int *entrystate, void **s);
        private static _d_mcpdcreateentry _i_ser_mcpdcreateentry = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdcreateexit(byte **error_msg, x_int *n, x_int *exitstate, void **s);
        private static _d_mcpdcreateexit _i_ser_mcpdcreateexit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdcreateentryexit(byte **error_msg, x_int *n, x_int *entrystate, x_int *exitstate, void **s);
        private static _d_mcpdcreateentryexit _i_ser_mcpdcreateentryexit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdaddtrack(byte **error_msg, void **s, x_matrix *xy, x_int *k);
        private static _d_mcpdaddtrack _i_ser_mcpdaddtrack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdsetec(byte **error_msg, void **s, x_matrix *ec);
        private static _d_mcpdsetec _i_ser_mcpdsetec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdaddec(byte **error_msg, void **s, x_int *i, x_int *j, double *c);
        private static _d_mcpdaddec _i_ser_mcpdaddec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdsetbc(byte **error_msg, void **s, x_matrix *bndl, x_matrix *bndu);
        private static _d_mcpdsetbc _i_ser_mcpdsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdaddbc(byte **error_msg, void **s, x_int *i, x_int *j, double *bndl, double *bndu);
        private static _d_mcpdaddbc _i_ser_mcpdaddbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdsetlc(byte **error_msg, void **s, x_matrix *c, x_vector *ct, x_int *k);
        private static _d_mcpdsetlc _i_ser_mcpdsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdsettikhonovregularizer(byte **error_msg, void **s, double *v);
        private static _d_mcpdsettikhonovregularizer _i_ser_mcpdsettikhonovregularizer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdsetprior(byte **error_msg, void **s, x_matrix *pp);
        private static _d_mcpdsetprior _i_ser_mcpdsetprior = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdsetpredictionweights(byte **error_msg, void **s, x_vector *pw);
        private static _d_mcpdsetpredictionweights _i_ser_mcpdsetpredictionweights = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdsolve(byte **error_msg, void **s);
        private static _d_mcpdsolve _i_ser_mcpdsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mcpdresults(byte **error_msg, void **s, x_matrix *p, x_mcpdreport *rep);
        private static _d_mcpdresults _i_ser_mcpdresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpeserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_mlpeunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_mlpeserialize   _i_x_mlpeserialize   = null;
        private static _d_x_mlpeunserialize _i_x_mlpeunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreate0(byte **error_msg, x_int *nin, x_int *nout, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreate0 _i_ser_mlpecreate0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreate1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreate1 _i_ser_mlpecreate1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreate2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreate2 _i_ser_mlpecreate2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreateb0(byte **error_msg, x_int *nin, x_int *nout, double *b, double *d, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreateb0 _i_ser_mlpecreateb0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreateb1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, double *b, double *d, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreateb1 _i_ser_mlpecreateb1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreateb2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, double *b, double *d, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreateb2 _i_ser_mlpecreateb2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreater0(byte **error_msg, x_int *nin, x_int *nout, double *a, double *b, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreater0 _i_ser_mlpecreater0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreater1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, double *a, double *b, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreater1 _i_ser_mlpecreater1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreater2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, double *a, double *b, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreater2 _i_ser_mlpecreater2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreatec0(byte **error_msg, x_int *nin, x_int *nout, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreatec0 _i_ser_mlpecreatec0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreatec1(byte **error_msg, x_int *nin, x_int *nhid, x_int *nout, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreatec1 _i_ser_mlpecreatec1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreatec2(byte **error_msg, x_int *nin, x_int *nhid1, x_int *nhid2, x_int *nout, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreatec2 _i_ser_mlpecreatec2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpecreatefromnetwork(byte **error_msg, void **network, x_int *ensemblesize, void **ensemble);
        private static _d_mlpecreatefromnetwork _i_ser_mlpecreatefromnetwork = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlperandomize(byte **error_msg, void **ensemble);
        private static _d_mlperandomize _i_ser_mlperandomize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpeproperties(byte **error_msg, void **ensemble, x_int *nin, x_int *nout);
        private static _d_mlpeproperties _i_ser_mlpeproperties = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpeissoftmax(byte **error_msg, byte *result, void **ensemble);
        private static _d_mlpeissoftmax _i_ser_mlpeissoftmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpeprocess(byte **error_msg, void **ensemble, x_vector *x, x_vector *y);
        private static _d_mlpeprocess _i_ser_mlpeprocess = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpeprocessi(byte **error_msg, void **ensemble, x_vector *x, x_vector *y);
        private static _d_mlpeprocessi _i_ser_mlpeprocessi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlperelclserror(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints);
        private static _d_mlperelclserror _i_ser_mlperelclserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpeavgce(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints);
        private static _d_mlpeavgce _i_ser_mlpeavgce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpermserror(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints);
        private static _d_mlpermserror _i_ser_mlpermserror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpeavgerror(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints);
        private static _d_mlpeavgerror _i_ser_mlpeavgerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpeavgrelerror(byte **error_msg, double *result, void **ensemble, x_matrix *xy, x_int *npoints);
        private static _d_mlpeavgrelerror _i_ser_mlpeavgrelerror = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgscreate(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state);
        private static _d_minlbfgscreate _i_ser_minlbfgscreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgscreatef(byte **error_msg, x_int *n, x_int *m, x_vector *x, double *diffstep, void **state);
        private static _d_minlbfgscreatef _i_ser_minlbfgscreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits);
        private static _d_minlbfgssetcond _i_ser_minlbfgssetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_minlbfgssetxrep _i_ser_minlbfgssetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetstpmax(byte **error_msg, void **state, double *stpmax);
        private static _d_minlbfgssetstpmax _i_ser_minlbfgssetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetscale(byte **error_msg, void **state, x_vector *s);
        private static _d_minlbfgssetscale _i_ser_minlbfgssetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetprecdefault(byte **error_msg, void **state);
        private static _d_minlbfgssetprecdefault _i_ser_minlbfgssetprecdefault = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetpreccholesky(byte **error_msg, void **state, x_matrix *p, byte *isupper);
        private static _d_minlbfgssetpreccholesky _i_ser_minlbfgssetpreccholesky = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetprecdiag(byte **error_msg, void **state, x_vector *d);
        private static _d_minlbfgssetprecdiag _i_ser_minlbfgssetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetprecscale(byte **error_msg, void **state);
        private static _d_minlbfgssetprecscale _i_ser_minlbfgssetprecscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgsiteration(byte **error_msg, byte *result, void **state);
        private static _d_minlbfgsiteration _i_ser_minlbfgsiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgsresults(byte **error_msg, void **state, x_vector *x, x_minlbfgsreport *rep);
        private static _d_minlbfgsresults _i_ser_minlbfgsresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgsresultsbuf(byte **error_msg, void **state, x_vector *x, x_minlbfgsreport *rep);
        private static _d_minlbfgsresultsbuf _i_ser_minlbfgsresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgsrestartfrom(byte **error_msg, void **state, x_vector *x);
        private static _d_minlbfgsrestartfrom _i_ser_minlbfgsrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgsrequesttermination(byte **error_msg, void **state);
        private static _d_minlbfgsrequesttermination _i_ser_minlbfgsrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetgradientcheck(byte **error_msg, void **state, double *teststep);
        private static _d_minlbfgssetgradientcheck _i_ser_minlbfgssetgradientcheck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlptrainlm(byte **error_msg, void **network, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, x_int *info, x_mlpreport *rep);
        private static _d_mlptrainlm _i_ser_mlptrainlm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlptrainlbfgs(byte **error_msg, void **network, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, double *wstep, x_int *maxits, x_int *info, x_mlpreport *rep);
        private static _d_mlptrainlbfgs _i_ser_mlptrainlbfgs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlptraines(byte **error_msg, void **network, x_matrix *trnxy, x_int *trnsize, x_matrix *valxy, x_int *valsize, double *decay, x_int *restarts, x_int *info, x_mlpreport *rep);
        private static _d_mlptraines _i_ser_mlptraines = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpkfoldcvlbfgs(byte **error_msg, void **network, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, double *wstep, x_int *maxits, x_int *foldscount, x_int *info, x_mlpreport *rep, x_mlpcvreport *cvrep);
        private static _d_mlpkfoldcvlbfgs _i_ser_mlpkfoldcvlbfgs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpkfoldcvlm(byte **error_msg, void **network, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, x_int *foldscount, x_int *info, x_mlpreport *rep, x_mlpcvreport *cvrep);
        private static _d_mlpkfoldcvlm _i_ser_mlpkfoldcvlm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpkfoldcv(byte **error_msg, void **s, void **network, x_int *nrestarts, x_int *foldscount, x_mlpreport *rep);
        private static _d_mlpkfoldcv _i_ser_mlpkfoldcv = null;
        private static _d_mlpkfoldcv _i_smp_mlpkfoldcv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreatetrainer(byte **error_msg, x_int *nin, x_int *nout, void **s);
        private static _d_mlpcreatetrainer _i_ser_mlpcreatetrainer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcreatetrainercls(byte **error_msg, x_int *nin, x_int *nclasses, void **s);
        private static _d_mlpcreatetrainercls _i_ser_mlpcreatetrainercls = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetdataset(byte **error_msg, void **s, x_matrix *xy, x_int *npoints);
        private static _d_mlpsetdataset _i_ser_mlpsetdataset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetsparsedataset(byte **error_msg, void **s, void **xy, x_int *npoints);
        private static _d_mlpsetsparsedataset _i_ser_mlpsetsparsedataset = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetdecay(byte **error_msg, void **s, double *decay);
        private static _d_mlpsetdecay _i_ser_mlpsetdecay = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetcond(byte **error_msg, void **s, double *wstep, x_int *maxits);
        private static _d_mlpsetcond _i_ser_mlpsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpsetalgobatch(byte **error_msg, void **s);
        private static _d_mlpsetalgobatch _i_ser_mlpsetalgobatch = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlptrainnetwork(byte **error_msg, void **s, void **network, x_int *nrestarts, x_mlpreport *rep);
        private static _d_mlptrainnetwork _i_ser_mlptrainnetwork = null;
        private static _d_mlptrainnetwork _i_smp_mlptrainnetwork = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpstarttraining(byte **error_msg, void **s, void **network, byte *randomstart);
        private static _d_mlpstarttraining _i_ser_mlpstarttraining = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpcontinuetraining(byte **error_msg, byte *result, void **s, void **network);
        private static _d_mlpcontinuetraining _i_ser_mlpcontinuetraining = null;
        private static _d_mlpcontinuetraining _i_smp_mlpcontinuetraining = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpebagginglm(byte **error_msg, void **ensemble, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, x_int *info, x_mlpreport *rep, x_mlpcvreport *ooberrors);
        private static _d_mlpebagginglm _i_ser_mlpebagginglm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpebagginglbfgs(byte **error_msg, void **ensemble, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, double *wstep, x_int *maxits, x_int *info, x_mlpreport *rep, x_mlpcvreport *ooberrors);
        private static _d_mlpebagginglbfgs _i_ser_mlpebagginglbfgs = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlpetraines(byte **error_msg, void **ensemble, x_matrix *xy, x_int *npoints, double *decay, x_int *restarts, x_int *info, x_mlpreport *rep);
        private static _d_mlpetraines _i_ser_mlpetraines = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mlptrainensemblees(byte **error_msg, void **s, void **ensemble, x_int *nrestarts, x_mlpreport *rep);
        private static _d_mlptrainensemblees _i_ser_mlptrainensemblees = null;
        private static _d_mlptrainensemblees _i_smp_mlptrainensemblees = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pcabuildbasis(byte **error_msg, x_matrix *x, x_int *npoints, x_int *nvars, x_int *info, x_vector *s2, x_matrix *v);
        private static _d_pcabuildbasis _i_ser_pcabuildbasis = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_odesolverrkck(byte **error_msg, x_vector *y, x_int *n, x_vector *x, x_int *m, double *eps, double *h, void **state);
        private static _d_odesolverrkck _i_ser_odesolverrkck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_odesolveriteration(byte **error_msg, byte *result, void **state);
        private static _d_odesolveriteration _i_ser_odesolveriteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_odesolverresults(byte **error_msg, void **state, x_int *m, x_vector *xtbl, x_matrix *ytbl, x_odesolverreport *rep);
        private static _d_odesolverresults _i_ser_odesolverresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fftc1d(byte **error_msg, x_vector *a, x_int *n);
        private static _d_fftc1d _i_ser_fftc1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fftc1dinv(byte **error_msg, x_vector *a, x_int *n);
        private static _d_fftc1dinv _i_ser_fftc1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fftr1d(byte **error_msg, x_vector *a, x_int *n, x_vector *f);
        private static _d_fftr1d _i_ser_fftr1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fftr1dinv(byte **error_msg, x_vector *f, x_int *n, x_vector *a);
        private static _d_fftr1dinv _i_ser_fftr1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_convc1d(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r);
        private static _d_convc1d _i_ser_convc1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_convc1dinv(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r);
        private static _d_convc1dinv _i_ser_convc1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_convc1dcircular(byte **error_msg, x_vector *s, x_int *m, x_vector *r, x_int *n, x_vector *c);
        private static _d_convc1dcircular _i_ser_convc1dcircular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_convc1dcircularinv(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r);
        private static _d_convc1dcircularinv _i_ser_convc1dcircularinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_convr1d(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r);
        private static _d_convr1d _i_ser_convr1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_convr1dinv(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r);
        private static _d_convr1dinv _i_ser_convr1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_convr1dcircular(byte **error_msg, x_vector *s, x_int *m, x_vector *r, x_int *n, x_vector *c);
        private static _d_convr1dcircular _i_ser_convr1dcircular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_convr1dcircularinv(byte **error_msg, x_vector *a, x_int *m, x_vector *b, x_int *n, x_vector *r);
        private static _d_convr1dcircularinv _i_ser_convr1dcircularinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_corrc1d(byte **error_msg, x_vector *signal, x_int *n, x_vector *pattern, x_int *m, x_vector *r);
        private static _d_corrc1d _i_ser_corrc1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_corrc1dcircular(byte **error_msg, x_vector *signal, x_int *m, x_vector *pattern, x_int *n, x_vector *c);
        private static _d_corrc1dcircular _i_ser_corrc1dcircular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_corrr1d(byte **error_msg, x_vector *signal, x_int *n, x_vector *pattern, x_int *m, x_vector *r);
        private static _d_corrr1d _i_ser_corrr1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_corrr1dcircular(byte **error_msg, x_vector *signal, x_int *m, x_vector *pattern, x_int *n, x_vector *c);
        private static _d_corrr1dcircular _i_ser_corrr1dcircular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fhtr1d(byte **error_msg, x_vector *a, x_int *n);
        private static _d_fhtr1d _i_ser_fhtr1d = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fhtr1dinv(byte **error_msg, x_vector *a, x_int *n);
        private static _d_fhtr1dinv _i_ser_fhtr1dinv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gqgeneraterec(byte **error_msg, x_vector *alpha, x_vector *beta, double *mu0, x_int *n, x_int *info, x_vector *x, x_vector *w);
        private static _d_gqgeneraterec _i_ser_gqgeneraterec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gqgenerategausslobattorec(byte **error_msg, x_vector *alpha, x_vector *beta, double *mu0, double *a, double *b, x_int *n, x_int *info, x_vector *x, x_vector *w);
        private static _d_gqgenerategausslobattorec _i_ser_gqgenerategausslobattorec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gqgenerategaussradaurec(byte **error_msg, x_vector *alpha, x_vector *beta, double *mu0, double *a, x_int *n, x_int *info, x_vector *x, x_vector *w);
        private static _d_gqgenerategaussradaurec _i_ser_gqgenerategaussradaurec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gqgenerategausslegendre(byte **error_msg, x_int *n, x_int *info, x_vector *x, x_vector *w);
        private static _d_gqgenerategausslegendre _i_ser_gqgenerategausslegendre = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gqgenerategaussjacobi(byte **error_msg, x_int *n, double *alpha, double *beta, x_int *info, x_vector *x, x_vector *w);
        private static _d_gqgenerategaussjacobi _i_ser_gqgenerategaussjacobi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gqgenerategausslaguerre(byte **error_msg, x_int *n, double *alpha, x_int *info, x_vector *x, x_vector *w);
        private static _d_gqgenerategausslaguerre _i_ser_gqgenerategausslaguerre = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gqgenerategausshermite(byte **error_msg, x_int *n, x_int *info, x_vector *x, x_vector *w);
        private static _d_gqgenerategausshermite _i_ser_gqgenerategausshermite = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gkqgeneraterec(byte **error_msg, x_vector *alpha, x_vector *beta, double *mu0, x_int *n, x_int *info, x_vector *x, x_vector *wkronrod, x_vector *wgauss);
        private static _d_gkqgeneraterec _i_ser_gkqgeneraterec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gkqgenerategausslegendre(byte **error_msg, x_int *n, x_int *info, x_vector *x, x_vector *wkronrod, x_vector *wgauss);
        private static _d_gkqgenerategausslegendre _i_ser_gkqgenerategausslegendre = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gkqgenerategaussjacobi(byte **error_msg, x_int *n, double *alpha, double *beta, x_int *info, x_vector *x, x_vector *wkronrod, x_vector *wgauss);
        private static _d_gkqgenerategaussjacobi _i_ser_gkqgenerategaussjacobi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gkqlegendrecalc(byte **error_msg, x_int *n, x_int *info, x_vector *x, x_vector *wkronrod, x_vector *wgauss);
        private static _d_gkqlegendrecalc _i_ser_gkqlegendrecalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_gkqlegendretbl(byte **error_msg, x_int *n, x_vector *x, x_vector *wkronrod, x_vector *wgauss, double *eps);
        private static _d_gkqlegendretbl _i_ser_gkqlegendretbl = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_autogksmooth(byte **error_msg, double *a, double *b, void **state);
        private static _d_autogksmooth _i_ser_autogksmooth = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_autogksmoothw(byte **error_msg, double *a, double *b, double *xwidth, void **state);
        private static _d_autogksmoothw _i_ser_autogksmoothw = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_autogksingular(byte **error_msg, double *a, double *b, double *alpha, double *beta, void **state);
        private static _d_autogksingular _i_ser_autogksingular = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_autogkiteration(byte **error_msg, byte *result, void **state);
        private static _d_autogkiteration _i_ser_autogkiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_autogkresults(byte **error_msg, void **state, double *v, x_autogkreport *rep);
        private static _d_autogkresults _i_ser_autogkresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_idwcalc(byte **error_msg, double *result, void **z, x_vector *x);
        private static _d_idwcalc _i_ser_idwcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_idwbuildmodifiedshepard(byte **error_msg, x_matrix *xy, x_int *n, x_int *nx, x_int *d, x_int *nq, x_int *nw, void **z);
        private static _d_idwbuildmodifiedshepard _i_ser_idwbuildmodifiedshepard = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_idwbuildmodifiedshepardr(byte **error_msg, x_matrix *xy, x_int *n, x_int *nx, double *r, void **z);
        private static _d_idwbuildmodifiedshepardr _i_ser_idwbuildmodifiedshepardr = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_idwbuildnoisy(byte **error_msg, x_matrix *xy, x_int *n, x_int *nx, x_int *d, x_int *nq, x_int *nw, void **z);
        private static _d_idwbuildnoisy _i_ser_idwbuildnoisy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentriccalc(byte **error_msg, double *result, void **b, double *t);
        private static _d_barycentriccalc _i_ser_barycentriccalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentricdiff1(byte **error_msg, void **b, double *t, double *f, double *df);
        private static _d_barycentricdiff1 _i_ser_barycentricdiff1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentricdiff2(byte **error_msg, void **b, double *t, double *f, double *df, double *d2f);
        private static _d_barycentricdiff2 _i_ser_barycentricdiff2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentriclintransx(byte **error_msg, void **b, double *ca, double *cb);
        private static _d_barycentriclintransx _i_ser_barycentriclintransx = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentriclintransy(byte **error_msg, void **b, double *ca, double *cb);
        private static _d_barycentriclintransy _i_ser_barycentriclintransy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentricunpack(byte **error_msg, void **b, x_int *n, x_vector *x, x_vector *y, x_vector *w);
        private static _d_barycentricunpack _i_ser_barycentricunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentricbuildxyw(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, void **b);
        private static _d_barycentricbuildxyw _i_ser_barycentricbuildxyw = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentricbuildfloaterhormann(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *d, void **b);
        private static _d_barycentricbuildfloaterhormann _i_ser_barycentricbuildfloaterhormann = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialbar2cheb(byte **error_msg, void **p, double *a, double *b, x_vector *t);
        private static _d_polynomialbar2cheb _i_ser_polynomialbar2cheb = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialcheb2bar(byte **error_msg, x_vector *t, x_int *n, double *a, double *b, void **p);
        private static _d_polynomialcheb2bar _i_ser_polynomialcheb2bar = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialbar2pow(byte **error_msg, void **p, double *c, double *s, x_vector *a);
        private static _d_polynomialbar2pow _i_ser_polynomialbar2pow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialpow2bar(byte **error_msg, x_vector *a, x_int *n, double *c, double *s, void **p);
        private static _d_polynomialpow2bar _i_ser_polynomialpow2bar = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialbuild(byte **error_msg, x_vector *x, x_vector *y, x_int *n, void **p);
        private static _d_polynomialbuild _i_ser_polynomialbuild = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialbuildeqdist(byte **error_msg, double *a, double *b, x_vector *y, x_int *n, void **p);
        private static _d_polynomialbuildeqdist _i_ser_polynomialbuildeqdist = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialbuildcheb1(byte **error_msg, double *a, double *b, x_vector *y, x_int *n, void **p);
        private static _d_polynomialbuildcheb1 _i_ser_polynomialbuildcheb1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialbuildcheb2(byte **error_msg, double *a, double *b, x_vector *y, x_int *n, void **p);
        private static _d_polynomialbuildcheb2 _i_ser_polynomialbuildcheb2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialcalceqdist(byte **error_msg, double *result, double *a, double *b, x_vector *f, x_int *n, double *t);
        private static _d_polynomialcalceqdist _i_ser_polynomialcalceqdist = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialcalccheb1(byte **error_msg, double *result, double *a, double *b, x_vector *f, x_int *n, double *t);
        private static _d_polynomialcalccheb1 _i_ser_polynomialcalccheb1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialcalccheb2(byte **error_msg, double *result, double *a, double *b, x_vector *f, x_int *n, double *t);
        private static _d_polynomialcalccheb2 _i_ser_polynomialcalccheb2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dbuildlinear(byte **error_msg, x_vector *x, x_vector *y, x_int *n, void **c);
        private static _d_spline1dbuildlinear _i_ser_spline1dbuildlinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dbuildcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, void **c);
        private static _d_spline1dbuildcubic _i_ser_spline1dbuildcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dgriddiffcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *d);
        private static _d_spline1dgriddiffcubic _i_ser_spline1dgriddiffcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dgriddiff2cubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *d1, x_vector *d2);
        private static _d_spline1dgriddiff2cubic _i_ser_spline1dgriddiff2cubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dconvcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *x2, x_int *n2, x_vector *y2);
        private static _d_spline1dconvcubic _i_ser_spline1dconvcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dconvdiffcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *x2, x_int *n2, x_vector *y2, x_vector *d2);
        private static _d_spline1dconvdiffcubic _i_ser_spline1dconvdiffcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dconvdiff2cubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundltype, double *boundl, x_int *boundrtype, double *boundr, x_vector *x2, x_int *n2, x_vector *y2, x_vector *d2, x_vector *dd2);
        private static _d_spline1dconvdiff2cubic _i_ser_spline1dconvdiff2cubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dbuildcatmullrom(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *boundtype, double *tension, void **c);
        private static _d_spline1dbuildcatmullrom _i_ser_spline1dbuildcatmullrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dbuildhermite(byte **error_msg, x_vector *x, x_vector *y, x_vector *d, x_int *n, void **c);
        private static _d_spline1dbuildhermite _i_ser_spline1dbuildhermite = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dbuildakima(byte **error_msg, x_vector *x, x_vector *y, x_int *n, void **c);
        private static _d_spline1dbuildakima _i_ser_spline1dbuildakima = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dcalc(byte **error_msg, double *result, void **c, double *x);
        private static _d_spline1dcalc _i_ser_spline1dcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1ddiff(byte **error_msg, void **c, double *x, double *s, double *ds, double *d2s);
        private static _d_spline1ddiff _i_ser_spline1ddiff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dunpack(byte **error_msg, void **c, x_int *n, x_matrix *tbl);
        private static _d_spline1dunpack _i_ser_spline1dunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dlintransx(byte **error_msg, void **c, double *a, double *b);
        private static _d_spline1dlintransx _i_ser_spline1dlintransx = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dlintransy(byte **error_msg, void **c, double *a, double *b);
        private static _d_spline1dlintransy _i_ser_spline1dlintransy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dintegrate(byte **error_msg, double *result, void **c, double *x);
        private static _d_spline1dintegrate _i_ser_spline1dintegrate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dbuildmonotone(byte **error_msg, x_vector *x, x_vector *y, x_int *n, void **c);
        private static _d_spline1dbuildmonotone _i_ser_spline1dbuildmonotone = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_normestimatorcreate(byte **error_msg, x_int *m, x_int *n, x_int *nstart, x_int *nits, void **state);
        private static _d_normestimatorcreate _i_ser_normestimatorcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_normestimatorsetseed(byte **error_msg, void **state, x_int *seedval);
        private static _d_normestimatorsetseed _i_ser_normestimatorsetseed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_normestimatorestimatesparse(byte **error_msg, void **state, void **a);
        private static _d_normestimatorestimatesparse _i_ser_normestimatorestimatesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_normestimatorresults(byte **error_msg, void **state, double *nrm);
        private static _d_normestimatorresults _i_ser_normestimatorresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpcreate(byte **error_msg, x_int *n, void **state);
        private static _d_minqpcreate _i_ser_minqpcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetlinearterm(byte **error_msg, void **state, x_vector *b);
        private static _d_minqpsetlinearterm _i_ser_minqpsetlinearterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetquadraticterm(byte **error_msg, void **state, x_matrix *a, byte *isupper);
        private static _d_minqpsetquadraticterm _i_ser_minqpsetquadraticterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetquadratictermsparse(byte **error_msg, void **state, void **a, byte *isupper);
        private static _d_minqpsetquadratictermsparse _i_ser_minqpsetquadratictermsparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetstartingpoint(byte **error_msg, void **state, x_vector *x);
        private static _d_minqpsetstartingpoint _i_ser_minqpsetstartingpoint = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetorigin(byte **error_msg, void **state, x_vector *xorigin);
        private static _d_minqpsetorigin _i_ser_minqpsetorigin = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetscale(byte **error_msg, void **state, x_vector *s);
        private static _d_minqpsetscale _i_ser_minqpsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetalgocholesky(byte **error_msg, void **state);
        private static _d_minqpsetalgocholesky _i_ser_minqpsetalgocholesky = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetalgobleic(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits);
        private static _d_minqpsetalgobleic _i_ser_minqpsetalgobleic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetalgoquickqp(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxouterits, byte *usenewton);
        private static _d_minqpsetalgoquickqp _i_ser_minqpsetalgoquickqp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu);
        private static _d_minqpsetbc _i_ser_minqpsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpsetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k);
        private static _d_minqpsetlc _i_ser_minqpsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpoptimize(byte **error_msg, void **state);
        private static _d_minqpoptimize _i_ser_minqpoptimize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpresults(byte **error_msg, void **state, x_vector *x, x_minqpreport *rep);
        private static _d_minqpresults _i_ser_minqpresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minqpresultsbuf(byte **error_msg, void **state, x_vector *x, x_minqpreport *rep);
        private static _d_minqpresultsbuf _i_ser_minqpresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmcreatevj(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state);
        private static _d_minlmcreatevj _i_ser_minlmcreatevj = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmcreatev(byte **error_msg, x_int *n, x_int *m, x_vector *x, double *diffstep, void **state);
        private static _d_minlmcreatev _i_ser_minlmcreatev = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmcreatefgh(byte **error_msg, x_int *n, x_vector *x, void **state);
        private static _d_minlmcreatefgh _i_ser_minlmcreatefgh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmsetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits);
        private static _d_minlmsetcond _i_ser_minlmsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmsetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_minlmsetxrep _i_ser_minlmsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmsetstpmax(byte **error_msg, void **state, double *stpmax);
        private static _d_minlmsetstpmax _i_ser_minlmsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmsetscale(byte **error_msg, void **state, x_vector *s);
        private static _d_minlmsetscale _i_ser_minlmsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu);
        private static _d_minlmsetbc _i_ser_minlmsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmsetacctype(byte **error_msg, void **state, x_int *acctype);
        private static _d_minlmsetacctype _i_ser_minlmsetacctype = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmiteration(byte **error_msg, byte *result, void **state);
        private static _d_minlmiteration _i_ser_minlmiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmresults(byte **error_msg, void **state, x_vector *x, x_minlmreport *rep);
        private static _d_minlmresults _i_ser_minlmresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmresultsbuf(byte **error_msg, void **state, x_vector *x, x_minlmreport *rep);
        private static _d_minlmresultsbuf _i_ser_minlmresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmrestartfrom(byte **error_msg, void **state, x_vector *x);
        private static _d_minlmrestartfrom _i_ser_minlmrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmrequesttermination(byte **error_msg, void **state);
        private static _d_minlmrequesttermination _i_ser_minlmrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmcreatevgj(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state);
        private static _d_minlmcreatevgj _i_ser_minlmcreatevgj = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmcreatefgj(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state);
        private static _d_minlmcreatefgj _i_ser_minlmcreatefgj = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmcreatefj(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state);
        private static _d_minlmcreatefj _i_ser_minlmcreatefj = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlmsetgradientcheck(byte **error_msg, void **state, double *teststep);
        private static _d_minlmsetgradientcheck _i_ser_minlmsetgradientcheck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lstfitpiecewiselinearrdpfixed(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_vector *x2, x_vector *y2, x_int *nsections);
        private static _d_lstfitpiecewiselinearrdpfixed _i_ser_lstfitpiecewiselinearrdpfixed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lstfitpiecewiselinearrdp(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *eps, x_vector *x2, x_vector *y2, x_int *nsections);
        private static _d_lstfitpiecewiselinearrdp _i_ser_lstfitpiecewiselinearrdp = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialfit(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_int *info, void **p, x_polynomialfitreport *rep);
        private static _d_polynomialfit _i_ser_polynomialfit = null;
        private static _d_polynomialfit _i_smp_polynomialfit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialfitwc(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_vector *xc, x_vector *yc, x_vector *dc, x_int *k, x_int *m, x_int *info, void **p, x_polynomialfitreport *rep);
        private static _d_polynomialfitwc _i_ser_polynomialfitwc = null;
        private static _d_polynomialfitwc _i_smp_polynomialfitwc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_logisticcalc4(byte **error_msg, double *result, double *x, double *a, double *b, double *c, double *d);
        private static _d_logisticcalc4 _i_ser_logisticcalc4 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_logisticcalc5(byte **error_msg, double *result, double *x, double *a, double *b, double *c, double *d, double *g);
        private static _d_logisticcalc5 _i_ser_logisticcalc5 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_logisticfit4(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *a, double *b, double *c, double *d, x_lsfitreport *rep);
        private static _d_logisticfit4 _i_ser_logisticfit4 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_logisticfit4ec(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *cnstrleft, double *cnstrright, double *a, double *b, double *c, double *d, x_lsfitreport *rep);
        private static _d_logisticfit4ec _i_ser_logisticfit4ec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_logisticfit5(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *a, double *b, double *c, double *d, double *g, x_lsfitreport *rep);
        private static _d_logisticfit5 _i_ser_logisticfit5 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_logisticfit5ec(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *cnstrleft, double *cnstrright, double *a, double *b, double *c, double *d, double *g, x_lsfitreport *rep);
        private static _d_logisticfit5ec _i_ser_logisticfit5ec = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_logisticfit45x(byte **error_msg, x_vector *x, x_vector *y, x_int *n, double *cnstrleft, double *cnstrright, byte *is4pl, double *lambdav, double *epsx, x_int *rscnt, double *a, double *b, double *c, double *d, double *g, x_lsfitreport *rep);
        private static _d_logisticfit45x _i_ser_logisticfit45x = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentricfitfloaterhormannwc(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_vector *xc, x_vector *yc, x_vector *dc, x_int *k, x_int *m, x_int *info, void **b, x_barycentricfitreport *rep);
        private static _d_barycentricfitfloaterhormannwc _i_ser_barycentricfitfloaterhormannwc = null;
        private static _d_barycentricfitfloaterhormannwc _i_smp_barycentricfitfloaterhormannwc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_barycentricfitfloaterhormann(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_int *info, void **b, x_barycentricfitreport *rep);
        private static _d_barycentricfitfloaterhormann _i_ser_barycentricfitfloaterhormann = null;
        private static _d_barycentricfitfloaterhormann _i_smp_barycentricfitfloaterhormann = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dfitpenalized(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, double *rho, x_int *info, void **s, x_spline1dfitreport *rep);
        private static _d_spline1dfitpenalized _i_ser_spline1dfitpenalized = null;
        private static _d_spline1dfitpenalized _i_smp_spline1dfitpenalized = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dfitpenalizedw(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_int *m, double *rho, x_int *info, void **s, x_spline1dfitreport *rep);
        private static _d_spline1dfitpenalizedw _i_ser_spline1dfitpenalizedw = null;
        private static _d_spline1dfitpenalizedw _i_smp_spline1dfitpenalizedw = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dfitcubicwc(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_vector *xc, x_vector *yc, x_vector *dc, x_int *k, x_int *m, x_int *info, void **s, x_spline1dfitreport *rep);
        private static _d_spline1dfitcubicwc _i_ser_spline1dfitcubicwc = null;
        private static _d_spline1dfitcubicwc _i_smp_spline1dfitcubicwc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dfithermitewc(byte **error_msg, x_vector *x, x_vector *y, x_vector *w, x_int *n, x_vector *xc, x_vector *yc, x_vector *dc, x_int *k, x_int *m, x_int *info, void **s, x_spline1dfitreport *rep);
        private static _d_spline1dfithermitewc _i_ser_spline1dfithermitewc = null;
        private static _d_spline1dfithermitewc _i_smp_spline1dfithermitewc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dfitcubic(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_int *info, void **s, x_spline1dfitreport *rep);
        private static _d_spline1dfitcubic _i_ser_spline1dfitcubic = null;
        private static _d_spline1dfitcubic _i_smp_spline1dfitcubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline1dfithermite(byte **error_msg, x_vector *x, x_vector *y, x_int *n, x_int *m, x_int *info, void **s, x_spline1dfitreport *rep);
        private static _d_spline1dfithermite _i_ser_spline1dfithermite = null;
        private static _d_spline1dfithermite _i_smp_spline1dfithermite = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitlinearw(byte **error_msg, x_vector *y, x_vector *w, x_matrix *fmatrix, x_int *n, x_int *m, x_int *info, x_vector *c, x_lsfitreport *rep);
        private static _d_lsfitlinearw _i_ser_lsfitlinearw = null;
        private static _d_lsfitlinearw _i_smp_lsfitlinearw = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitlinearwc(byte **error_msg, x_vector *y, x_vector *w, x_matrix *fmatrix, x_matrix *cmatrix, x_int *n, x_int *m, x_int *k, x_int *info, x_vector *c, x_lsfitreport *rep);
        private static _d_lsfitlinearwc _i_ser_lsfitlinearwc = null;
        private static _d_lsfitlinearwc _i_smp_lsfitlinearwc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitlinear(byte **error_msg, x_vector *y, x_matrix *fmatrix, x_int *n, x_int *m, x_int *info, x_vector *c, x_lsfitreport *rep);
        private static _d_lsfitlinear _i_ser_lsfitlinear = null;
        private static _d_lsfitlinear _i_smp_lsfitlinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitlinearc(byte **error_msg, x_vector *y, x_matrix *fmatrix, x_matrix *cmatrix, x_int *n, x_int *m, x_int *k, x_int *info, x_vector *c, x_lsfitreport *rep);
        private static _d_lsfitlinearc _i_ser_lsfitlinearc = null;
        private static _d_lsfitlinearc _i_smp_lsfitlinearc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitcreatewf(byte **error_msg, x_matrix *x, x_vector *y, x_vector *w, x_vector *c, x_int *n, x_int *m, x_int *k, double *diffstep, void **state);
        private static _d_lsfitcreatewf _i_ser_lsfitcreatewf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitcreatef(byte **error_msg, x_matrix *x, x_vector *y, x_vector *c, x_int *n, x_int *m, x_int *k, double *diffstep, void **state);
        private static _d_lsfitcreatef _i_ser_lsfitcreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitcreatewfg(byte **error_msg, x_matrix *x, x_vector *y, x_vector *w, x_vector *c, x_int *n, x_int *m, x_int *k, byte *cheapfg, void **state);
        private static _d_lsfitcreatewfg _i_ser_lsfitcreatewfg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitcreatefg(byte **error_msg, x_matrix *x, x_vector *y, x_vector *c, x_int *n, x_int *m, x_int *k, byte *cheapfg, void **state);
        private static _d_lsfitcreatefg _i_ser_lsfitcreatefg = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitcreatewfgh(byte **error_msg, x_matrix *x, x_vector *y, x_vector *w, x_vector *c, x_int *n, x_int *m, x_int *k, void **state);
        private static _d_lsfitcreatewfgh _i_ser_lsfitcreatewfgh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitcreatefgh(byte **error_msg, x_matrix *x, x_vector *y, x_vector *c, x_int *n, x_int *m, x_int *k, void **state);
        private static _d_lsfitcreatefgh _i_ser_lsfitcreatefgh = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitsetcond(byte **error_msg, void **state, double *epsf, double *epsx, x_int *maxits);
        private static _d_lsfitsetcond _i_ser_lsfitsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitsetstpmax(byte **error_msg, void **state, double *stpmax);
        private static _d_lsfitsetstpmax _i_ser_lsfitsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitsetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_lsfitsetxrep _i_ser_lsfitsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitsetscale(byte **error_msg, void **state, x_vector *s);
        private static _d_lsfitsetscale _i_ser_lsfitsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu);
        private static _d_lsfitsetbc _i_ser_lsfitsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfititeration(byte **error_msg, byte *result, void **state);
        private static _d_lsfititeration _i_ser_lsfititeration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitresults(byte **error_msg, void **state, x_int *info, x_vector *c, x_lsfitreport *rep);
        private static _d_lsfitresults _i_ser_lsfitresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lsfitsetgradientcheck(byte **error_msg, void **state, double *teststep);
        private static _d_lsfitsetgradientcheck _i_ser_lsfitsetgradientcheck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline2build(byte **error_msg, x_matrix *xy, x_int *n, x_int *st, x_int *pt, void **p);
        private static _d_pspline2build _i_ser_pspline2build = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline3build(byte **error_msg, x_matrix *xy, x_int *n, x_int *st, x_int *pt, void **p);
        private static _d_pspline3build _i_ser_pspline3build = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline2buildperiodic(byte **error_msg, x_matrix *xy, x_int *n, x_int *st, x_int *pt, void **p);
        private static _d_pspline2buildperiodic _i_ser_pspline2buildperiodic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline3buildperiodic(byte **error_msg, x_matrix *xy, x_int *n, x_int *st, x_int *pt, void **p);
        private static _d_pspline3buildperiodic _i_ser_pspline3buildperiodic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline2parametervalues(byte **error_msg, void **p, x_int *n, x_vector *t);
        private static _d_pspline2parametervalues _i_ser_pspline2parametervalues = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline3parametervalues(byte **error_msg, void **p, x_int *n, x_vector *t);
        private static _d_pspline3parametervalues _i_ser_pspline3parametervalues = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline2calc(byte **error_msg, void **p, double *t, double *x, double *y);
        private static _d_pspline2calc _i_ser_pspline2calc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline3calc(byte **error_msg, void **p, double *t, double *x, double *y, double *z);
        private static _d_pspline3calc _i_ser_pspline3calc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline2tangent(byte **error_msg, void **p, double *t, double *x, double *y);
        private static _d_pspline2tangent _i_ser_pspline2tangent = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline3tangent(byte **error_msg, void **p, double *t, double *x, double *y, double *z);
        private static _d_pspline3tangent _i_ser_pspline3tangent = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline2diff(byte **error_msg, void **p, double *t, double *x, double *dx, double *y, double *dy);
        private static _d_pspline2diff _i_ser_pspline2diff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline3diff(byte **error_msg, void **p, double *t, double *x, double *dx, double *y, double *dy, double *z, double *dz);
        private static _d_pspline3diff _i_ser_pspline3diff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline2diff2(byte **error_msg, void **p, double *t, double *x, double *dx, double *d2x, double *y, double *dy, double *d2y);
        private static _d_pspline2diff2 _i_ser_pspline2diff2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline3diff2(byte **error_msg, void **p, double *t, double *x, double *dx, double *d2x, double *y, double *dy, double *d2y, double *z, double *dz, double *d2z);
        private static _d_pspline3diff2 _i_ser_pspline3diff2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline2arclength(byte **error_msg, double *result, void **p, double *a, double *b);
        private static _d_pspline2arclength _i_ser_pspline2arclength = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pspline3arclength(byte **error_msg, double *result, void **p, double *a, double *b);
        private static _d_pspline3arclength _i_ser_pspline3arclength = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_parametricrdpfixed(byte **error_msg, x_matrix *x, x_int *n, x_int *d, x_int *stopm, double *stopeps, x_matrix *x2, x_vector *idx2, x_int *nsections);
        private static _d_parametricrdpfixed _i_ser_parametricrdpfixed = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_linlsqrcreate(byte **error_msg, x_int *m, x_int *n, void **state);
        private static _d_linlsqrcreate _i_ser_linlsqrcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_linlsqrsetprecunit(byte **error_msg, void **state);
        private static _d_linlsqrsetprecunit _i_ser_linlsqrsetprecunit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_linlsqrsetprecdiag(byte **error_msg, void **state);
        private static _d_linlsqrsetprecdiag _i_ser_linlsqrsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_linlsqrsetlambdai(byte **error_msg, void **state, double *lambdai);
        private static _d_linlsqrsetlambdai _i_ser_linlsqrsetlambdai = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_linlsqrsolvesparse(byte **error_msg, void **state, void **a, x_vector *b);
        private static _d_linlsqrsolvesparse _i_ser_linlsqrsolvesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_linlsqrsetcond(byte **error_msg, void **state, double *epsa, double *epsb, x_int *maxits);
        private static _d_linlsqrsetcond _i_ser_linlsqrsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_linlsqrresults(byte **error_msg, void **state, x_vector *x, x_linlsqrreport *rep);
        private static _d_linlsqrresults _i_ser_linlsqrresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_linlsqrsetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_linlsqrsetxrep _i_ser_linlsqrsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_rbfserialize(byte **error_msg, void **x, byte **dst);
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_x_rbfunserialize(byte **error_msg, byte **src, void **x);
        private static _d_x_rbfserialize   _i_x_rbfserialize   = null;
        private static _d_x_rbfunserialize _i_x_rbfunserialize = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfcreate(byte **error_msg, x_int *nx, x_int *ny, void **s);
        private static _d_rbfcreate _i_ser_rbfcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfsetpoints(byte **error_msg, void **s, x_matrix *xy, x_int *n);
        private static _d_rbfsetpoints _i_ser_rbfsetpoints = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfsetalgoqnn(byte **error_msg, void **s, double *q, double *z);
        private static _d_rbfsetalgoqnn _i_ser_rbfsetalgoqnn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfsetalgomultilayer(byte **error_msg, void **s, double *rbase, x_int *nlayers, double *lambdav);
        private static _d_rbfsetalgomultilayer _i_ser_rbfsetalgomultilayer = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfsetlinterm(byte **error_msg, void **s);
        private static _d_rbfsetlinterm _i_ser_rbfsetlinterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfsetconstterm(byte **error_msg, void **s);
        private static _d_rbfsetconstterm _i_ser_rbfsetconstterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfsetzeroterm(byte **error_msg, void **s);
        private static _d_rbfsetzeroterm _i_ser_rbfsetzeroterm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfbuildmodel(byte **error_msg, void **s, x_rbfreport *rep);
        private static _d_rbfbuildmodel _i_ser_rbfbuildmodel = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfcalc2(byte **error_msg, double *result, void **s, double *x0, double *x1);
        private static _d_rbfcalc2 _i_ser_rbfcalc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfcalc3(byte **error_msg, double *result, void **s, double *x0, double *x1, double *x2);
        private static _d_rbfcalc3 _i_ser_rbfcalc3 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfcalc(byte **error_msg, void **s, x_vector *x, x_vector *y);
        private static _d_rbfcalc _i_ser_rbfcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfcalcbuf(byte **error_msg, void **s, x_vector *x, x_vector *y);
        private static _d_rbfcalcbuf _i_ser_rbfcalcbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfgridcalc2(byte **error_msg, void **s, x_vector *x0, x_int *n0, x_vector *x1, x_int *n1, x_matrix *y);
        private static _d_rbfgridcalc2 _i_ser_rbfgridcalc2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rbfunpack(byte **error_msg, void **s, x_int *nx, x_int *ny, x_matrix *xwr, x_int *nc, x_matrix *v);
        private static _d_rbfunpack _i_ser_rbfunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dcalc(byte **error_msg, double *result, void **c, double *x, double *y);
        private static _d_spline2dcalc _i_ser_spline2dcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2ddiff(byte **error_msg, void **c, double *x, double *y, double *f, double *fx, double *fy, double *fxy);
        private static _d_spline2ddiff _i_ser_spline2ddiff = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dlintransxy(byte **error_msg, void **c, double *ax, double *bx, double *ay, double *by);
        private static _d_spline2dlintransxy _i_ser_spline2dlintransxy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dlintransf(byte **error_msg, void **c, double *a, double *b);
        private static _d_spline2dlintransf _i_ser_spline2dlintransf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dcopy(byte **error_msg, void **c, void **cc);
        private static _d_spline2dcopy _i_ser_spline2dcopy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dresamplebicubic(byte **error_msg, x_matrix *a, x_int *oldheight, x_int *oldwidth, x_matrix *b, x_int *newheight, x_int *newwidth);
        private static _d_spline2dresamplebicubic _i_ser_spline2dresamplebicubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dresamplebilinear(byte **error_msg, x_matrix *a, x_int *oldheight, x_int *oldwidth, x_matrix *b, x_int *newheight, x_int *newwidth);
        private static _d_spline2dresamplebilinear _i_ser_spline2dresamplebilinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dbuildbilinearv(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, x_vector *f, x_int *d, void **c);
        private static _d_spline2dbuildbilinearv _i_ser_spline2dbuildbilinearv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dbuildbicubicv(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, x_vector *f, x_int *d, void **c);
        private static _d_spline2dbuildbicubicv _i_ser_spline2dbuildbicubicv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dcalcvbuf(byte **error_msg, void **c, double *x, double *y, x_vector *f);
        private static _d_spline2dcalcvbuf _i_ser_spline2dcalcvbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dcalcv(byte **error_msg, void **c, double *x, double *y, x_vector *f);
        private static _d_spline2dcalcv _i_ser_spline2dcalcv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dunpackv(byte **error_msg, void **c, x_int *m, x_int *n, x_int *d, x_matrix *tbl);
        private static _d_spline2dunpackv _i_ser_spline2dunpackv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dbuildbilinear(byte **error_msg, x_vector *x, x_vector *y, x_matrix *f, x_int *m, x_int *n, void **c);
        private static _d_spline2dbuildbilinear _i_ser_spline2dbuildbilinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dbuildbicubic(byte **error_msg, x_vector *x, x_vector *y, x_matrix *f, x_int *m, x_int *n, void **c);
        private static _d_spline2dbuildbicubic _i_ser_spline2dbuildbicubic = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline2dunpack(byte **error_msg, void **c, x_int *m, x_int *n, x_matrix *tbl);
        private static _d_spline2dunpack _i_ser_spline2dunpack = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline3dcalc(byte **error_msg, double *result, void **c, double *x, double *y, double *z);
        private static _d_spline3dcalc _i_ser_spline3dcalc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline3dlintransxyz(byte **error_msg, void **c, double *ax, double *bx, double *ay, double *by, double *az, double *bz);
        private static _d_spline3dlintransxyz _i_ser_spline3dlintransxyz = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline3dlintransf(byte **error_msg, void **c, double *a, double *b);
        private static _d_spline3dlintransf _i_ser_spline3dlintransf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline3dresampletrilinear(byte **error_msg, x_vector *a, x_int *oldzcount, x_int *oldycount, x_int *oldxcount, x_int *newzcount, x_int *newycount, x_int *newxcount, x_vector *b);
        private static _d_spline3dresampletrilinear _i_ser_spline3dresampletrilinear = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline3dbuildtrilinearv(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, x_vector *z, x_int *l, x_vector *f, x_int *d, void **c);
        private static _d_spline3dbuildtrilinearv _i_ser_spline3dbuildtrilinearv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline3dcalcvbuf(byte **error_msg, void **c, double *x, double *y, double *z, x_vector *f);
        private static _d_spline3dcalcvbuf _i_ser_spline3dcalcvbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline3dcalcv(byte **error_msg, void **c, double *x, double *y, double *z, x_vector *f);
        private static _d_spline3dcalcv _i_ser_spline3dcalcv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spline3dunpackv(byte **error_msg, void **c, x_int *n, x_int *m, x_int *l, x_int *d, x_int *stype, x_matrix *tbl);
        private static _d_spline3dunpackv _i_ser_spline3dunpackv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixludet(byte **error_msg, double *result, x_matrix *a, x_vector *pivots, x_int *n);
        private static _d_rmatrixludet _i_ser_rmatrixludet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixdet(byte **error_msg, double *result, x_matrix *a, x_int *n);
        private static _d_rmatrixdet _i_ser_rmatrixdet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixludet(byte **error_msg, alglib.complex *result, x_matrix *a, x_vector *pivots, x_int *n);
        private static _d_cmatrixludet _i_ser_cmatrixludet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_cmatrixdet(byte **error_msg, alglib.complex *result, x_matrix *a, x_int *n);
        private static _d_cmatrixdet _i_ser_cmatrixdet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixcholeskydet(byte **error_msg, double *result, x_matrix *a, x_int *n);
        private static _d_spdmatrixcholeskydet _i_ser_spdmatrixcholeskydet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spdmatrixdet(byte **error_msg, double *result, x_matrix *a, x_int *n, byte *isupper);
        private static _d_spdmatrixdet _i_ser_spdmatrixdet = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixgevd(byte **error_msg, byte *result, x_matrix *a, x_int *n, byte *isuppera, x_matrix *b, byte *isupperb, x_int *zneeded, x_int *problemtype, x_vector *d, x_matrix *z);
        private static _d_smatrixgevd _i_ser_smatrixgevd = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_smatrixgevdreduce(byte **error_msg, byte *result, x_matrix *a, x_int *n, byte *isuppera, x_matrix *b, byte *isupperb, x_int *problemtype, x_matrix *r, byte *isupperr);
        private static _d_smatrixgevdreduce _i_ser_smatrixgevdreduce = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixinvupdatesimple(byte **error_msg, x_matrix *inva, x_int *n, x_int *updrow, x_int *updcolumn, double *updval);
        private static _d_rmatrixinvupdatesimple _i_ser_rmatrixinvupdatesimple = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixinvupdaterow(byte **error_msg, x_matrix *inva, x_int *n, x_int *updrow, x_vector *v);
        private static _d_rmatrixinvupdaterow _i_ser_rmatrixinvupdaterow = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixinvupdatecolumn(byte **error_msg, x_matrix *inva, x_int *n, x_int *updcolumn, x_vector *u);
        private static _d_rmatrixinvupdatecolumn _i_ser_rmatrixinvupdatecolumn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixinvupdateuv(byte **error_msg, x_matrix *inva, x_int *n, x_vector *u, x_vector *v);
        private static _d_rmatrixinvupdateuv _i_ser_rmatrixinvupdateuv = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_rmatrixschur(byte **error_msg, byte *result, x_matrix *a, x_int *n, x_matrix *s);
        private static _d_rmatrixschur _i_ser_rmatrixschur = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetdefaultpreconditioner(byte **error_msg, void **state);
        private static _d_minlbfgssetdefaultpreconditioner _i_ser_minlbfgssetdefaultpreconditioner = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minlbfgssetcholeskypreconditioner(byte **error_msg, void **state, x_matrix *p, byte *isupper);
        private static _d_minlbfgssetcholeskypreconditioner _i_ser_minlbfgssetcholeskypreconditioner = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetbarrierwidth(byte **error_msg, void **state, double *mu);
        private static _d_minbleicsetbarrierwidth _i_ser_minbleicsetbarrierwidth = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minbleicsetbarrierdecay(byte **error_msg, void **state, double *mudecay);
        private static _d_minbleicsetbarrierdecay _i_ser_minbleicsetbarrierdecay = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasacreate(byte **error_msg, x_int *n, x_vector *x, x_vector *bndl, x_vector *bndu, void **state);
        private static _d_minasacreate _i_ser_minasacreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasasetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits);
        private static _d_minasasetcond _i_ser_minasasetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasasetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_minasasetxrep _i_ser_minasasetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasasetalgorithm(byte **error_msg, void **state, x_int *algotype);
        private static _d_minasasetalgorithm _i_ser_minasasetalgorithm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasasetstpmax(byte **error_msg, void **state, double *stpmax);
        private static _d_minasasetstpmax _i_ser_minasasetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasaiteration(byte **error_msg, byte *result, void **state);
        private static _d_minasaiteration _i_ser_minasaiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasaresults(byte **error_msg, void **state, x_vector *x, x_minasareport *rep);
        private static _d_minasaresults _i_ser_minasaresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasaresultsbuf(byte **error_msg, void **state, x_vector *x, x_minasareport *rep);
        private static _d_minasaresultsbuf _i_ser_minasaresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minasarestartfrom(byte **error_msg, void **state, x_vector *x, x_vector *bndl, x_vector *bndu);
        private static _d_minasarestartfrom _i_ser_minasarestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlccreate(byte **error_msg, x_int *n, x_vector *x, void **state);
        private static _d_minnlccreate _i_ser_minnlccreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlccreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state);
        private static _d_minnlccreatef _i_ser_minnlccreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu);
        private static _d_minnlcsetbc _i_ser_minnlcsetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k);
        private static _d_minnlcsetlc _i_ser_minnlcsetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetnlc(byte **error_msg, void **state, x_int *nlec, x_int *nlic);
        private static _d_minnlcsetnlc _i_ser_minnlcsetnlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetcond(byte **error_msg, void **state, double *epsg, double *epsf, double *epsx, x_int *maxits);
        private static _d_minnlcsetcond _i_ser_minnlcsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetscale(byte **error_msg, void **state, x_vector *s);
        private static _d_minnlcsetscale _i_ser_minnlcsetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetprecinexact(byte **error_msg, void **state);
        private static _d_minnlcsetprecinexact _i_ser_minnlcsetprecinexact = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetprecexactlowrank(byte **error_msg, void **state, x_int *updatefreq);
        private static _d_minnlcsetprecexactlowrank _i_ser_minnlcsetprecexactlowrank = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetprecnone(byte **error_msg, void **state);
        private static _d_minnlcsetprecnone _i_ser_minnlcsetprecnone = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetalgoaul(byte **error_msg, void **state, double *rho, x_int *itscnt);
        private static _d_minnlcsetalgoaul _i_ser_minnlcsetalgoaul = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_minnlcsetxrep _i_ser_minnlcsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlciteration(byte **error_msg, byte *result, void **state);
        private static _d_minnlciteration _i_ser_minnlciteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcresults(byte **error_msg, void **state, x_vector *x, x_minnlcreport *rep);
        private static _d_minnlcresults _i_ser_minnlcresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcresultsbuf(byte **error_msg, void **state, x_vector *x, x_minnlcreport *rep);
        private static _d_minnlcresultsbuf _i_ser_minnlcresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcrestartfrom(byte **error_msg, void **state, x_vector *x);
        private static _d_minnlcrestartfrom _i_ser_minnlcrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnlcsetgradientcheck(byte **error_msg, void **state, double *teststep);
        private static _d_minnlcsetgradientcheck _i_ser_minnlcsetgradientcheck = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnscreate(byte **error_msg, x_int *n, x_vector *x, void **state);
        private static _d_minnscreate _i_ser_minnscreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnscreatef(byte **error_msg, x_int *n, x_vector *x, double *diffstep, void **state);
        private static _d_minnscreatef _i_ser_minnscreatef = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnssetbc(byte **error_msg, void **state, x_vector *bndl, x_vector *bndu);
        private static _d_minnssetbc _i_ser_minnssetbc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnssetlc(byte **error_msg, void **state, x_matrix *c, x_vector *ct, x_int *k);
        private static _d_minnssetlc _i_ser_minnssetlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnssetnlc(byte **error_msg, void **state, x_int *nlec, x_int *nlic);
        private static _d_minnssetnlc _i_ser_minnssetnlc = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnssetcond(byte **error_msg, void **state, double *epsx, x_int *maxits);
        private static _d_minnssetcond _i_ser_minnssetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnssetscale(byte **error_msg, void **state, x_vector *s);
        private static _d_minnssetscale _i_ser_minnssetscale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnssetalgoags(byte **error_msg, void **state, double *radius, double *penalty);
        private static _d_minnssetalgoags _i_ser_minnssetalgoags = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnssetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_minnssetxrep _i_ser_minnssetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnsrequesttermination(byte **error_msg, void **state);
        private static _d_minnsrequesttermination _i_ser_minnsrequesttermination = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnsiteration(byte **error_msg, byte *result, void **state);
        private static _d_minnsiteration _i_ser_minnsiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnsresults(byte **error_msg, void **state, x_vector *x, x_minnsreport *rep);
        private static _d_minnsresults _i_ser_minnsresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnsresultsbuf(byte **error_msg, void **state, x_vector *x, x_minnsreport *rep);
        private static _d_minnsresultsbuf _i_ser_minnsresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_minnsrestartfrom(byte **error_msg, void **state, x_vector *x);
        private static _d_minnsrestartfrom _i_ser_minnsrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgcreate(byte **error_msg, x_int *n, void **state);
        private static _d_lincgcreate _i_ser_lincgcreate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgsetstartingpoint(byte **error_msg, void **state, x_vector *x);
        private static _d_lincgsetstartingpoint _i_ser_lincgsetstartingpoint = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgsetprecunit(byte **error_msg, void **state);
        private static _d_lincgsetprecunit _i_ser_lincgsetprecunit = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgsetprecdiag(byte **error_msg, void **state);
        private static _d_lincgsetprecdiag _i_ser_lincgsetprecdiag = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgsetcond(byte **error_msg, void **state, double *epsf, x_int *maxits);
        private static _d_lincgsetcond _i_ser_lincgsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgsolvesparse(byte **error_msg, void **state, void **a, byte *isupper, x_vector *b);
        private static _d_lincgsolvesparse _i_ser_lincgsolvesparse = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgresults(byte **error_msg, void **state, x_vector *x, x_lincgreport *rep);
        private static _d_lincgresults _i_ser_lincgresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgsetrestartfreq(byte **error_msg, void **state, x_int *srf);
        private static _d_lincgsetrestartfreq _i_ser_lincgsetrestartfreq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgsetrupdatefreq(byte **error_msg, void **state, x_int *freq);
        private static _d_lincgsetrupdatefreq _i_ser_lincgsetrupdatefreq = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_lincgsetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_lincgsetxrep _i_ser_lincgsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_nleqcreatelm(byte **error_msg, x_int *n, x_int *m, x_vector *x, void **state);
        private static _d_nleqcreatelm _i_ser_nleqcreatelm = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_nleqsetcond(byte **error_msg, void **state, double *epsf, x_int *maxits);
        private static _d_nleqsetcond _i_ser_nleqsetcond = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_nleqsetxrep(byte **error_msg, void **state, byte *needxrep);
        private static _d_nleqsetxrep _i_ser_nleqsetxrep = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_nleqsetstpmax(byte **error_msg, void **state, double *stpmax);
        private static _d_nleqsetstpmax _i_ser_nleqsetstpmax = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_nleqiteration(byte **error_msg, byte *result, void **state);
        private static _d_nleqiteration _i_ser_nleqiteration = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_nleqresults(byte **error_msg, void **state, x_vector *x, x_nleqreport *rep);
        private static _d_nleqresults _i_ser_nleqresults = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_nleqresultsbuf(byte **error_msg, void **state, x_vector *x, x_nleqreport *rep);
        private static _d_nleqresultsbuf _i_ser_nleqresultsbuf = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_nleqrestartfrom(byte **error_msg, void **state, x_vector *x);
        private static _d_nleqrestartfrom _i_ser_nleqrestartfrom = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_polynomialsolve(byte **error_msg, x_vector *a, x_int *n, x_vector *x, x_polynomialsolverreport *rep);
        private static _d_polynomialsolve _i_ser_polynomialsolve = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_airy(byte **error_msg, double *x, double *ai, double *aip, double *bi, double *bip);
        private static _d_airy _i_ser_airy = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besselj0(byte **error_msg, double *result, double *x);
        private static _d_besselj0 _i_ser_besselj0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besselj1(byte **error_msg, double *result, double *x);
        private static _d_besselj1 _i_ser_besselj1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besseljn(byte **error_msg, double *result, x_int *n, double *x);
        private static _d_besseljn _i_ser_besseljn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_bessely0(byte **error_msg, double *result, double *x);
        private static _d_bessely0 _i_ser_bessely0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_bessely1(byte **error_msg, double *result, double *x);
        private static _d_bessely1 _i_ser_bessely1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besselyn(byte **error_msg, double *result, x_int *n, double *x);
        private static _d_besselyn _i_ser_besselyn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besseli0(byte **error_msg, double *result, double *x);
        private static _d_besseli0 _i_ser_besseli0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besseli1(byte **error_msg, double *result, double *x);
        private static _d_besseli1 _i_ser_besseli1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besselk0(byte **error_msg, double *result, double *x);
        private static _d_besselk0 _i_ser_besselk0 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besselk1(byte **error_msg, double *result, double *x);
        private static _d_besselk1 _i_ser_besselk1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_besselkn(byte **error_msg, double *result, x_int *nn, double *x);
        private static _d_besselkn _i_ser_besselkn = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_beta(byte **error_msg, double *result, double *a, double *b);
        private static _d_beta _i_ser_beta = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_incompletebeta(byte **error_msg, double *result, double *a, double *b, double *x);
        private static _d_incompletebeta _i_ser_incompletebeta = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_invincompletebeta(byte **error_msg, double *result, double *a, double *b, double *y);
        private static _d_invincompletebeta _i_ser_invincompletebeta = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_binomialdistribution(byte **error_msg, double *result, x_int *k, x_int *n, double *p);
        private static _d_binomialdistribution _i_ser_binomialdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_binomialcdistribution(byte **error_msg, double *result, x_int *k, x_int *n, double *p);
        private static _d_binomialcdistribution _i_ser_binomialcdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_invbinomialdistribution(byte **error_msg, double *result, x_int *k, x_int *n, double *y);
        private static _d_invbinomialdistribution _i_ser_invbinomialdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_chebyshevcalculate(byte **error_msg, double *result, x_int *r, x_int *n, double *x);
        private static _d_chebyshevcalculate _i_ser_chebyshevcalculate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_chebyshevsum(byte **error_msg, double *result, x_vector *c, x_int *r, x_int *n, double *x);
        private static _d_chebyshevsum _i_ser_chebyshevsum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_chebyshevcoefficients(byte **error_msg, x_int *n, x_vector *c);
        private static _d_chebyshevcoefficients _i_ser_chebyshevcoefficients = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fromchebyshev(byte **error_msg, x_vector *a, x_int *n, x_vector *b);
        private static _d_fromchebyshev _i_ser_fromchebyshev = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_chisquaredistribution(byte **error_msg, double *result, double *v, double *x);
        private static _d_chisquaredistribution _i_ser_chisquaredistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_chisquarecdistribution(byte **error_msg, double *result, double *v, double *x);
        private static _d_chisquarecdistribution _i_ser_chisquarecdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_invchisquaredistribution(byte **error_msg, double *result, double *v, double *y);
        private static _d_invchisquaredistribution _i_ser_invchisquaredistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_dawsonintegral(byte **error_msg, double *result, double *x);
        private static _d_dawsonintegral _i_ser_dawsonintegral = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_ellipticintegralk(byte **error_msg, double *result, double *m);
        private static _d_ellipticintegralk _i_ser_ellipticintegralk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_ellipticintegralkhighprecision(byte **error_msg, double *result, double *m1);
        private static _d_ellipticintegralkhighprecision _i_ser_ellipticintegralkhighprecision = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_incompleteellipticintegralk(byte **error_msg, double *result, double *phi, double *m);
        private static _d_incompleteellipticintegralk _i_ser_incompleteellipticintegralk = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_ellipticintegrale(byte **error_msg, double *result, double *m);
        private static _d_ellipticintegrale _i_ser_ellipticintegrale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_incompleteellipticintegrale(byte **error_msg, double *result, double *phi, double *m);
        private static _d_incompleteellipticintegrale _i_ser_incompleteellipticintegrale = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_exponentialintegralei(byte **error_msg, double *result, double *x);
        private static _d_exponentialintegralei _i_ser_exponentialintegralei = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_exponentialintegralen(byte **error_msg, double *result, double *x, x_int *n);
        private static _d_exponentialintegralen _i_ser_exponentialintegralen = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fdistribution(byte **error_msg, double *result, x_int *a, x_int *b, double *x);
        private static _d_fdistribution _i_ser_fdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fcdistribution(byte **error_msg, double *result, x_int *a, x_int *b, double *x);
        private static _d_fcdistribution _i_ser_fcdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_invfdistribution(byte **error_msg, double *result, x_int *a, x_int *b, double *y);
        private static _d_invfdistribution _i_ser_invfdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_fresnelintegral(byte **error_msg, double *x, double *c, double *s);
        private static _d_fresnelintegral _i_ser_fresnelintegral = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hermitecalculate(byte **error_msg, double *result, x_int *n, double *x);
        private static _d_hermitecalculate _i_ser_hermitecalculate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hermitesum(byte **error_msg, double *result, x_vector *c, x_int *n, double *x);
        private static _d_hermitesum _i_ser_hermitesum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hermitecoefficients(byte **error_msg, x_int *n, x_vector *c);
        private static _d_hermitecoefficients _i_ser_hermitecoefficients = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_jacobianellipticfunctions(byte **error_msg, double *u, double *m, double *sn, double *cn, double *dn, double *ph);
        private static _d_jacobianellipticfunctions _i_ser_jacobianellipticfunctions = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_laguerrecalculate(byte **error_msg, double *result, x_int *n, double *x);
        private static _d_laguerrecalculate _i_ser_laguerrecalculate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_laguerresum(byte **error_msg, double *result, x_vector *c, x_int *n, double *x);
        private static _d_laguerresum _i_ser_laguerresum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_laguerrecoefficients(byte **error_msg, x_int *n, x_vector *c);
        private static _d_laguerrecoefficients _i_ser_laguerrecoefficients = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_legendrecalculate(byte **error_msg, double *result, x_int *n, double *x);
        private static _d_legendrecalculate _i_ser_legendrecalculate = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_legendresum(byte **error_msg, double *result, x_vector *c, x_int *n, double *x);
        private static _d_legendresum _i_ser_legendresum = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_legendrecoefficients(byte **error_msg, x_int *n, x_vector *c);
        private static _d_legendrecoefficients _i_ser_legendrecoefficients = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_poissondistribution(byte **error_msg, double *result, x_int *k, double *m);
        private static _d_poissondistribution _i_ser_poissondistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_poissoncdistribution(byte **error_msg, double *result, x_int *k, double *m);
        private static _d_poissoncdistribution _i_ser_poissoncdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_invpoissondistribution(byte **error_msg, double *result, x_int *k, double *y);
        private static _d_invpoissondistribution _i_ser_invpoissondistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_psi(byte **error_msg, double *result, double *x);
        private static _d_psi _i_ser_psi = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_studenttdistribution(byte **error_msg, double *result, x_int *k, double *t);
        private static _d_studenttdistribution _i_ser_studenttdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_invstudenttdistribution(byte **error_msg, double *result, x_int *k, double *p);
        private static _d_invstudenttdistribution _i_ser_invstudenttdistribution = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_sinecosineintegrals(byte **error_msg, double *x, double *si, double *ci);
        private static _d_sinecosineintegrals _i_ser_sinecosineintegrals = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_hyperbolicsinecosineintegrals(byte **error_msg, double *x, double *shi, double *chi);
        private static _d_hyperbolicsinecosineintegrals _i_ser_hyperbolicsinecosineintegrals = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_pearsoncorrelationsignificance(byte **error_msg, double *r, x_int *n, double *bothtails, double *lefttail, double *righttail);
        private static _d_pearsoncorrelationsignificance _i_ser_pearsoncorrelationsignificance = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_spearmanrankcorrelationsignificance(byte **error_msg, double *r, x_int *n, double *bothtails, double *lefttail, double *righttail);
        private static _d_spearmanrankcorrelationsignificance _i_ser_spearmanrankcorrelationsignificance = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_jarqueberatest(byte **error_msg, x_vector *x, x_int *n, double *p);
        private static _d_jarqueberatest _i_ser_jarqueberatest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_mannwhitneyutest(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, double *bothtails, double *lefttail, double *righttail);
        private static _d_mannwhitneyutest _i_ser_mannwhitneyutest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_onesamplesigntest(byte **error_msg, x_vector *x, x_int *n, double *median, double *bothtails, double *lefttail, double *righttail);
        private static _d_onesamplesigntest _i_ser_onesamplesigntest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_studentttest1(byte **error_msg, x_vector *x, x_int *n, double *mean, double *bothtails, double *lefttail, double *righttail);
        private static _d_studentttest1 _i_ser_studentttest1 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_studentttest2(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, double *bothtails, double *lefttail, double *righttail);
        private static _d_studentttest2 _i_ser_studentttest2 = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_unequalvariancettest(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, double *bothtails, double *lefttail, double *righttail);
        private static _d_unequalvariancettest _i_ser_unequalvariancettest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_ftest(byte **error_msg, x_vector *x, x_int *n, x_vector *y, x_int *m, double *bothtails, double *lefttail, double *righttail);
        private static _d_ftest _i_ser_ftest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_onesamplevariancetest(byte **error_msg, x_vector *x, x_int *n, double *variance, double *bothtails, double *lefttail, double *righttail);
        private static _d_onesamplevariancetest _i_ser_onesamplevariancetest = null;
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate int _d_wilcoxonsignedranktest(byte **error_msg, x_vector *x, x_int *n, double *e, double *bothtails, double *lefttail, double *righttail);
        private static _d_wilcoxonsignedranktest _i_ser_wilcoxonsignedranktest = null;


    //
    // This function loads pointers to functions of ALGLIB HPC core.
    // This function must be called once by activatealglibcore() during
    // initialization of HPC core.
    //
    private static void LoadALGLIBFunctions(IntPtr hTmpDL)
    {
        x_malloc                    =                 (_d_x_malloc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_malloc"),       typeof(_d_x_malloc));
        x_free                      =                   (_d_x_free)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_free"),         typeof(_d_x_free));
        x_setnworkers               =            (_d_x_setnworkers)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_setnworkers"),  typeof(_d_x_setnworkers));
        x_alloc_counter             =          (_d_x_alloc_counter)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_alloc_counter"),  typeof(_d_x_alloc_counter));
        x_alloc_counter_activate    = (_d_x_alloc_counter_activate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_alloc_counter_activate"),  typeof(_d_x_alloc_counter_activate));
        _i_x_obj_copy_hqrndstate = (_d_x_obj_copy_hqrndstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_hqrndstate"), typeof(_d_x_obj_copy_hqrndstate));
        _i_x_obj_free_hqrndstate = (_d_x_obj_free_hqrndstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_hqrndstate"), typeof(_d_x_obj_free_hqrndstate));
            _i_ser_hqrndrandomize = (_d_hqrndrandomize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrndrandomize"), typeof(_d_hqrndrandomize));
            _i_ser_hqrndseed = (_d_hqrndseed)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrndseed"), typeof(_d_hqrndseed));
            _i_ser_hqrnduniformr = (_d_hqrnduniformr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrnduniformr"), typeof(_d_hqrnduniformr));
            _i_ser_hqrnduniformi = (_d_hqrnduniformi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrnduniformi"), typeof(_d_hqrnduniformi));
            _i_ser_hqrndnormal = (_d_hqrndnormal)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrndnormal"), typeof(_d_hqrndnormal));
            _i_ser_hqrndunit2 = (_d_hqrndunit2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrndunit2"), typeof(_d_hqrndunit2));
            _i_ser_hqrndnormal2 = (_d_hqrndnormal2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrndnormal2"), typeof(_d_hqrndnormal2));
            _i_ser_hqrndexponential = (_d_hqrndexponential)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrndexponential"), typeof(_d_hqrndexponential));
            _i_ser_hqrnddiscrete = (_d_hqrnddiscrete)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrnddiscrete"), typeof(_d_hqrnddiscrete));
            _i_ser_hqrndcontinuous = (_d_hqrndcontinuous)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hqrndcontinuous"), typeof(_d_hqrndcontinuous));
        _i_x_obj_copy_kdtree = (_d_x_obj_copy_kdtree)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_kdtree"), typeof(_d_x_obj_copy_kdtree));
        _i_x_obj_free_kdtree = (_d_x_obj_free_kdtree)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_kdtree"), typeof(_d_x_obj_free_kdtree));
            _i_x_kdtreeserialize   =   (_d_x_kdtreeserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreeserialize"),   typeof(_d_x_kdtreeserialize));
            _i_x_kdtreeunserialize = (_d_x_kdtreeunserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreeunserialize"), typeof(_d_x_kdtreeunserialize));
            _i_ser_kdtreebuild = (_d_kdtreebuild)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreebuild"), typeof(_d_kdtreebuild));
            _i_ser_kdtreebuildtagged = (_d_kdtreebuildtagged)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreebuildtagged"), typeof(_d_kdtreebuildtagged));
            _i_ser_kdtreequeryknn = (_d_kdtreequeryknn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryknn"), typeof(_d_kdtreequeryknn));
            _i_ser_kdtreequeryrnn = (_d_kdtreequeryrnn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryrnn"), typeof(_d_kdtreequeryrnn));
            _i_ser_kdtreequeryaknn = (_d_kdtreequeryaknn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryaknn"), typeof(_d_kdtreequeryaknn));
            _i_ser_kdtreequeryresultsx = (_d_kdtreequeryresultsx)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryresultsx"), typeof(_d_kdtreequeryresultsx));
            _i_ser_kdtreequeryresultsxy = (_d_kdtreequeryresultsxy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryresultsxy"), typeof(_d_kdtreequeryresultsxy));
            _i_ser_kdtreequeryresultstags = (_d_kdtreequeryresultstags)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryresultstags"), typeof(_d_kdtreequeryresultstags));
            _i_ser_kdtreequeryresultsdistances = (_d_kdtreequeryresultsdistances)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryresultsdistances"), typeof(_d_kdtreequeryresultsdistances));
            _i_ser_kdtreequeryresultsxi = (_d_kdtreequeryresultsxi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryresultsxi"), typeof(_d_kdtreequeryresultsxi));
            _i_ser_kdtreequeryresultsxyi = (_d_kdtreequeryresultsxyi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryresultsxyi"), typeof(_d_kdtreequeryresultsxyi));
            _i_ser_kdtreequeryresultstagsi = (_d_kdtreequeryresultstagsi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryresultstagsi"), typeof(_d_kdtreequeryresultstagsi));
            _i_ser_kdtreequeryresultsdistancesi = (_d_kdtreequeryresultsdistancesi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kdtreequeryresultsdistancesi"), typeof(_d_kdtreequeryresultsdistancesi));
            _i_ser_xdebuginitrecord1 = (_d_xdebuginitrecord1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebuginitrecord1"), typeof(_d_xdebuginitrecord1));
            _i_ser_xdebugb1count = (_d_xdebugb1count)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugb1count"), typeof(_d_xdebugb1count));
            _i_ser_xdebugb1not = (_d_xdebugb1not)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugb1not"), typeof(_d_xdebugb1not));
            _i_ser_xdebugb1appendcopy = (_d_xdebugb1appendcopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugb1appendcopy"), typeof(_d_xdebugb1appendcopy));
            _i_ser_xdebugb1outeven = (_d_xdebugb1outeven)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugb1outeven"), typeof(_d_xdebugb1outeven));
            _i_ser_xdebugi1sum = (_d_xdebugi1sum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugi1sum"), typeof(_d_xdebugi1sum));
            _i_ser_xdebugi1neg = (_d_xdebugi1neg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugi1neg"), typeof(_d_xdebugi1neg));
            _i_ser_xdebugi1appendcopy = (_d_xdebugi1appendcopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugi1appendcopy"), typeof(_d_xdebugi1appendcopy));
            _i_ser_xdebugi1outeven = (_d_xdebugi1outeven)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugi1outeven"), typeof(_d_xdebugi1outeven));
            _i_ser_xdebugr1sum = (_d_xdebugr1sum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugr1sum"), typeof(_d_xdebugr1sum));
            _i_ser_xdebugr1neg = (_d_xdebugr1neg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugr1neg"), typeof(_d_xdebugr1neg));
            _i_ser_xdebugr1appendcopy = (_d_xdebugr1appendcopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugr1appendcopy"), typeof(_d_xdebugr1appendcopy));
            _i_ser_xdebugr1outeven = (_d_xdebugr1outeven)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugr1outeven"), typeof(_d_xdebugr1outeven));
            _i_ser_xdebugc1sum = (_d_xdebugc1sum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugc1sum"), typeof(_d_xdebugc1sum));
            _i_ser_xdebugc1neg = (_d_xdebugc1neg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugc1neg"), typeof(_d_xdebugc1neg));
            _i_ser_xdebugc1appendcopy = (_d_xdebugc1appendcopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugc1appendcopy"), typeof(_d_xdebugc1appendcopy));
            _i_ser_xdebugc1outeven = (_d_xdebugc1outeven)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugc1outeven"), typeof(_d_xdebugc1outeven));
            _i_ser_xdebugb2count = (_d_xdebugb2count)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugb2count"), typeof(_d_xdebugb2count));
            _i_ser_xdebugb2not = (_d_xdebugb2not)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugb2not"), typeof(_d_xdebugb2not));
            _i_ser_xdebugb2transpose = (_d_xdebugb2transpose)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugb2transpose"), typeof(_d_xdebugb2transpose));
            _i_ser_xdebugb2outsin = (_d_xdebugb2outsin)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugb2outsin"), typeof(_d_xdebugb2outsin));
            _i_ser_xdebugi2sum = (_d_xdebugi2sum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugi2sum"), typeof(_d_xdebugi2sum));
            _i_ser_xdebugi2neg = (_d_xdebugi2neg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugi2neg"), typeof(_d_xdebugi2neg));
            _i_ser_xdebugi2transpose = (_d_xdebugi2transpose)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugi2transpose"), typeof(_d_xdebugi2transpose));
            _i_ser_xdebugi2outsin = (_d_xdebugi2outsin)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugi2outsin"), typeof(_d_xdebugi2outsin));
            _i_ser_xdebugr2sum = (_d_xdebugr2sum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugr2sum"), typeof(_d_xdebugr2sum));
            _i_ser_xdebugr2neg = (_d_xdebugr2neg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugr2neg"), typeof(_d_xdebugr2neg));
            _i_ser_xdebugr2transpose = (_d_xdebugr2transpose)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugr2transpose"), typeof(_d_xdebugr2transpose));
            _i_ser_xdebugr2outsin = (_d_xdebugr2outsin)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugr2outsin"), typeof(_d_xdebugr2outsin));
            _i_ser_xdebugc2sum = (_d_xdebugc2sum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugc2sum"), typeof(_d_xdebugc2sum));
            _i_ser_xdebugc2neg = (_d_xdebugc2neg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugc2neg"), typeof(_d_xdebugc2neg));
            _i_ser_xdebugc2transpose = (_d_xdebugc2transpose)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugc2transpose"), typeof(_d_xdebugc2transpose));
            _i_ser_xdebugc2outsincos = (_d_xdebugc2outsincos)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugc2outsincos"), typeof(_d_xdebugc2outsincos));
            _i_ser_xdebugmaskedbiasedproductsum = (_d_xdebugmaskedbiasedproductsum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_xdebugmaskedbiasedproductsum"), typeof(_d_xdebugmaskedbiasedproductsum));
            _i_ser_cmatrixtranspose = (_d_cmatrixtranspose)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixtranspose"), typeof(_d_cmatrixtranspose));
            _i_ser_rmatrixtranspose = (_d_rmatrixtranspose)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixtranspose"), typeof(_d_rmatrixtranspose));
            _i_ser_rmatrixenforcesymmetricity = (_d_rmatrixenforcesymmetricity)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixenforcesymmetricity"), typeof(_d_rmatrixenforcesymmetricity));
            _i_ser_cmatrixcopy = (_d_cmatrixcopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixcopy"), typeof(_d_cmatrixcopy));
            _i_ser_rmatrixcopy = (_d_rmatrixcopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixcopy"), typeof(_d_rmatrixcopy));
            _i_ser_cmatrixrank1 = (_d_cmatrixrank1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixrank1"), typeof(_d_cmatrixrank1));
            _i_ser_rmatrixrank1 = (_d_rmatrixrank1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixrank1"), typeof(_d_rmatrixrank1));
            _i_ser_cmatrixmv = (_d_cmatrixmv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixmv"), typeof(_d_cmatrixmv));
            _i_ser_rmatrixmv = (_d_rmatrixmv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixmv"), typeof(_d_rmatrixmv));
            _i_ser_cmatrixrighttrsm = (_d_cmatrixrighttrsm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixrighttrsm"), typeof(_d_cmatrixrighttrsm));
            _i_smp_cmatrixrighttrsm = (_d_cmatrixrighttrsm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixrighttrsm"), typeof(_d_cmatrixrighttrsm));
            _i_ser_cmatrixlefttrsm = (_d_cmatrixlefttrsm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlefttrsm"), typeof(_d_cmatrixlefttrsm));
            _i_smp_cmatrixlefttrsm = (_d_cmatrixlefttrsm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixlefttrsm"), typeof(_d_cmatrixlefttrsm));
            _i_ser_rmatrixrighttrsm = (_d_rmatrixrighttrsm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixrighttrsm"), typeof(_d_rmatrixrighttrsm));
            _i_smp_rmatrixrighttrsm = (_d_rmatrixrighttrsm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixrighttrsm"), typeof(_d_rmatrixrighttrsm));
            _i_ser_rmatrixlefttrsm = (_d_rmatrixlefttrsm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlefttrsm"), typeof(_d_rmatrixlefttrsm));
            _i_smp_rmatrixlefttrsm = (_d_rmatrixlefttrsm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixlefttrsm"), typeof(_d_rmatrixlefttrsm));
            _i_ser_cmatrixherk = (_d_cmatrixherk)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixherk"), typeof(_d_cmatrixherk));
            _i_smp_cmatrixherk = (_d_cmatrixherk)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixherk"), typeof(_d_cmatrixherk));
            _i_ser_rmatrixsyrk = (_d_rmatrixsyrk)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixsyrk"), typeof(_d_rmatrixsyrk));
            _i_smp_rmatrixsyrk = (_d_rmatrixsyrk)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixsyrk"), typeof(_d_rmatrixsyrk));
            _i_ser_cmatrixgemm = (_d_cmatrixgemm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixgemm"), typeof(_d_cmatrixgemm));
            _i_smp_cmatrixgemm = (_d_cmatrixgemm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixgemm"), typeof(_d_cmatrixgemm));
            _i_ser_rmatrixgemm = (_d_rmatrixgemm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixgemm"), typeof(_d_rmatrixgemm));
            _i_smp_rmatrixgemm = (_d_rmatrixgemm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixgemm"), typeof(_d_rmatrixgemm));
            _i_ser_cmatrixsyrk = (_d_cmatrixsyrk)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixsyrk"), typeof(_d_cmatrixsyrk));
            _i_smp_cmatrixsyrk = (_d_cmatrixsyrk)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixsyrk"), typeof(_d_cmatrixsyrk));
            _i_ser_samplemoments = (_d_samplemoments)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_samplemoments"), typeof(_d_samplemoments));
            _i_ser_samplemean = (_d_samplemean)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_samplemean"), typeof(_d_samplemean));
            _i_ser_samplevariance = (_d_samplevariance)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_samplevariance"), typeof(_d_samplevariance));
            _i_ser_sampleskewness = (_d_sampleskewness)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sampleskewness"), typeof(_d_sampleskewness));
            _i_ser_samplekurtosis = (_d_samplekurtosis)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_samplekurtosis"), typeof(_d_samplekurtosis));
            _i_ser_sampleadev = (_d_sampleadev)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sampleadev"), typeof(_d_sampleadev));
            _i_ser_samplemedian = (_d_samplemedian)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_samplemedian"), typeof(_d_samplemedian));
            _i_ser_samplepercentile = (_d_samplepercentile)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_samplepercentile"), typeof(_d_samplepercentile));
            _i_ser_cov2 = (_d_cov2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cov2"), typeof(_d_cov2));
            _i_ser_pearsoncorr2 = (_d_pearsoncorr2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pearsoncorr2"), typeof(_d_pearsoncorr2));
            _i_ser_spearmancorr2 = (_d_spearmancorr2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spearmancorr2"), typeof(_d_spearmancorr2));
            _i_ser_covm = (_d_covm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_covm"), typeof(_d_covm));
            _i_smp_covm = (_d_covm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_covm"), typeof(_d_covm));
            _i_ser_pearsoncorrm = (_d_pearsoncorrm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pearsoncorrm"), typeof(_d_pearsoncorrm));
            _i_smp_pearsoncorrm = (_d_pearsoncorrm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_pearsoncorrm"), typeof(_d_pearsoncorrm));
            _i_ser_spearmancorrm = (_d_spearmancorrm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spearmancorrm"), typeof(_d_spearmancorrm));
            _i_smp_spearmancorrm = (_d_spearmancorrm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spearmancorrm"), typeof(_d_spearmancorrm));
            _i_ser_covm2 = (_d_covm2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_covm2"), typeof(_d_covm2));
            _i_smp_covm2 = (_d_covm2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_covm2"), typeof(_d_covm2));
            _i_ser_pearsoncorrm2 = (_d_pearsoncorrm2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pearsoncorrm2"), typeof(_d_pearsoncorrm2));
            _i_smp_pearsoncorrm2 = (_d_pearsoncorrm2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_pearsoncorrm2"), typeof(_d_pearsoncorrm2));
            _i_ser_spearmancorrm2 = (_d_spearmancorrm2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spearmancorrm2"), typeof(_d_spearmancorrm2));
            _i_smp_spearmancorrm2 = (_d_spearmancorrm2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spearmancorrm2"), typeof(_d_spearmancorrm2));
            _i_ser_rankdata = (_d_rankdata)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rankdata"), typeof(_d_rankdata));
            _i_smp_rankdata = (_d_rankdata)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rankdata"), typeof(_d_rankdata));
            _i_ser_rankdatacentered = (_d_rankdatacentered)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rankdatacentered"), typeof(_d_rankdatacentered));
            _i_smp_rankdatacentered = (_d_rankdatacentered)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rankdatacentered"), typeof(_d_rankdatacentered));
            _i_ser_pearsoncorrelation = (_d_pearsoncorrelation)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pearsoncorrelation"), typeof(_d_pearsoncorrelation));
            _i_ser_spearmanrankcorrelation = (_d_spearmanrankcorrelation)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spearmanrankcorrelation"), typeof(_d_spearmanrankcorrelation));
            _i_ser_dsoptimalsplit2 = (_d_dsoptimalsplit2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dsoptimalsplit2"), typeof(_d_dsoptimalsplit2));
            _i_ser_dsoptimalsplit2fast = (_d_dsoptimalsplit2fast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dsoptimalsplit2fast"), typeof(_d_dsoptimalsplit2fast));
        _i_x_obj_copy_clusterizerstate = (_d_x_obj_copy_clusterizerstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_clusterizerstate"), typeof(_d_x_obj_copy_clusterizerstate));
        _i_x_obj_free_clusterizerstate = (_d_x_obj_free_clusterizerstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_clusterizerstate"), typeof(_d_x_obj_free_clusterizerstate));
            _i_ser_clusterizercreate = (_d_clusterizercreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizercreate"), typeof(_d_clusterizercreate));
            _i_ser_clusterizersetpoints = (_d_clusterizersetpoints)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizersetpoints"), typeof(_d_clusterizersetpoints));
            _i_ser_clusterizersetdistances = (_d_clusterizersetdistances)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizersetdistances"), typeof(_d_clusterizersetdistances));
            _i_ser_clusterizersetahcalgo = (_d_clusterizersetahcalgo)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizersetahcalgo"), typeof(_d_clusterizersetahcalgo));
            _i_ser_clusterizersetkmeanslimits = (_d_clusterizersetkmeanslimits)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizersetkmeanslimits"), typeof(_d_clusterizersetkmeanslimits));
            _i_ser_clusterizersetkmeansinit = (_d_clusterizersetkmeansinit)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizersetkmeansinit"), typeof(_d_clusterizersetkmeansinit));
            _i_ser_clusterizerrunahc = (_d_clusterizerrunahc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizerrunahc"), typeof(_d_clusterizerrunahc));
            _i_smp_clusterizerrunahc = (_d_clusterizerrunahc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_clusterizerrunahc"), typeof(_d_clusterizerrunahc));
            _i_ser_clusterizerrunkmeans = (_d_clusterizerrunkmeans)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizerrunkmeans"), typeof(_d_clusterizerrunkmeans));
            _i_smp_clusterizerrunkmeans = (_d_clusterizerrunkmeans)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_clusterizerrunkmeans"), typeof(_d_clusterizerrunkmeans));
            _i_ser_clusterizergetdistances = (_d_clusterizergetdistances)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizergetdistances"), typeof(_d_clusterizergetdistances));
            _i_smp_clusterizergetdistances = (_d_clusterizergetdistances)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_clusterizergetdistances"), typeof(_d_clusterizergetdistances));
            _i_ser_clusterizergetkclusters = (_d_clusterizergetkclusters)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizergetkclusters"), typeof(_d_clusterizergetkclusters));
            _i_ser_clusterizerseparatedbydist = (_d_clusterizerseparatedbydist)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizerseparatedbydist"), typeof(_d_clusterizerseparatedbydist));
            _i_ser_clusterizerseparatedbycorr = (_d_clusterizerseparatedbycorr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_clusterizerseparatedbycorr"), typeof(_d_clusterizerseparatedbycorr));
            _i_ser_kmeansgenerate = (_d_kmeansgenerate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_kmeansgenerate"), typeof(_d_kmeansgenerate));
        _i_x_obj_copy_decisionforest = (_d_x_obj_copy_decisionforest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_decisionforest"), typeof(_d_x_obj_copy_decisionforest));
        _i_x_obj_free_decisionforest = (_d_x_obj_free_decisionforest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_decisionforest"), typeof(_d_x_obj_free_decisionforest));
            _i_x_dfserialize   =   (_d_x_dfserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfserialize"),   typeof(_d_x_dfserialize));
            _i_x_dfunserialize = (_d_x_dfunserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfunserialize"), typeof(_d_x_dfunserialize));
            _i_ser_dfbuildrandomdecisionforest = (_d_dfbuildrandomdecisionforest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfbuildrandomdecisionforest"), typeof(_d_dfbuildrandomdecisionforest));
            _i_ser_dfbuildrandomdecisionforestx1 = (_d_dfbuildrandomdecisionforestx1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfbuildrandomdecisionforestx1"), typeof(_d_dfbuildrandomdecisionforestx1));
            _i_ser_dfprocess = (_d_dfprocess)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfprocess"), typeof(_d_dfprocess));
            _i_ser_dfprocessi = (_d_dfprocessi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfprocessi"), typeof(_d_dfprocessi));
            _i_ser_dfrelclserror = (_d_dfrelclserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfrelclserror"), typeof(_d_dfrelclserror));
            _i_ser_dfavgce = (_d_dfavgce)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfavgce"), typeof(_d_dfavgce));
            _i_ser_dfrmserror = (_d_dfrmserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfrmserror"), typeof(_d_dfrmserror));
            _i_ser_dfavgerror = (_d_dfavgerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfavgerror"), typeof(_d_dfavgerror));
            _i_ser_dfavgrelerror = (_d_dfavgrelerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dfavgrelerror"), typeof(_d_dfavgrelerror));
            _i_ser_gammafunction = (_d_gammafunction)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gammafunction"), typeof(_d_gammafunction));
            _i_ser_lngamma = (_d_lngamma)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lngamma"), typeof(_d_lngamma));
            _i_ser_errorfunction = (_d_errorfunction)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_errorfunction"), typeof(_d_errorfunction));
            _i_ser_errorfunctionc = (_d_errorfunctionc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_errorfunctionc"), typeof(_d_errorfunctionc));
            _i_ser_normaldistribution = (_d_normaldistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_normaldistribution"), typeof(_d_normaldistribution));
            _i_ser_inverf = (_d_inverf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_inverf"), typeof(_d_inverf));
            _i_ser_invnormaldistribution = (_d_invnormaldistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_invnormaldistribution"), typeof(_d_invnormaldistribution));
            _i_ser_incompletegamma = (_d_incompletegamma)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_incompletegamma"), typeof(_d_incompletegamma));
            _i_ser_incompletegammac = (_d_incompletegammac)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_incompletegammac"), typeof(_d_incompletegammac));
            _i_ser_invincompletegammac = (_d_invincompletegammac)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_invincompletegammac"), typeof(_d_invincompletegammac));
            _i_ser_rmatrixqr = (_d_rmatrixqr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixqr"), typeof(_d_rmatrixqr));
            _i_smp_rmatrixqr = (_d_rmatrixqr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixqr"), typeof(_d_rmatrixqr));
            _i_ser_rmatrixlq = (_d_rmatrixlq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlq"), typeof(_d_rmatrixlq));
            _i_smp_rmatrixlq = (_d_rmatrixlq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixlq"), typeof(_d_rmatrixlq));
            _i_ser_cmatrixqr = (_d_cmatrixqr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixqr"), typeof(_d_cmatrixqr));
            _i_smp_cmatrixqr = (_d_cmatrixqr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixqr"), typeof(_d_cmatrixqr));
            _i_ser_cmatrixlq = (_d_cmatrixlq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlq"), typeof(_d_cmatrixlq));
            _i_smp_cmatrixlq = (_d_cmatrixlq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixlq"), typeof(_d_cmatrixlq));
            _i_ser_rmatrixqrunpackq = (_d_rmatrixqrunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixqrunpackq"), typeof(_d_rmatrixqrunpackq));
            _i_smp_rmatrixqrunpackq = (_d_rmatrixqrunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixqrunpackq"), typeof(_d_rmatrixqrunpackq));
            _i_ser_rmatrixqrunpackr = (_d_rmatrixqrunpackr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixqrunpackr"), typeof(_d_rmatrixqrunpackr));
            _i_ser_rmatrixlqunpackq = (_d_rmatrixlqunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlqunpackq"), typeof(_d_rmatrixlqunpackq));
            _i_smp_rmatrixlqunpackq = (_d_rmatrixlqunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixlqunpackq"), typeof(_d_rmatrixlqunpackq));
            _i_ser_rmatrixlqunpackl = (_d_rmatrixlqunpackl)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlqunpackl"), typeof(_d_rmatrixlqunpackl));
            _i_ser_cmatrixqrunpackq = (_d_cmatrixqrunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixqrunpackq"), typeof(_d_cmatrixqrunpackq));
            _i_smp_cmatrixqrunpackq = (_d_cmatrixqrunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixqrunpackq"), typeof(_d_cmatrixqrunpackq));
            _i_ser_cmatrixqrunpackr = (_d_cmatrixqrunpackr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixqrunpackr"), typeof(_d_cmatrixqrunpackr));
            _i_ser_cmatrixlqunpackq = (_d_cmatrixlqunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlqunpackq"), typeof(_d_cmatrixlqunpackq));
            _i_smp_cmatrixlqunpackq = (_d_cmatrixlqunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixlqunpackq"), typeof(_d_cmatrixlqunpackq));
            _i_ser_cmatrixlqunpackl = (_d_cmatrixlqunpackl)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlqunpackl"), typeof(_d_cmatrixlqunpackl));
            _i_ser_rmatrixbd = (_d_rmatrixbd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixbd"), typeof(_d_rmatrixbd));
            _i_ser_rmatrixbdunpackq = (_d_rmatrixbdunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixbdunpackq"), typeof(_d_rmatrixbdunpackq));
            _i_ser_rmatrixbdmultiplybyq = (_d_rmatrixbdmultiplybyq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixbdmultiplybyq"), typeof(_d_rmatrixbdmultiplybyq));
            _i_ser_rmatrixbdunpackpt = (_d_rmatrixbdunpackpt)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixbdunpackpt"), typeof(_d_rmatrixbdunpackpt));
            _i_ser_rmatrixbdmultiplybyp = (_d_rmatrixbdmultiplybyp)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixbdmultiplybyp"), typeof(_d_rmatrixbdmultiplybyp));
            _i_ser_rmatrixbdunpackdiagonals = (_d_rmatrixbdunpackdiagonals)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixbdunpackdiagonals"), typeof(_d_rmatrixbdunpackdiagonals));
            _i_ser_rmatrixhessenberg = (_d_rmatrixhessenberg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixhessenberg"), typeof(_d_rmatrixhessenberg));
            _i_ser_rmatrixhessenbergunpackq = (_d_rmatrixhessenbergunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixhessenbergunpackq"), typeof(_d_rmatrixhessenbergunpackq));
            _i_ser_rmatrixhessenbergunpackh = (_d_rmatrixhessenbergunpackh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixhessenbergunpackh"), typeof(_d_rmatrixhessenbergunpackh));
            _i_ser_smatrixtd = (_d_smatrixtd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixtd"), typeof(_d_smatrixtd));
            _i_ser_smatrixtdunpackq = (_d_smatrixtdunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixtdunpackq"), typeof(_d_smatrixtdunpackq));
            _i_ser_hmatrixtd = (_d_hmatrixtd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hmatrixtd"), typeof(_d_hmatrixtd));
            _i_ser_hmatrixtdunpackq = (_d_hmatrixtdunpackq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hmatrixtdunpackq"), typeof(_d_hmatrixtdunpackq));
            _i_ser_rmatrixbdsvd = (_d_rmatrixbdsvd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixbdsvd"), typeof(_d_rmatrixbdsvd));
            _i_ser_rmatrixsvd = (_d_rmatrixsvd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixsvd"), typeof(_d_rmatrixsvd));
            _i_smp_rmatrixsvd = (_d_rmatrixsvd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixsvd"), typeof(_d_rmatrixsvd));
        _i_x_obj_copy_linearmodel = (_d_x_obj_copy_linearmodel)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_linearmodel"), typeof(_d_x_obj_copy_linearmodel));
        _i_x_obj_free_linearmodel = (_d_x_obj_free_linearmodel)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_linearmodel"), typeof(_d_x_obj_free_linearmodel));
            _i_ser_lrbuild = (_d_lrbuild)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lrbuild"), typeof(_d_lrbuild));
            _i_ser_lrbuilds = (_d_lrbuilds)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lrbuilds"), typeof(_d_lrbuilds));
            _i_ser_lrbuildzs = (_d_lrbuildzs)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lrbuildzs"), typeof(_d_lrbuildzs));
            _i_ser_lrbuildz = (_d_lrbuildz)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lrbuildz"), typeof(_d_lrbuildz));
            _i_ser_lrunpack = (_d_lrunpack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lrunpack"), typeof(_d_lrunpack));
            _i_ser_lrpack = (_d_lrpack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lrpack"), typeof(_d_lrpack));
            _i_ser_lrprocess = (_d_lrprocess)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lrprocess"), typeof(_d_lrprocess));
            _i_ser_lrrmserror = (_d_lrrmserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lrrmserror"), typeof(_d_lrrmserror));
            _i_ser_lravgerror = (_d_lravgerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lravgerror"), typeof(_d_lravgerror));
            _i_ser_lravgrelerror = (_d_lravgrelerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lravgrelerror"), typeof(_d_lravgrelerror));
            _i_ser_filtersma = (_d_filtersma)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_filtersma"), typeof(_d_filtersma));
            _i_ser_filterema = (_d_filterema)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_filterema"), typeof(_d_filterema));
            _i_ser_filterlrma = (_d_filterlrma)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_filterlrma"), typeof(_d_filterlrma));
            _i_ser_smatrixevd = (_d_smatrixevd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixevd"), typeof(_d_smatrixevd));
            _i_ser_smatrixevdr = (_d_smatrixevdr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixevdr"), typeof(_d_smatrixevdr));
            _i_ser_smatrixevdi = (_d_smatrixevdi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixevdi"), typeof(_d_smatrixevdi));
            _i_ser_hmatrixevd = (_d_hmatrixevd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hmatrixevd"), typeof(_d_hmatrixevd));
            _i_ser_hmatrixevdr = (_d_hmatrixevdr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hmatrixevdr"), typeof(_d_hmatrixevdr));
            _i_ser_hmatrixevdi = (_d_hmatrixevdi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hmatrixevdi"), typeof(_d_hmatrixevdi));
            _i_ser_smatrixtdevd = (_d_smatrixtdevd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixtdevd"), typeof(_d_smatrixtdevd));
            _i_ser_smatrixtdevdr = (_d_smatrixtdevdr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixtdevdr"), typeof(_d_smatrixtdevdr));
            _i_ser_smatrixtdevdi = (_d_smatrixtdevdi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixtdevdi"), typeof(_d_smatrixtdevdi));
            _i_ser_rmatrixevd = (_d_rmatrixevd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixevd"), typeof(_d_rmatrixevd));
            _i_ser_rmatrixrndorthogonal = (_d_rmatrixrndorthogonal)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixrndorthogonal"), typeof(_d_rmatrixrndorthogonal));
            _i_ser_rmatrixrndcond = (_d_rmatrixrndcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixrndcond"), typeof(_d_rmatrixrndcond));
            _i_ser_cmatrixrndorthogonal = (_d_cmatrixrndorthogonal)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixrndorthogonal"), typeof(_d_cmatrixrndorthogonal));
            _i_ser_cmatrixrndcond = (_d_cmatrixrndcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixrndcond"), typeof(_d_cmatrixrndcond));
            _i_ser_smatrixrndcond = (_d_smatrixrndcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixrndcond"), typeof(_d_smatrixrndcond));
            _i_ser_spdmatrixrndcond = (_d_spdmatrixrndcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixrndcond"), typeof(_d_spdmatrixrndcond));
            _i_ser_hmatrixrndcond = (_d_hmatrixrndcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hmatrixrndcond"), typeof(_d_hmatrixrndcond));
            _i_ser_hpdmatrixrndcond = (_d_hpdmatrixrndcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixrndcond"), typeof(_d_hpdmatrixrndcond));
            _i_ser_rmatrixrndorthogonalfromtheright = (_d_rmatrixrndorthogonalfromtheright)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixrndorthogonalfromtheright"), typeof(_d_rmatrixrndorthogonalfromtheright));
            _i_ser_rmatrixrndorthogonalfromtheleft = (_d_rmatrixrndorthogonalfromtheleft)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixrndorthogonalfromtheleft"), typeof(_d_rmatrixrndorthogonalfromtheleft));
            _i_ser_cmatrixrndorthogonalfromtheright = (_d_cmatrixrndorthogonalfromtheright)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixrndorthogonalfromtheright"), typeof(_d_cmatrixrndorthogonalfromtheright));
            _i_ser_cmatrixrndorthogonalfromtheleft = (_d_cmatrixrndorthogonalfromtheleft)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixrndorthogonalfromtheleft"), typeof(_d_cmatrixrndorthogonalfromtheleft));
            _i_ser_smatrixrndmultiply = (_d_smatrixrndmultiply)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixrndmultiply"), typeof(_d_smatrixrndmultiply));
            _i_ser_hmatrixrndmultiply = (_d_hmatrixrndmultiply)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hmatrixrndmultiply"), typeof(_d_hmatrixrndmultiply));
        _i_x_obj_copy_sparsematrix = (_d_x_obj_copy_sparsematrix)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_sparsematrix"), typeof(_d_x_obj_copy_sparsematrix));
        _i_x_obj_free_sparsematrix = (_d_x_obj_free_sparsematrix)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_sparsematrix"), typeof(_d_x_obj_free_sparsematrix));
        _i_x_obj_copy_sparsebuffers = (_d_x_obj_copy_sparsebuffers)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_sparsebuffers"), typeof(_d_x_obj_copy_sparsebuffers));
        _i_x_obj_free_sparsebuffers = (_d_x_obj_free_sparsebuffers)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_sparsebuffers"), typeof(_d_x_obj_free_sparsebuffers));
            _i_ser_sparsecreate = (_d_sparsecreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecreate"), typeof(_d_sparsecreate));
            _i_ser_sparsecreatebuf = (_d_sparsecreatebuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecreatebuf"), typeof(_d_sparsecreatebuf));
            _i_ser_sparsecreatecrs = (_d_sparsecreatecrs)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecreatecrs"), typeof(_d_sparsecreatecrs));
            _i_ser_sparsecreatecrsbuf = (_d_sparsecreatecrsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecreatecrsbuf"), typeof(_d_sparsecreatecrsbuf));
            _i_ser_sparsecreatesks = (_d_sparsecreatesks)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecreatesks"), typeof(_d_sparsecreatesks));
            _i_ser_sparsecreatesksbuf = (_d_sparsecreatesksbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecreatesksbuf"), typeof(_d_sparsecreatesksbuf));
            _i_ser_sparsecopy = (_d_sparsecopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopy"), typeof(_d_sparsecopy));
            _i_ser_sparsecopybuf = (_d_sparsecopybuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopybuf"), typeof(_d_sparsecopybuf));
            _i_ser_sparseswap = (_d_sparseswap)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseswap"), typeof(_d_sparseswap));
            _i_ser_sparseadd = (_d_sparseadd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseadd"), typeof(_d_sparseadd));
            _i_ser_sparseset = (_d_sparseset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseset"), typeof(_d_sparseset));
            _i_ser_sparseget = (_d_sparseget)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseget"), typeof(_d_sparseget));
            _i_ser_sparsegetdiagonal = (_d_sparsegetdiagonal)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsegetdiagonal"), typeof(_d_sparsegetdiagonal));
            _i_ser_sparsemv = (_d_sparsemv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsemv"), typeof(_d_sparsemv));
            _i_ser_sparsemtv = (_d_sparsemtv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsemtv"), typeof(_d_sparsemtv));
            _i_ser_sparsemv2 = (_d_sparsemv2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsemv2"), typeof(_d_sparsemv2));
            _i_ser_sparsesmv = (_d_sparsesmv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsesmv"), typeof(_d_sparsesmv));
            _i_ser_sparsevsmv = (_d_sparsevsmv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsevsmv"), typeof(_d_sparsevsmv));
            _i_ser_sparsemm = (_d_sparsemm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsemm"), typeof(_d_sparsemm));
            _i_ser_sparsemtm = (_d_sparsemtm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsemtm"), typeof(_d_sparsemtm));
            _i_ser_sparsemm2 = (_d_sparsemm2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsemm2"), typeof(_d_sparsemm2));
            _i_ser_sparsesmm = (_d_sparsesmm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsesmm"), typeof(_d_sparsesmm));
            _i_ser_sparsetrmv = (_d_sparsetrmv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsetrmv"), typeof(_d_sparsetrmv));
            _i_ser_sparsetrsv = (_d_sparsetrsv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsetrsv"), typeof(_d_sparsetrsv));
            _i_ser_sparseresizematrix = (_d_sparseresizematrix)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseresizematrix"), typeof(_d_sparseresizematrix));
            _i_ser_sparseenumerate = (_d_sparseenumerate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseenumerate"), typeof(_d_sparseenumerate));
            _i_ser_sparserewriteexisting = (_d_sparserewriteexisting)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparserewriteexisting"), typeof(_d_sparserewriteexisting));
            _i_ser_sparsegetrow = (_d_sparsegetrow)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsegetrow"), typeof(_d_sparsegetrow));
            _i_ser_sparsegetcompressedrow = (_d_sparsegetcompressedrow)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsegetcompressedrow"), typeof(_d_sparsegetcompressedrow));
            _i_ser_sparsetransposesks = (_d_sparsetransposesks)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsetransposesks"), typeof(_d_sparsetransposesks));
            _i_ser_sparseconvertto = (_d_sparseconvertto)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseconvertto"), typeof(_d_sparseconvertto));
            _i_ser_sparsecopytobuf = (_d_sparsecopytobuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopytobuf"), typeof(_d_sparsecopytobuf));
            _i_ser_sparseconverttohash = (_d_sparseconverttohash)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseconverttohash"), typeof(_d_sparseconverttohash));
            _i_ser_sparsecopytohash = (_d_sparsecopytohash)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopytohash"), typeof(_d_sparsecopytohash));
            _i_ser_sparsecopytohashbuf = (_d_sparsecopytohashbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopytohashbuf"), typeof(_d_sparsecopytohashbuf));
            _i_ser_sparseconverttocrs = (_d_sparseconverttocrs)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseconverttocrs"), typeof(_d_sparseconverttocrs));
            _i_ser_sparsecopytocrs = (_d_sparsecopytocrs)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopytocrs"), typeof(_d_sparsecopytocrs));
            _i_ser_sparsecopytocrsbuf = (_d_sparsecopytocrsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopytocrsbuf"), typeof(_d_sparsecopytocrsbuf));
            _i_ser_sparseconverttosks = (_d_sparseconverttosks)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseconverttosks"), typeof(_d_sparseconverttosks));
            _i_ser_sparsecopytosks = (_d_sparsecopytosks)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopytosks"), typeof(_d_sparsecopytosks));
            _i_ser_sparsecopytosksbuf = (_d_sparsecopytosksbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecopytosksbuf"), typeof(_d_sparsecopytosksbuf));
            _i_ser_sparsegetmatrixtype = (_d_sparsegetmatrixtype)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsegetmatrixtype"), typeof(_d_sparsegetmatrixtype));
            _i_ser_sparseishash = (_d_sparseishash)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseishash"), typeof(_d_sparseishash));
            _i_ser_sparseiscrs = (_d_sparseiscrs)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseiscrs"), typeof(_d_sparseiscrs));
            _i_ser_sparseissks = (_d_sparseissks)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparseissks"), typeof(_d_sparseissks));
            _i_ser_sparsefree = (_d_sparsefree)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsefree"), typeof(_d_sparsefree));
            _i_ser_sparsegetnrows = (_d_sparsegetnrows)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsegetnrows"), typeof(_d_sparsegetnrows));
            _i_ser_sparsegetncols = (_d_sparsegetncols)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsegetncols"), typeof(_d_sparsegetncols));
            _i_ser_sparsegetuppercount = (_d_sparsegetuppercount)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsegetuppercount"), typeof(_d_sparsegetuppercount));
            _i_ser_sparsegetlowercount = (_d_sparsegetlowercount)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsegetlowercount"), typeof(_d_sparsegetlowercount));
            _i_ser_rmatrixlu = (_d_rmatrixlu)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlu"), typeof(_d_rmatrixlu));
            _i_smp_rmatrixlu = (_d_rmatrixlu)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixlu"), typeof(_d_rmatrixlu));
            _i_ser_cmatrixlu = (_d_cmatrixlu)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlu"), typeof(_d_cmatrixlu));
            _i_smp_cmatrixlu = (_d_cmatrixlu)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixlu"), typeof(_d_cmatrixlu));
            _i_ser_hpdmatrixcholesky = (_d_hpdmatrixcholesky)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixcholesky"), typeof(_d_hpdmatrixcholesky));
            _i_smp_hpdmatrixcholesky = (_d_hpdmatrixcholesky)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixcholesky"), typeof(_d_hpdmatrixcholesky));
            _i_ser_spdmatrixcholesky = (_d_spdmatrixcholesky)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholesky"), typeof(_d_spdmatrixcholesky));
            _i_smp_spdmatrixcholesky = (_d_spdmatrixcholesky)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixcholesky"), typeof(_d_spdmatrixcholesky));
            _i_ser_spdmatrixcholeskyupdateadd1 = (_d_spdmatrixcholeskyupdateadd1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskyupdateadd1"), typeof(_d_spdmatrixcholeskyupdateadd1));
            _i_ser_spdmatrixcholeskyupdatefix = (_d_spdmatrixcholeskyupdatefix)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskyupdatefix"), typeof(_d_spdmatrixcholeskyupdatefix));
            _i_ser_spdmatrixcholeskyupdateadd1buf = (_d_spdmatrixcholeskyupdateadd1buf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskyupdateadd1buf"), typeof(_d_spdmatrixcholeskyupdateadd1buf));
            _i_ser_spdmatrixcholeskyupdatefixbuf = (_d_spdmatrixcholeskyupdatefixbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskyupdatefixbuf"), typeof(_d_spdmatrixcholeskyupdatefixbuf));
            _i_ser_sparsecholeskyskyline = (_d_sparsecholeskyskyline)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sparsecholeskyskyline"), typeof(_d_sparsecholeskyskyline));
            _i_ser_rmatrixrcond1 = (_d_rmatrixrcond1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixrcond1"), typeof(_d_rmatrixrcond1));
            _i_ser_rmatrixrcondinf = (_d_rmatrixrcondinf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixrcondinf"), typeof(_d_rmatrixrcondinf));
            _i_ser_spdmatrixrcond = (_d_spdmatrixrcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixrcond"), typeof(_d_spdmatrixrcond));
            _i_ser_rmatrixtrrcond1 = (_d_rmatrixtrrcond1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixtrrcond1"), typeof(_d_rmatrixtrrcond1));
            _i_ser_rmatrixtrrcondinf = (_d_rmatrixtrrcondinf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixtrrcondinf"), typeof(_d_rmatrixtrrcondinf));
            _i_ser_hpdmatrixrcond = (_d_hpdmatrixrcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixrcond"), typeof(_d_hpdmatrixrcond));
            _i_ser_cmatrixrcond1 = (_d_cmatrixrcond1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixrcond1"), typeof(_d_cmatrixrcond1));
            _i_ser_cmatrixrcondinf = (_d_cmatrixrcondinf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixrcondinf"), typeof(_d_cmatrixrcondinf));
            _i_ser_rmatrixlurcond1 = (_d_rmatrixlurcond1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlurcond1"), typeof(_d_rmatrixlurcond1));
            _i_ser_rmatrixlurcondinf = (_d_rmatrixlurcondinf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlurcondinf"), typeof(_d_rmatrixlurcondinf));
            _i_ser_spdmatrixcholeskyrcond = (_d_spdmatrixcholeskyrcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskyrcond"), typeof(_d_spdmatrixcholeskyrcond));
            _i_ser_hpdmatrixcholeskyrcond = (_d_hpdmatrixcholeskyrcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixcholeskyrcond"), typeof(_d_hpdmatrixcholeskyrcond));
            _i_ser_cmatrixlurcond1 = (_d_cmatrixlurcond1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlurcond1"), typeof(_d_cmatrixlurcond1));
            _i_ser_cmatrixlurcondinf = (_d_cmatrixlurcondinf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlurcondinf"), typeof(_d_cmatrixlurcondinf));
            _i_ser_cmatrixtrrcond1 = (_d_cmatrixtrrcond1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixtrrcond1"), typeof(_d_cmatrixtrrcond1));
            _i_ser_cmatrixtrrcondinf = (_d_cmatrixtrrcondinf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixtrrcondinf"), typeof(_d_cmatrixtrrcondinf));
            _i_ser_rmatrixluinverse = (_d_rmatrixluinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixluinverse"), typeof(_d_rmatrixluinverse));
            _i_smp_rmatrixluinverse = (_d_rmatrixluinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixluinverse"), typeof(_d_rmatrixluinverse));
            _i_ser_rmatrixinverse = (_d_rmatrixinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixinverse"), typeof(_d_rmatrixinverse));
            _i_smp_rmatrixinverse = (_d_rmatrixinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixinverse"), typeof(_d_rmatrixinverse));
            _i_ser_cmatrixluinverse = (_d_cmatrixluinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixluinverse"), typeof(_d_cmatrixluinverse));
            _i_smp_cmatrixluinverse = (_d_cmatrixluinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixluinverse"), typeof(_d_cmatrixluinverse));
            _i_ser_cmatrixinverse = (_d_cmatrixinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixinverse"), typeof(_d_cmatrixinverse));
            _i_smp_cmatrixinverse = (_d_cmatrixinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixinverse"), typeof(_d_cmatrixinverse));
            _i_ser_spdmatrixcholeskyinverse = (_d_spdmatrixcholeskyinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskyinverse"), typeof(_d_spdmatrixcholeskyinverse));
            _i_smp_spdmatrixcholeskyinverse = (_d_spdmatrixcholeskyinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixcholeskyinverse"), typeof(_d_spdmatrixcholeskyinverse));
            _i_ser_spdmatrixinverse = (_d_spdmatrixinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixinverse"), typeof(_d_spdmatrixinverse));
            _i_smp_spdmatrixinverse = (_d_spdmatrixinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixinverse"), typeof(_d_spdmatrixinverse));
            _i_ser_hpdmatrixcholeskyinverse = (_d_hpdmatrixcholeskyinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixcholeskyinverse"), typeof(_d_hpdmatrixcholeskyinverse));
            _i_smp_hpdmatrixcholeskyinverse = (_d_hpdmatrixcholeskyinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixcholeskyinverse"), typeof(_d_hpdmatrixcholeskyinverse));
            _i_ser_hpdmatrixinverse = (_d_hpdmatrixinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixinverse"), typeof(_d_hpdmatrixinverse));
            _i_smp_hpdmatrixinverse = (_d_hpdmatrixinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixinverse"), typeof(_d_hpdmatrixinverse));
            _i_ser_rmatrixtrinverse = (_d_rmatrixtrinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixtrinverse"), typeof(_d_rmatrixtrinverse));
            _i_smp_rmatrixtrinverse = (_d_rmatrixtrinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixtrinverse"), typeof(_d_rmatrixtrinverse));
            _i_ser_cmatrixtrinverse = (_d_cmatrixtrinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixtrinverse"), typeof(_d_cmatrixtrinverse));
            _i_smp_cmatrixtrinverse = (_d_cmatrixtrinverse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixtrinverse"), typeof(_d_cmatrixtrinverse));
            _i_ser_fisherlda = (_d_fisherlda)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fisherlda"), typeof(_d_fisherlda));
            _i_ser_fisherldan = (_d_fisherldan)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fisherldan"), typeof(_d_fisherldan));
            _i_smp_fisherldan = (_d_fisherldan)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_fisherldan"), typeof(_d_fisherldan));
        _i_x_obj_copy_multilayerperceptron = (_d_x_obj_copy_multilayerperceptron)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_multilayerperceptron"), typeof(_d_x_obj_copy_multilayerperceptron));
        _i_x_obj_free_multilayerperceptron = (_d_x_obj_free_multilayerperceptron)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_multilayerperceptron"), typeof(_d_x_obj_free_multilayerperceptron));
            _i_x_mlpserialize   =   (_d_x_mlpserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpserialize"),   typeof(_d_x_mlpserialize));
            _i_x_mlpunserialize = (_d_x_mlpunserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpunserialize"), typeof(_d_x_mlpunserialize));
            _i_ser_mlpcreate0 = (_d_mlpcreate0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreate0"), typeof(_d_mlpcreate0));
            _i_ser_mlpcreate1 = (_d_mlpcreate1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreate1"), typeof(_d_mlpcreate1));
            _i_ser_mlpcreate2 = (_d_mlpcreate2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreate2"), typeof(_d_mlpcreate2));
            _i_ser_mlpcreateb0 = (_d_mlpcreateb0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreateb0"), typeof(_d_mlpcreateb0));
            _i_ser_mlpcreateb1 = (_d_mlpcreateb1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreateb1"), typeof(_d_mlpcreateb1));
            _i_ser_mlpcreateb2 = (_d_mlpcreateb2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreateb2"), typeof(_d_mlpcreateb2));
            _i_ser_mlpcreater0 = (_d_mlpcreater0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreater0"), typeof(_d_mlpcreater0));
            _i_ser_mlpcreater1 = (_d_mlpcreater1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreater1"), typeof(_d_mlpcreater1));
            _i_ser_mlpcreater2 = (_d_mlpcreater2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreater2"), typeof(_d_mlpcreater2));
            _i_ser_mlpcreatec0 = (_d_mlpcreatec0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreatec0"), typeof(_d_mlpcreatec0));
            _i_ser_mlpcreatec1 = (_d_mlpcreatec1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreatec1"), typeof(_d_mlpcreatec1));
            _i_ser_mlpcreatec2 = (_d_mlpcreatec2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreatec2"), typeof(_d_mlpcreatec2));
            _i_ser_mlpcopy = (_d_mlpcopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcopy"), typeof(_d_mlpcopy));
            _i_ser_mlpcopytunableparameters = (_d_mlpcopytunableparameters)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcopytunableparameters"), typeof(_d_mlpcopytunableparameters));
            _i_ser_mlprandomize = (_d_mlprandomize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlprandomize"), typeof(_d_mlprandomize));
            _i_ser_mlprandomizefull = (_d_mlprandomizefull)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlprandomizefull"), typeof(_d_mlprandomizefull));
            _i_ser_mlpinitpreprocessor = (_d_mlpinitpreprocessor)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpinitpreprocessor"), typeof(_d_mlpinitpreprocessor));
            _i_ser_mlpproperties = (_d_mlpproperties)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpproperties"), typeof(_d_mlpproperties));
            _i_ser_mlpgetinputscount = (_d_mlpgetinputscount)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetinputscount"), typeof(_d_mlpgetinputscount));
            _i_ser_mlpgetoutputscount = (_d_mlpgetoutputscount)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetoutputscount"), typeof(_d_mlpgetoutputscount));
            _i_ser_mlpgetweightscount = (_d_mlpgetweightscount)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetweightscount"), typeof(_d_mlpgetweightscount));
            _i_ser_mlpissoftmax = (_d_mlpissoftmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpissoftmax"), typeof(_d_mlpissoftmax));
            _i_ser_mlpgetlayerscount = (_d_mlpgetlayerscount)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetlayerscount"), typeof(_d_mlpgetlayerscount));
            _i_ser_mlpgetlayersize = (_d_mlpgetlayersize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetlayersize"), typeof(_d_mlpgetlayersize));
            _i_ser_mlpgetinputscaling = (_d_mlpgetinputscaling)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetinputscaling"), typeof(_d_mlpgetinputscaling));
            _i_ser_mlpgetoutputscaling = (_d_mlpgetoutputscaling)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetoutputscaling"), typeof(_d_mlpgetoutputscaling));
            _i_ser_mlpgetneuroninfo = (_d_mlpgetneuroninfo)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetneuroninfo"), typeof(_d_mlpgetneuroninfo));
            _i_ser_mlpgetweight = (_d_mlpgetweight)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgetweight"), typeof(_d_mlpgetweight));
            _i_ser_mlpsetinputscaling = (_d_mlpsetinputscaling)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetinputscaling"), typeof(_d_mlpsetinputscaling));
            _i_ser_mlpsetoutputscaling = (_d_mlpsetoutputscaling)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetoutputscaling"), typeof(_d_mlpsetoutputscaling));
            _i_ser_mlpsetneuroninfo = (_d_mlpsetneuroninfo)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetneuroninfo"), typeof(_d_mlpsetneuroninfo));
            _i_ser_mlpsetweight = (_d_mlpsetweight)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetweight"), typeof(_d_mlpsetweight));
            _i_ser_mlpactivationfunction = (_d_mlpactivationfunction)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpactivationfunction"), typeof(_d_mlpactivationfunction));
            _i_ser_mlpprocess = (_d_mlpprocess)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpprocess"), typeof(_d_mlpprocess));
            _i_ser_mlpprocessi = (_d_mlpprocessi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpprocessi"), typeof(_d_mlpprocessi));
            _i_ser_mlperror = (_d_mlperror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlperror"), typeof(_d_mlperror));
            _i_smp_mlperror = (_d_mlperror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlperror"), typeof(_d_mlperror));
            _i_ser_mlperrorsparse = (_d_mlperrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlperrorsparse"), typeof(_d_mlperrorsparse));
            _i_smp_mlperrorsparse = (_d_mlperrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlperrorsparse"), typeof(_d_mlperrorsparse));
            _i_ser_mlperrorn = (_d_mlperrorn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlperrorn"), typeof(_d_mlperrorn));
            _i_ser_mlpclserror = (_d_mlpclserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpclserror"), typeof(_d_mlpclserror));
            _i_smp_mlpclserror = (_d_mlpclserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpclserror"), typeof(_d_mlpclserror));
            _i_ser_mlprelclserror = (_d_mlprelclserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlprelclserror"), typeof(_d_mlprelclserror));
            _i_smp_mlprelclserror = (_d_mlprelclserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlprelclserror"), typeof(_d_mlprelclserror));
            _i_ser_mlprelclserrorsparse = (_d_mlprelclserrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlprelclserrorsparse"), typeof(_d_mlprelclserrorsparse));
            _i_smp_mlprelclserrorsparse = (_d_mlprelclserrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlprelclserrorsparse"), typeof(_d_mlprelclserrorsparse));
            _i_ser_mlpavgce = (_d_mlpavgce)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpavgce"), typeof(_d_mlpavgce));
            _i_smp_mlpavgce = (_d_mlpavgce)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpavgce"), typeof(_d_mlpavgce));
            _i_ser_mlpavgcesparse = (_d_mlpavgcesparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpavgcesparse"), typeof(_d_mlpavgcesparse));
            _i_smp_mlpavgcesparse = (_d_mlpavgcesparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpavgcesparse"), typeof(_d_mlpavgcesparse));
            _i_ser_mlprmserror = (_d_mlprmserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlprmserror"), typeof(_d_mlprmserror));
            _i_smp_mlprmserror = (_d_mlprmserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlprmserror"), typeof(_d_mlprmserror));
            _i_ser_mlprmserrorsparse = (_d_mlprmserrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlprmserrorsparse"), typeof(_d_mlprmserrorsparse));
            _i_smp_mlprmserrorsparse = (_d_mlprmserrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlprmserrorsparse"), typeof(_d_mlprmserrorsparse));
            _i_ser_mlpavgerror = (_d_mlpavgerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpavgerror"), typeof(_d_mlpavgerror));
            _i_smp_mlpavgerror = (_d_mlpavgerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpavgerror"), typeof(_d_mlpavgerror));
            _i_ser_mlpavgerrorsparse = (_d_mlpavgerrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpavgerrorsparse"), typeof(_d_mlpavgerrorsparse));
            _i_smp_mlpavgerrorsparse = (_d_mlpavgerrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpavgerrorsparse"), typeof(_d_mlpavgerrorsparse));
            _i_ser_mlpavgrelerror = (_d_mlpavgrelerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpavgrelerror"), typeof(_d_mlpavgrelerror));
            _i_smp_mlpavgrelerror = (_d_mlpavgrelerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpavgrelerror"), typeof(_d_mlpavgrelerror));
            _i_ser_mlpavgrelerrorsparse = (_d_mlpavgrelerrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpavgrelerrorsparse"), typeof(_d_mlpavgrelerrorsparse));
            _i_smp_mlpavgrelerrorsparse = (_d_mlpavgrelerrorsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpavgrelerrorsparse"), typeof(_d_mlpavgrelerrorsparse));
            _i_ser_mlpgrad = (_d_mlpgrad)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgrad"), typeof(_d_mlpgrad));
            _i_ser_mlpgradn = (_d_mlpgradn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgradn"), typeof(_d_mlpgradn));
            _i_ser_mlpgradbatch = (_d_mlpgradbatch)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgradbatch"), typeof(_d_mlpgradbatch));
            _i_smp_mlpgradbatch = (_d_mlpgradbatch)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpgradbatch"), typeof(_d_mlpgradbatch));
            _i_ser_mlpgradbatchsparse = (_d_mlpgradbatchsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgradbatchsparse"), typeof(_d_mlpgradbatchsparse));
            _i_smp_mlpgradbatchsparse = (_d_mlpgradbatchsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpgradbatchsparse"), typeof(_d_mlpgradbatchsparse));
            _i_ser_mlpgradbatchsubset = (_d_mlpgradbatchsubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgradbatchsubset"), typeof(_d_mlpgradbatchsubset));
            _i_smp_mlpgradbatchsubset = (_d_mlpgradbatchsubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpgradbatchsubset"), typeof(_d_mlpgradbatchsubset));
            _i_ser_mlpgradbatchsparsesubset = (_d_mlpgradbatchsparsesubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgradbatchsparsesubset"), typeof(_d_mlpgradbatchsparsesubset));
            _i_smp_mlpgradbatchsparsesubset = (_d_mlpgradbatchsparsesubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpgradbatchsparsesubset"), typeof(_d_mlpgradbatchsparsesubset));
            _i_ser_mlpgradnbatch = (_d_mlpgradnbatch)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpgradnbatch"), typeof(_d_mlpgradnbatch));
            _i_ser_mlphessiannbatch = (_d_mlphessiannbatch)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlphessiannbatch"), typeof(_d_mlphessiannbatch));
            _i_ser_mlphessianbatch = (_d_mlphessianbatch)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlphessianbatch"), typeof(_d_mlphessianbatch));
            _i_ser_mlpallerrorssubset = (_d_mlpallerrorssubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpallerrorssubset"), typeof(_d_mlpallerrorssubset));
            _i_smp_mlpallerrorssubset = (_d_mlpallerrorssubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpallerrorssubset"), typeof(_d_mlpallerrorssubset));
            _i_ser_mlpallerrorssparsesubset = (_d_mlpallerrorssparsesubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpallerrorssparsesubset"), typeof(_d_mlpallerrorssparsesubset));
            _i_smp_mlpallerrorssparsesubset = (_d_mlpallerrorssparsesubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpallerrorssparsesubset"), typeof(_d_mlpallerrorssparsesubset));
            _i_ser_mlperrorsubset = (_d_mlperrorsubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlperrorsubset"), typeof(_d_mlperrorsubset));
            _i_smp_mlperrorsubset = (_d_mlperrorsubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlperrorsubset"), typeof(_d_mlperrorsubset));
            _i_ser_mlperrorsparsesubset = (_d_mlperrorsparsesubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlperrorsparsesubset"), typeof(_d_mlperrorsparsesubset));
            _i_smp_mlperrorsparsesubset = (_d_mlperrorsparsesubset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlperrorsparsesubset"), typeof(_d_mlperrorsparsesubset));
            _i_ser_rmatrixsolve = (_d_rmatrixsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixsolve"), typeof(_d_rmatrixsolve));
            _i_smp_rmatrixsolve = (_d_rmatrixsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixsolve"), typeof(_d_rmatrixsolve));
            _i_ser_rmatrixsolvefast = (_d_rmatrixsolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixsolvefast"), typeof(_d_rmatrixsolvefast));
            _i_smp_rmatrixsolvefast = (_d_rmatrixsolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixsolvefast"), typeof(_d_rmatrixsolvefast));
            _i_ser_rmatrixsolvem = (_d_rmatrixsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixsolvem"), typeof(_d_rmatrixsolvem));
            _i_smp_rmatrixsolvem = (_d_rmatrixsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixsolvem"), typeof(_d_rmatrixsolvem));
            _i_ser_rmatrixsolvemfast = (_d_rmatrixsolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixsolvemfast"), typeof(_d_rmatrixsolvemfast));
            _i_smp_rmatrixsolvemfast = (_d_rmatrixsolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixsolvemfast"), typeof(_d_rmatrixsolvemfast));
            _i_ser_rmatrixlusolve = (_d_rmatrixlusolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlusolve"), typeof(_d_rmatrixlusolve));
            _i_ser_rmatrixlusolvefast = (_d_rmatrixlusolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlusolvefast"), typeof(_d_rmatrixlusolvefast));
            _i_ser_rmatrixlusolvem = (_d_rmatrixlusolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlusolvem"), typeof(_d_rmatrixlusolvem));
            _i_smp_rmatrixlusolvem = (_d_rmatrixlusolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixlusolvem"), typeof(_d_rmatrixlusolvem));
            _i_ser_rmatrixlusolvemfast = (_d_rmatrixlusolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixlusolvemfast"), typeof(_d_rmatrixlusolvemfast));
            _i_smp_rmatrixlusolvemfast = (_d_rmatrixlusolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixlusolvemfast"), typeof(_d_rmatrixlusolvemfast));
            _i_ser_rmatrixmixedsolve = (_d_rmatrixmixedsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixmixedsolve"), typeof(_d_rmatrixmixedsolve));
            _i_ser_rmatrixmixedsolvem = (_d_rmatrixmixedsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixmixedsolvem"), typeof(_d_rmatrixmixedsolvem));
            _i_ser_cmatrixsolvem = (_d_cmatrixsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixsolvem"), typeof(_d_cmatrixsolvem));
            _i_smp_cmatrixsolvem = (_d_cmatrixsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixsolvem"), typeof(_d_cmatrixsolvem));
            _i_ser_cmatrixsolvemfast = (_d_cmatrixsolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixsolvemfast"), typeof(_d_cmatrixsolvemfast));
            _i_smp_cmatrixsolvemfast = (_d_cmatrixsolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixsolvemfast"), typeof(_d_cmatrixsolvemfast));
            _i_ser_cmatrixsolve = (_d_cmatrixsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixsolve"), typeof(_d_cmatrixsolve));
            _i_smp_cmatrixsolve = (_d_cmatrixsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixsolve"), typeof(_d_cmatrixsolve));
            _i_ser_cmatrixsolvefast = (_d_cmatrixsolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixsolvefast"), typeof(_d_cmatrixsolvefast));
            _i_smp_cmatrixsolvefast = (_d_cmatrixsolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixsolvefast"), typeof(_d_cmatrixsolvefast));
            _i_ser_cmatrixlusolvem = (_d_cmatrixlusolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlusolvem"), typeof(_d_cmatrixlusolvem));
            _i_smp_cmatrixlusolvem = (_d_cmatrixlusolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixlusolvem"), typeof(_d_cmatrixlusolvem));
            _i_ser_cmatrixlusolvemfast = (_d_cmatrixlusolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlusolvemfast"), typeof(_d_cmatrixlusolvemfast));
            _i_smp_cmatrixlusolvemfast = (_d_cmatrixlusolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_cmatrixlusolvemfast"), typeof(_d_cmatrixlusolvemfast));
            _i_ser_cmatrixlusolve = (_d_cmatrixlusolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlusolve"), typeof(_d_cmatrixlusolve));
            _i_ser_cmatrixlusolvefast = (_d_cmatrixlusolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixlusolvefast"), typeof(_d_cmatrixlusolvefast));
            _i_ser_cmatrixmixedsolvem = (_d_cmatrixmixedsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixmixedsolvem"), typeof(_d_cmatrixmixedsolvem));
            _i_ser_cmatrixmixedsolve = (_d_cmatrixmixedsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixmixedsolve"), typeof(_d_cmatrixmixedsolve));
            _i_ser_spdmatrixsolvem = (_d_spdmatrixsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixsolvem"), typeof(_d_spdmatrixsolvem));
            _i_smp_spdmatrixsolvem = (_d_spdmatrixsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixsolvem"), typeof(_d_spdmatrixsolvem));
            _i_ser_spdmatrixsolvemfast = (_d_spdmatrixsolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixsolvemfast"), typeof(_d_spdmatrixsolvemfast));
            _i_smp_spdmatrixsolvemfast = (_d_spdmatrixsolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixsolvemfast"), typeof(_d_spdmatrixsolvemfast));
            _i_ser_spdmatrixsolve = (_d_spdmatrixsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixsolve"), typeof(_d_spdmatrixsolve));
            _i_smp_spdmatrixsolve = (_d_spdmatrixsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixsolve"), typeof(_d_spdmatrixsolve));
            _i_ser_spdmatrixsolvefast = (_d_spdmatrixsolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixsolvefast"), typeof(_d_spdmatrixsolvefast));
            _i_smp_spdmatrixsolvefast = (_d_spdmatrixsolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixsolvefast"), typeof(_d_spdmatrixsolvefast));
            _i_ser_spdmatrixcholeskysolvem = (_d_spdmatrixcholeskysolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskysolvem"), typeof(_d_spdmatrixcholeskysolvem));
            _i_smp_spdmatrixcholeskysolvem = (_d_spdmatrixcholeskysolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixcholeskysolvem"), typeof(_d_spdmatrixcholeskysolvem));
            _i_ser_spdmatrixcholeskysolvemfast = (_d_spdmatrixcholeskysolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskysolvemfast"), typeof(_d_spdmatrixcholeskysolvemfast));
            _i_smp_spdmatrixcholeskysolvemfast = (_d_spdmatrixcholeskysolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spdmatrixcholeskysolvemfast"), typeof(_d_spdmatrixcholeskysolvemfast));
            _i_ser_spdmatrixcholeskysolve = (_d_spdmatrixcholeskysolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskysolve"), typeof(_d_spdmatrixcholeskysolve));
            _i_ser_spdmatrixcholeskysolvefast = (_d_spdmatrixcholeskysolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskysolvefast"), typeof(_d_spdmatrixcholeskysolvefast));
            _i_ser_hpdmatrixsolvem = (_d_hpdmatrixsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixsolvem"), typeof(_d_hpdmatrixsolvem));
            _i_smp_hpdmatrixsolvem = (_d_hpdmatrixsolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixsolvem"), typeof(_d_hpdmatrixsolvem));
            _i_ser_hpdmatrixsolvemfast = (_d_hpdmatrixsolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixsolvemfast"), typeof(_d_hpdmatrixsolvemfast));
            _i_smp_hpdmatrixsolvemfast = (_d_hpdmatrixsolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixsolvemfast"), typeof(_d_hpdmatrixsolvemfast));
            _i_ser_hpdmatrixsolve = (_d_hpdmatrixsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixsolve"), typeof(_d_hpdmatrixsolve));
            _i_smp_hpdmatrixsolve = (_d_hpdmatrixsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixsolve"), typeof(_d_hpdmatrixsolve));
            _i_ser_hpdmatrixsolvefast = (_d_hpdmatrixsolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixsolvefast"), typeof(_d_hpdmatrixsolvefast));
            _i_smp_hpdmatrixsolvefast = (_d_hpdmatrixsolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixsolvefast"), typeof(_d_hpdmatrixsolvefast));
            _i_ser_hpdmatrixcholeskysolvem = (_d_hpdmatrixcholeskysolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixcholeskysolvem"), typeof(_d_hpdmatrixcholeskysolvem));
            _i_smp_hpdmatrixcholeskysolvem = (_d_hpdmatrixcholeskysolvem)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixcholeskysolvem"), typeof(_d_hpdmatrixcholeskysolvem));
            _i_ser_hpdmatrixcholeskysolvemfast = (_d_hpdmatrixcholeskysolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixcholeskysolvemfast"), typeof(_d_hpdmatrixcholeskysolvemfast));
            _i_smp_hpdmatrixcholeskysolvemfast = (_d_hpdmatrixcholeskysolvemfast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_hpdmatrixcholeskysolvemfast"), typeof(_d_hpdmatrixcholeskysolvemfast));
            _i_ser_hpdmatrixcholeskysolve = (_d_hpdmatrixcholeskysolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixcholeskysolve"), typeof(_d_hpdmatrixcholeskysolve));
            _i_ser_hpdmatrixcholeskysolvefast = (_d_hpdmatrixcholeskysolvefast)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hpdmatrixcholeskysolvefast"), typeof(_d_hpdmatrixcholeskysolvefast));
            _i_ser_rmatrixsolvels = (_d_rmatrixsolvels)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixsolvels"), typeof(_d_rmatrixsolvels));
            _i_smp_rmatrixsolvels = (_d_rmatrixsolvels)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_rmatrixsolvels"), typeof(_d_rmatrixsolvels));
        _i_x_obj_copy_logitmodel = (_d_x_obj_copy_logitmodel)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_logitmodel"), typeof(_d_x_obj_copy_logitmodel));
        _i_x_obj_free_logitmodel = (_d_x_obj_free_logitmodel)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_logitmodel"), typeof(_d_x_obj_free_logitmodel));
            _i_ser_mnltrainh = (_d_mnltrainh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnltrainh"), typeof(_d_mnltrainh));
            _i_ser_mnlprocess = (_d_mnlprocess)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlprocess"), typeof(_d_mnlprocess));
            _i_ser_mnlprocessi = (_d_mnlprocessi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlprocessi"), typeof(_d_mnlprocessi));
            _i_ser_mnlunpack = (_d_mnlunpack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlunpack"), typeof(_d_mnlunpack));
            _i_ser_mnlpack = (_d_mnlpack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlpack"), typeof(_d_mnlpack));
            _i_ser_mnlavgce = (_d_mnlavgce)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlavgce"), typeof(_d_mnlavgce));
            _i_ser_mnlrelclserror = (_d_mnlrelclserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlrelclserror"), typeof(_d_mnlrelclserror));
            _i_ser_mnlrmserror = (_d_mnlrmserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlrmserror"), typeof(_d_mnlrmserror));
            _i_ser_mnlavgerror = (_d_mnlavgerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlavgerror"), typeof(_d_mnlavgerror));
            _i_ser_mnlavgrelerror = (_d_mnlavgrelerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlavgrelerror"), typeof(_d_mnlavgrelerror));
            _i_ser_mnlclserror = (_d_mnlclserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mnlclserror"), typeof(_d_mnlclserror));
        _i_x_obj_copy_mincgstate = (_d_x_obj_copy_mincgstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_mincgstate"), typeof(_d_x_obj_copy_mincgstate));
        _i_x_obj_free_mincgstate = (_d_x_obj_free_mincgstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_mincgstate"), typeof(_d_x_obj_free_mincgstate));
        _i_x_mincgstate_get_needf = (_d_x_mincgstate_get_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_get_needf"), typeof(_d_x_mincgstate_get_needf));
        _i_x_mincgstate_set_needf = (_d_x_mincgstate_set_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_set_needf"), typeof(_d_x_mincgstate_set_needf));
        _i_x_mincgstate_get_needfg = (_d_x_mincgstate_get_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_get_needfg"), typeof(_d_x_mincgstate_get_needfg));
        _i_x_mincgstate_set_needfg = (_d_x_mincgstate_set_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_set_needfg"), typeof(_d_x_mincgstate_set_needfg));
        _i_x_mincgstate_get_xupdated = (_d_x_mincgstate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_get_xupdated"), typeof(_d_x_mincgstate_get_xupdated));
        _i_x_mincgstate_set_xupdated = (_d_x_mincgstate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_set_xupdated"), typeof(_d_x_mincgstate_set_xupdated));
        _i_x_mincgstate_get_f = (_d_x_mincgstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_get_f"), typeof(_d_x_mincgstate_get_f));
        _i_x_mincgstate_set_f = (_d_x_mincgstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_set_f"), typeof(_d_x_mincgstate_set_f));
        _i_x_mincgstate_get_g = (_d_x_mincgstate_get_g)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_get_g"), typeof(_d_x_mincgstate_get_g));
        _i_x_mincgstate_get_x = (_d_x_mincgstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_mincgstate_get_x"), typeof(_d_x_mincgstate_get_x));
            _i_ser_mincgcreate = (_d_mincgcreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgcreate"), typeof(_d_mincgcreate));
            _i_ser_mincgcreatef = (_d_mincgcreatef)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgcreatef"), typeof(_d_mincgcreatef));
            _i_ser_mincgsetcond = (_d_mincgsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetcond"), typeof(_d_mincgsetcond));
            _i_ser_mincgsetscale = (_d_mincgsetscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetscale"), typeof(_d_mincgsetscale));
            _i_ser_mincgsetxrep = (_d_mincgsetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetxrep"), typeof(_d_mincgsetxrep));
            _i_ser_mincgsetcgtype = (_d_mincgsetcgtype)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetcgtype"), typeof(_d_mincgsetcgtype));
            _i_ser_mincgsetstpmax = (_d_mincgsetstpmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetstpmax"), typeof(_d_mincgsetstpmax));
            _i_ser_mincgsuggeststep = (_d_mincgsuggeststep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsuggeststep"), typeof(_d_mincgsuggeststep));
            _i_ser_mincgsetprecdefault = (_d_mincgsetprecdefault)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetprecdefault"), typeof(_d_mincgsetprecdefault));
            _i_ser_mincgsetprecdiag = (_d_mincgsetprecdiag)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetprecdiag"), typeof(_d_mincgsetprecdiag));
            _i_ser_mincgsetprecscale = (_d_mincgsetprecscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetprecscale"), typeof(_d_mincgsetprecscale));
            _i_ser_mincgiteration = (_d_mincgiteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgiteration"), typeof(_d_mincgiteration));
            _i_ser_mincgresults = (_d_mincgresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgresults"), typeof(_d_mincgresults));
            _i_ser_mincgresultsbuf = (_d_mincgresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgresultsbuf"), typeof(_d_mincgresultsbuf));
            _i_ser_mincgrestartfrom = (_d_mincgrestartfrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgrestartfrom"), typeof(_d_mincgrestartfrom));
            _i_ser_mincgrequesttermination = (_d_mincgrequesttermination)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgrequesttermination"), typeof(_d_mincgrequesttermination));
            _i_ser_mincgsetgradientcheck = (_d_mincgsetgradientcheck)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mincgsetgradientcheck"), typeof(_d_mincgsetgradientcheck));
        _i_x_obj_copy_minbleicstate = (_d_x_obj_copy_minbleicstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_minbleicstate"), typeof(_d_x_obj_copy_minbleicstate));
        _i_x_obj_free_minbleicstate = (_d_x_obj_free_minbleicstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_minbleicstate"), typeof(_d_x_obj_free_minbleicstate));
        _i_x_minbleicstate_get_needf = (_d_x_minbleicstate_get_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_get_needf"), typeof(_d_x_minbleicstate_get_needf));
        _i_x_minbleicstate_set_needf = (_d_x_minbleicstate_set_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_set_needf"), typeof(_d_x_minbleicstate_set_needf));
        _i_x_minbleicstate_get_needfg = (_d_x_minbleicstate_get_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_get_needfg"), typeof(_d_x_minbleicstate_get_needfg));
        _i_x_minbleicstate_set_needfg = (_d_x_minbleicstate_set_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_set_needfg"), typeof(_d_x_minbleicstate_set_needfg));
        _i_x_minbleicstate_get_xupdated = (_d_x_minbleicstate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_get_xupdated"), typeof(_d_x_minbleicstate_get_xupdated));
        _i_x_minbleicstate_set_xupdated = (_d_x_minbleicstate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_set_xupdated"), typeof(_d_x_minbleicstate_set_xupdated));
        _i_x_minbleicstate_get_f = (_d_x_minbleicstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_get_f"), typeof(_d_x_minbleicstate_get_f));
        _i_x_minbleicstate_set_f = (_d_x_minbleicstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_set_f"), typeof(_d_x_minbleicstate_set_f));
        _i_x_minbleicstate_get_g = (_d_x_minbleicstate_get_g)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_get_g"), typeof(_d_x_minbleicstate_get_g));
        _i_x_minbleicstate_get_x = (_d_x_minbleicstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minbleicstate_get_x"), typeof(_d_x_minbleicstate_get_x));
            _i_ser_minbleiccreate = (_d_minbleiccreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleiccreate"), typeof(_d_minbleiccreate));
            _i_ser_minbleiccreatef = (_d_minbleiccreatef)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleiccreatef"), typeof(_d_minbleiccreatef));
            _i_ser_minbleicsetbc = (_d_minbleicsetbc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetbc"), typeof(_d_minbleicsetbc));
            _i_ser_minbleicsetlc = (_d_minbleicsetlc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetlc"), typeof(_d_minbleicsetlc));
            _i_ser_minbleicsetcond = (_d_minbleicsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetcond"), typeof(_d_minbleicsetcond));
            _i_ser_minbleicsetscale = (_d_minbleicsetscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetscale"), typeof(_d_minbleicsetscale));
            _i_ser_minbleicsetprecdefault = (_d_minbleicsetprecdefault)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetprecdefault"), typeof(_d_minbleicsetprecdefault));
            _i_ser_minbleicsetprecdiag = (_d_minbleicsetprecdiag)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetprecdiag"), typeof(_d_minbleicsetprecdiag));
            _i_ser_minbleicsetprecscale = (_d_minbleicsetprecscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetprecscale"), typeof(_d_minbleicsetprecscale));
            _i_ser_minbleicsetxrep = (_d_minbleicsetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetxrep"), typeof(_d_minbleicsetxrep));
            _i_ser_minbleicsetstpmax = (_d_minbleicsetstpmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetstpmax"), typeof(_d_minbleicsetstpmax));
            _i_ser_minbleiciteration = (_d_minbleiciteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleiciteration"), typeof(_d_minbleiciteration));
            _i_ser_minbleicresults = (_d_minbleicresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicresults"), typeof(_d_minbleicresults));
            _i_ser_minbleicresultsbuf = (_d_minbleicresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicresultsbuf"), typeof(_d_minbleicresultsbuf));
            _i_ser_minbleicrestartfrom = (_d_minbleicrestartfrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicrestartfrom"), typeof(_d_minbleicrestartfrom));
            _i_ser_minbleicrequesttermination = (_d_minbleicrequesttermination)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicrequesttermination"), typeof(_d_minbleicrequesttermination));
            _i_ser_minbleicsetgradientcheck = (_d_minbleicsetgradientcheck)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetgradientcheck"), typeof(_d_minbleicsetgradientcheck));
        _i_x_obj_copy_mcpdstate = (_d_x_obj_copy_mcpdstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_mcpdstate"), typeof(_d_x_obj_copy_mcpdstate));
        _i_x_obj_free_mcpdstate = (_d_x_obj_free_mcpdstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_mcpdstate"), typeof(_d_x_obj_free_mcpdstate));
            _i_ser_mcpdcreate = (_d_mcpdcreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdcreate"), typeof(_d_mcpdcreate));
            _i_ser_mcpdcreateentry = (_d_mcpdcreateentry)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdcreateentry"), typeof(_d_mcpdcreateentry));
            _i_ser_mcpdcreateexit = (_d_mcpdcreateexit)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdcreateexit"), typeof(_d_mcpdcreateexit));
            _i_ser_mcpdcreateentryexit = (_d_mcpdcreateentryexit)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdcreateentryexit"), typeof(_d_mcpdcreateentryexit));
            _i_ser_mcpdaddtrack = (_d_mcpdaddtrack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdaddtrack"), typeof(_d_mcpdaddtrack));
            _i_ser_mcpdsetec = (_d_mcpdsetec)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdsetec"), typeof(_d_mcpdsetec));
            _i_ser_mcpdaddec = (_d_mcpdaddec)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdaddec"), typeof(_d_mcpdaddec));
            _i_ser_mcpdsetbc = (_d_mcpdsetbc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdsetbc"), typeof(_d_mcpdsetbc));
            _i_ser_mcpdaddbc = (_d_mcpdaddbc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdaddbc"), typeof(_d_mcpdaddbc));
            _i_ser_mcpdsetlc = (_d_mcpdsetlc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdsetlc"), typeof(_d_mcpdsetlc));
            _i_ser_mcpdsettikhonovregularizer = (_d_mcpdsettikhonovregularizer)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdsettikhonovregularizer"), typeof(_d_mcpdsettikhonovregularizer));
            _i_ser_mcpdsetprior = (_d_mcpdsetprior)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdsetprior"), typeof(_d_mcpdsetprior));
            _i_ser_mcpdsetpredictionweights = (_d_mcpdsetpredictionweights)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdsetpredictionweights"), typeof(_d_mcpdsetpredictionweights));
            _i_ser_mcpdsolve = (_d_mcpdsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdsolve"), typeof(_d_mcpdsolve));
            _i_ser_mcpdresults = (_d_mcpdresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mcpdresults"), typeof(_d_mcpdresults));
        _i_x_obj_copy_mlpensemble = (_d_x_obj_copy_mlpensemble)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_mlpensemble"), typeof(_d_x_obj_copy_mlpensemble));
        _i_x_obj_free_mlpensemble = (_d_x_obj_free_mlpensemble)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_mlpensemble"), typeof(_d_x_obj_free_mlpensemble));
            _i_x_mlpeserialize   =   (_d_x_mlpeserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeserialize"),   typeof(_d_x_mlpeserialize));
            _i_x_mlpeunserialize = (_d_x_mlpeunserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeunserialize"), typeof(_d_x_mlpeunserialize));
            _i_ser_mlpecreate0 = (_d_mlpecreate0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreate0"), typeof(_d_mlpecreate0));
            _i_ser_mlpecreate1 = (_d_mlpecreate1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreate1"), typeof(_d_mlpecreate1));
            _i_ser_mlpecreate2 = (_d_mlpecreate2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreate2"), typeof(_d_mlpecreate2));
            _i_ser_mlpecreateb0 = (_d_mlpecreateb0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreateb0"), typeof(_d_mlpecreateb0));
            _i_ser_mlpecreateb1 = (_d_mlpecreateb1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreateb1"), typeof(_d_mlpecreateb1));
            _i_ser_mlpecreateb2 = (_d_mlpecreateb2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreateb2"), typeof(_d_mlpecreateb2));
            _i_ser_mlpecreater0 = (_d_mlpecreater0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreater0"), typeof(_d_mlpecreater0));
            _i_ser_mlpecreater1 = (_d_mlpecreater1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreater1"), typeof(_d_mlpecreater1));
            _i_ser_mlpecreater2 = (_d_mlpecreater2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreater2"), typeof(_d_mlpecreater2));
            _i_ser_mlpecreatec0 = (_d_mlpecreatec0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreatec0"), typeof(_d_mlpecreatec0));
            _i_ser_mlpecreatec1 = (_d_mlpecreatec1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreatec1"), typeof(_d_mlpecreatec1));
            _i_ser_mlpecreatec2 = (_d_mlpecreatec2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreatec2"), typeof(_d_mlpecreatec2));
            _i_ser_mlpecreatefromnetwork = (_d_mlpecreatefromnetwork)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpecreatefromnetwork"), typeof(_d_mlpecreatefromnetwork));
            _i_ser_mlperandomize = (_d_mlperandomize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlperandomize"), typeof(_d_mlperandomize));
            _i_ser_mlpeproperties = (_d_mlpeproperties)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeproperties"), typeof(_d_mlpeproperties));
            _i_ser_mlpeissoftmax = (_d_mlpeissoftmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeissoftmax"), typeof(_d_mlpeissoftmax));
            _i_ser_mlpeprocess = (_d_mlpeprocess)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeprocess"), typeof(_d_mlpeprocess));
            _i_ser_mlpeprocessi = (_d_mlpeprocessi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeprocessi"), typeof(_d_mlpeprocessi));
            _i_ser_mlperelclserror = (_d_mlperelclserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlperelclserror"), typeof(_d_mlperelclserror));
            _i_ser_mlpeavgce = (_d_mlpeavgce)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeavgce"), typeof(_d_mlpeavgce));
            _i_ser_mlpermserror = (_d_mlpermserror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpermserror"), typeof(_d_mlpermserror));
            _i_ser_mlpeavgerror = (_d_mlpeavgerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeavgerror"), typeof(_d_mlpeavgerror));
            _i_ser_mlpeavgrelerror = (_d_mlpeavgrelerror)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpeavgrelerror"), typeof(_d_mlpeavgrelerror));
        _i_x_obj_copy_minlbfgsstate = (_d_x_obj_copy_minlbfgsstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_minlbfgsstate"), typeof(_d_x_obj_copy_minlbfgsstate));
        _i_x_obj_free_minlbfgsstate = (_d_x_obj_free_minlbfgsstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_minlbfgsstate"), typeof(_d_x_obj_free_minlbfgsstate));
        _i_x_minlbfgsstate_get_needf = (_d_x_minlbfgsstate_get_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_get_needf"), typeof(_d_x_minlbfgsstate_get_needf));
        _i_x_minlbfgsstate_set_needf = (_d_x_minlbfgsstate_set_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_set_needf"), typeof(_d_x_minlbfgsstate_set_needf));
        _i_x_minlbfgsstate_get_needfg = (_d_x_minlbfgsstate_get_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_get_needfg"), typeof(_d_x_minlbfgsstate_get_needfg));
        _i_x_minlbfgsstate_set_needfg = (_d_x_minlbfgsstate_set_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_set_needfg"), typeof(_d_x_minlbfgsstate_set_needfg));
        _i_x_minlbfgsstate_get_xupdated = (_d_x_minlbfgsstate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_get_xupdated"), typeof(_d_x_minlbfgsstate_get_xupdated));
        _i_x_minlbfgsstate_set_xupdated = (_d_x_minlbfgsstate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_set_xupdated"), typeof(_d_x_minlbfgsstate_set_xupdated));
        _i_x_minlbfgsstate_get_f = (_d_x_minlbfgsstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_get_f"), typeof(_d_x_minlbfgsstate_get_f));
        _i_x_minlbfgsstate_set_f = (_d_x_minlbfgsstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_set_f"), typeof(_d_x_minlbfgsstate_set_f));
        _i_x_minlbfgsstate_get_g = (_d_x_minlbfgsstate_get_g)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_get_g"), typeof(_d_x_minlbfgsstate_get_g));
        _i_x_minlbfgsstate_get_x = (_d_x_minlbfgsstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlbfgsstate_get_x"), typeof(_d_x_minlbfgsstate_get_x));
            _i_ser_minlbfgscreate = (_d_minlbfgscreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgscreate"), typeof(_d_minlbfgscreate));
            _i_ser_minlbfgscreatef = (_d_minlbfgscreatef)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgscreatef"), typeof(_d_minlbfgscreatef));
            _i_ser_minlbfgssetcond = (_d_minlbfgssetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetcond"), typeof(_d_minlbfgssetcond));
            _i_ser_minlbfgssetxrep = (_d_minlbfgssetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetxrep"), typeof(_d_minlbfgssetxrep));
            _i_ser_minlbfgssetstpmax = (_d_minlbfgssetstpmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetstpmax"), typeof(_d_minlbfgssetstpmax));
            _i_ser_minlbfgssetscale = (_d_minlbfgssetscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetscale"), typeof(_d_minlbfgssetscale));
            _i_ser_minlbfgssetprecdefault = (_d_minlbfgssetprecdefault)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetprecdefault"), typeof(_d_minlbfgssetprecdefault));
            _i_ser_minlbfgssetpreccholesky = (_d_minlbfgssetpreccholesky)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetpreccholesky"), typeof(_d_minlbfgssetpreccholesky));
            _i_ser_minlbfgssetprecdiag = (_d_minlbfgssetprecdiag)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetprecdiag"), typeof(_d_minlbfgssetprecdiag));
            _i_ser_minlbfgssetprecscale = (_d_minlbfgssetprecscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetprecscale"), typeof(_d_minlbfgssetprecscale));
            _i_ser_minlbfgsiteration = (_d_minlbfgsiteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgsiteration"), typeof(_d_minlbfgsiteration));
            _i_ser_minlbfgsresults = (_d_minlbfgsresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgsresults"), typeof(_d_minlbfgsresults));
            _i_ser_minlbfgsresultsbuf = (_d_minlbfgsresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgsresultsbuf"), typeof(_d_minlbfgsresultsbuf));
            _i_ser_minlbfgsrestartfrom = (_d_minlbfgsrestartfrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgsrestartfrom"), typeof(_d_minlbfgsrestartfrom));
            _i_ser_minlbfgsrequesttermination = (_d_minlbfgsrequesttermination)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgsrequesttermination"), typeof(_d_minlbfgsrequesttermination));
            _i_ser_minlbfgssetgradientcheck = (_d_minlbfgssetgradientcheck)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetgradientcheck"), typeof(_d_minlbfgssetgradientcheck));
        _i_x_obj_copy_mlptrainer = (_d_x_obj_copy_mlptrainer)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_mlptrainer"), typeof(_d_x_obj_copy_mlptrainer));
        _i_x_obj_free_mlptrainer = (_d_x_obj_free_mlptrainer)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_mlptrainer"), typeof(_d_x_obj_free_mlptrainer));
            _i_ser_mlptrainlm = (_d_mlptrainlm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlptrainlm"), typeof(_d_mlptrainlm));
            _i_ser_mlptrainlbfgs = (_d_mlptrainlbfgs)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlptrainlbfgs"), typeof(_d_mlptrainlbfgs));
            _i_ser_mlptraines = (_d_mlptraines)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlptraines"), typeof(_d_mlptraines));
            _i_ser_mlpkfoldcvlbfgs = (_d_mlpkfoldcvlbfgs)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpkfoldcvlbfgs"), typeof(_d_mlpkfoldcvlbfgs));
            _i_ser_mlpkfoldcvlm = (_d_mlpkfoldcvlm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpkfoldcvlm"), typeof(_d_mlpkfoldcvlm));
            _i_ser_mlpkfoldcv = (_d_mlpkfoldcv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpkfoldcv"), typeof(_d_mlpkfoldcv));
            _i_smp_mlpkfoldcv = (_d_mlpkfoldcv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpkfoldcv"), typeof(_d_mlpkfoldcv));
            _i_ser_mlpcreatetrainer = (_d_mlpcreatetrainer)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreatetrainer"), typeof(_d_mlpcreatetrainer));
            _i_ser_mlpcreatetrainercls = (_d_mlpcreatetrainercls)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcreatetrainercls"), typeof(_d_mlpcreatetrainercls));
            _i_ser_mlpsetdataset = (_d_mlpsetdataset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetdataset"), typeof(_d_mlpsetdataset));
            _i_ser_mlpsetsparsedataset = (_d_mlpsetsparsedataset)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetsparsedataset"), typeof(_d_mlpsetsparsedataset));
            _i_ser_mlpsetdecay = (_d_mlpsetdecay)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetdecay"), typeof(_d_mlpsetdecay));
            _i_ser_mlpsetcond = (_d_mlpsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetcond"), typeof(_d_mlpsetcond));
            _i_ser_mlpsetalgobatch = (_d_mlpsetalgobatch)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpsetalgobatch"), typeof(_d_mlpsetalgobatch));
            _i_ser_mlptrainnetwork = (_d_mlptrainnetwork)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlptrainnetwork"), typeof(_d_mlptrainnetwork));
            _i_smp_mlptrainnetwork = (_d_mlptrainnetwork)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlptrainnetwork"), typeof(_d_mlptrainnetwork));
            _i_ser_mlpstarttraining = (_d_mlpstarttraining)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpstarttraining"), typeof(_d_mlpstarttraining));
            _i_ser_mlpcontinuetraining = (_d_mlpcontinuetraining)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpcontinuetraining"), typeof(_d_mlpcontinuetraining));
            _i_smp_mlpcontinuetraining = (_d_mlpcontinuetraining)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlpcontinuetraining"), typeof(_d_mlpcontinuetraining));
            _i_ser_mlpebagginglm = (_d_mlpebagginglm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpebagginglm"), typeof(_d_mlpebagginglm));
            _i_ser_mlpebagginglbfgs = (_d_mlpebagginglbfgs)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpebagginglbfgs"), typeof(_d_mlpebagginglbfgs));
            _i_ser_mlpetraines = (_d_mlpetraines)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlpetraines"), typeof(_d_mlpetraines));
            _i_ser_mlptrainensemblees = (_d_mlptrainensemblees)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mlptrainensemblees"), typeof(_d_mlptrainensemblees));
            _i_smp_mlptrainensemblees = (_d_mlptrainensemblees)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_mlptrainensemblees"), typeof(_d_mlptrainensemblees));
            _i_ser_pcabuildbasis = (_d_pcabuildbasis)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pcabuildbasis"), typeof(_d_pcabuildbasis));
        _i_x_obj_copy_odesolverstate = (_d_x_obj_copy_odesolverstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_odesolverstate"), typeof(_d_x_obj_copy_odesolverstate));
        _i_x_obj_free_odesolverstate = (_d_x_obj_free_odesolverstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_odesolverstate"), typeof(_d_x_obj_free_odesolverstate));
        _i_x_odesolverstate_get_needdy = (_d_x_odesolverstate_get_needdy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_odesolverstate_get_needdy"), typeof(_d_x_odesolverstate_get_needdy));
        _i_x_odesolverstate_set_needdy = (_d_x_odesolverstate_set_needdy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_odesolverstate_set_needdy"), typeof(_d_x_odesolverstate_set_needdy));
        _i_x_odesolverstate_get_y = (_d_x_odesolverstate_get_y)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_odesolverstate_get_y"), typeof(_d_x_odesolverstate_get_y));
        _i_x_odesolverstate_get_dy = (_d_x_odesolverstate_get_dy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_odesolverstate_get_dy"), typeof(_d_x_odesolverstate_get_dy));
        _i_x_odesolverstate_get_x = (_d_x_odesolverstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_odesolverstate_get_x"), typeof(_d_x_odesolverstate_get_x));
        _i_x_odesolverstate_set_x = (_d_x_odesolverstate_set_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_odesolverstate_set_x"), typeof(_d_x_odesolverstate_set_x));
            _i_ser_odesolverrkck = (_d_odesolverrkck)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_odesolverrkck"), typeof(_d_odesolverrkck));
            _i_ser_odesolveriteration = (_d_odesolveriteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_odesolveriteration"), typeof(_d_odesolveriteration));
            _i_ser_odesolverresults = (_d_odesolverresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_odesolverresults"), typeof(_d_odesolverresults));
            _i_ser_fftc1d = (_d_fftc1d)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fftc1d"), typeof(_d_fftc1d));
            _i_ser_fftc1dinv = (_d_fftc1dinv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fftc1dinv"), typeof(_d_fftc1dinv));
            _i_ser_fftr1d = (_d_fftr1d)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fftr1d"), typeof(_d_fftr1d));
            _i_ser_fftr1dinv = (_d_fftr1dinv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fftr1dinv"), typeof(_d_fftr1dinv));
            _i_ser_convc1d = (_d_convc1d)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_convc1d"), typeof(_d_convc1d));
            _i_ser_convc1dinv = (_d_convc1dinv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_convc1dinv"), typeof(_d_convc1dinv));
            _i_ser_convc1dcircular = (_d_convc1dcircular)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_convc1dcircular"), typeof(_d_convc1dcircular));
            _i_ser_convc1dcircularinv = (_d_convc1dcircularinv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_convc1dcircularinv"), typeof(_d_convc1dcircularinv));
            _i_ser_convr1d = (_d_convr1d)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_convr1d"), typeof(_d_convr1d));
            _i_ser_convr1dinv = (_d_convr1dinv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_convr1dinv"), typeof(_d_convr1dinv));
            _i_ser_convr1dcircular = (_d_convr1dcircular)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_convr1dcircular"), typeof(_d_convr1dcircular));
            _i_ser_convr1dcircularinv = (_d_convr1dcircularinv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_convr1dcircularinv"), typeof(_d_convr1dcircularinv));
            _i_ser_corrc1d = (_d_corrc1d)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_corrc1d"), typeof(_d_corrc1d));
            _i_ser_corrc1dcircular = (_d_corrc1dcircular)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_corrc1dcircular"), typeof(_d_corrc1dcircular));
            _i_ser_corrr1d = (_d_corrr1d)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_corrr1d"), typeof(_d_corrr1d));
            _i_ser_corrr1dcircular = (_d_corrr1dcircular)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_corrr1dcircular"), typeof(_d_corrr1dcircular));
            _i_ser_fhtr1d = (_d_fhtr1d)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fhtr1d"), typeof(_d_fhtr1d));
            _i_ser_fhtr1dinv = (_d_fhtr1dinv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fhtr1dinv"), typeof(_d_fhtr1dinv));
            _i_ser_gqgeneraterec = (_d_gqgeneraterec)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gqgeneraterec"), typeof(_d_gqgeneraterec));
            _i_ser_gqgenerategausslobattorec = (_d_gqgenerategausslobattorec)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gqgenerategausslobattorec"), typeof(_d_gqgenerategausslobattorec));
            _i_ser_gqgenerategaussradaurec = (_d_gqgenerategaussradaurec)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gqgenerategaussradaurec"), typeof(_d_gqgenerategaussradaurec));
            _i_ser_gqgenerategausslegendre = (_d_gqgenerategausslegendre)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gqgenerategausslegendre"), typeof(_d_gqgenerategausslegendre));
            _i_ser_gqgenerategaussjacobi = (_d_gqgenerategaussjacobi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gqgenerategaussjacobi"), typeof(_d_gqgenerategaussjacobi));
            _i_ser_gqgenerategausslaguerre = (_d_gqgenerategausslaguerre)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gqgenerategausslaguerre"), typeof(_d_gqgenerategausslaguerre));
            _i_ser_gqgenerategausshermite = (_d_gqgenerategausshermite)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gqgenerategausshermite"), typeof(_d_gqgenerategausshermite));
            _i_ser_gkqgeneraterec = (_d_gkqgeneraterec)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gkqgeneraterec"), typeof(_d_gkqgeneraterec));
            _i_ser_gkqgenerategausslegendre = (_d_gkqgenerategausslegendre)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gkqgenerategausslegendre"), typeof(_d_gkqgenerategausslegendre));
            _i_ser_gkqgenerategaussjacobi = (_d_gkqgenerategaussjacobi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gkqgenerategaussjacobi"), typeof(_d_gkqgenerategaussjacobi));
            _i_ser_gkqlegendrecalc = (_d_gkqlegendrecalc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gkqlegendrecalc"), typeof(_d_gkqlegendrecalc));
            _i_ser_gkqlegendretbl = (_d_gkqlegendretbl)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_gkqlegendretbl"), typeof(_d_gkqlegendretbl));
        _i_x_obj_copy_autogkstate = (_d_x_obj_copy_autogkstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_autogkstate"), typeof(_d_x_obj_copy_autogkstate));
        _i_x_obj_free_autogkstate = (_d_x_obj_free_autogkstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_autogkstate"), typeof(_d_x_obj_free_autogkstate));
        _i_x_autogkstate_get_needf = (_d_x_autogkstate_get_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_get_needf"), typeof(_d_x_autogkstate_get_needf));
        _i_x_autogkstate_set_needf = (_d_x_autogkstate_set_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_set_needf"), typeof(_d_x_autogkstate_set_needf));
        _i_x_autogkstate_get_x = (_d_x_autogkstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_get_x"), typeof(_d_x_autogkstate_get_x));
        _i_x_autogkstate_set_x = (_d_x_autogkstate_set_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_set_x"), typeof(_d_x_autogkstate_set_x));
        _i_x_autogkstate_get_xminusa = (_d_x_autogkstate_get_xminusa)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_get_xminusa"), typeof(_d_x_autogkstate_get_xminusa));
        _i_x_autogkstate_set_xminusa = (_d_x_autogkstate_set_xminusa)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_set_xminusa"), typeof(_d_x_autogkstate_set_xminusa));
        _i_x_autogkstate_get_bminusx = (_d_x_autogkstate_get_bminusx)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_get_bminusx"), typeof(_d_x_autogkstate_get_bminusx));
        _i_x_autogkstate_set_bminusx = (_d_x_autogkstate_set_bminusx)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_set_bminusx"), typeof(_d_x_autogkstate_set_bminusx));
        _i_x_autogkstate_get_f = (_d_x_autogkstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_get_f"), typeof(_d_x_autogkstate_get_f));
        _i_x_autogkstate_set_f = (_d_x_autogkstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_autogkstate_set_f"), typeof(_d_x_autogkstate_set_f));
            _i_ser_autogksmooth = (_d_autogksmooth)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_autogksmooth"), typeof(_d_autogksmooth));
            _i_ser_autogksmoothw = (_d_autogksmoothw)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_autogksmoothw"), typeof(_d_autogksmoothw));
            _i_ser_autogksingular = (_d_autogksingular)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_autogksingular"), typeof(_d_autogksingular));
            _i_ser_autogkiteration = (_d_autogkiteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_autogkiteration"), typeof(_d_autogkiteration));
            _i_ser_autogkresults = (_d_autogkresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_autogkresults"), typeof(_d_autogkresults));
        _i_x_obj_copy_idwinterpolant = (_d_x_obj_copy_idwinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_idwinterpolant"), typeof(_d_x_obj_copy_idwinterpolant));
        _i_x_obj_free_idwinterpolant = (_d_x_obj_free_idwinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_idwinterpolant"), typeof(_d_x_obj_free_idwinterpolant));
            _i_ser_idwcalc = (_d_idwcalc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_idwcalc"), typeof(_d_idwcalc));
            _i_ser_idwbuildmodifiedshepard = (_d_idwbuildmodifiedshepard)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_idwbuildmodifiedshepard"), typeof(_d_idwbuildmodifiedshepard));
            _i_ser_idwbuildmodifiedshepardr = (_d_idwbuildmodifiedshepardr)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_idwbuildmodifiedshepardr"), typeof(_d_idwbuildmodifiedshepardr));
            _i_ser_idwbuildnoisy = (_d_idwbuildnoisy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_idwbuildnoisy"), typeof(_d_idwbuildnoisy));
        _i_x_obj_copy_barycentricinterpolant = (_d_x_obj_copy_barycentricinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_barycentricinterpolant"), typeof(_d_x_obj_copy_barycentricinterpolant));
        _i_x_obj_free_barycentricinterpolant = (_d_x_obj_free_barycentricinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_barycentricinterpolant"), typeof(_d_x_obj_free_barycentricinterpolant));
            _i_ser_barycentriccalc = (_d_barycentriccalc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentriccalc"), typeof(_d_barycentriccalc));
            _i_ser_barycentricdiff1 = (_d_barycentricdiff1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentricdiff1"), typeof(_d_barycentricdiff1));
            _i_ser_barycentricdiff2 = (_d_barycentricdiff2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentricdiff2"), typeof(_d_barycentricdiff2));
            _i_ser_barycentriclintransx = (_d_barycentriclintransx)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentriclintransx"), typeof(_d_barycentriclintransx));
            _i_ser_barycentriclintransy = (_d_barycentriclintransy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentriclintransy"), typeof(_d_barycentriclintransy));
            _i_ser_barycentricunpack = (_d_barycentricunpack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentricunpack"), typeof(_d_barycentricunpack));
            _i_ser_barycentricbuildxyw = (_d_barycentricbuildxyw)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentricbuildxyw"), typeof(_d_barycentricbuildxyw));
            _i_ser_barycentricbuildfloaterhormann = (_d_barycentricbuildfloaterhormann)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentricbuildfloaterhormann"), typeof(_d_barycentricbuildfloaterhormann));
            _i_ser_polynomialbar2cheb = (_d_polynomialbar2cheb)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialbar2cheb"), typeof(_d_polynomialbar2cheb));
            _i_ser_polynomialcheb2bar = (_d_polynomialcheb2bar)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialcheb2bar"), typeof(_d_polynomialcheb2bar));
            _i_ser_polynomialbar2pow = (_d_polynomialbar2pow)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialbar2pow"), typeof(_d_polynomialbar2pow));
            _i_ser_polynomialpow2bar = (_d_polynomialpow2bar)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialpow2bar"), typeof(_d_polynomialpow2bar));
            _i_ser_polynomialbuild = (_d_polynomialbuild)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialbuild"), typeof(_d_polynomialbuild));
            _i_ser_polynomialbuildeqdist = (_d_polynomialbuildeqdist)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialbuildeqdist"), typeof(_d_polynomialbuildeqdist));
            _i_ser_polynomialbuildcheb1 = (_d_polynomialbuildcheb1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialbuildcheb1"), typeof(_d_polynomialbuildcheb1));
            _i_ser_polynomialbuildcheb2 = (_d_polynomialbuildcheb2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialbuildcheb2"), typeof(_d_polynomialbuildcheb2));
            _i_ser_polynomialcalceqdist = (_d_polynomialcalceqdist)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialcalceqdist"), typeof(_d_polynomialcalceqdist));
            _i_ser_polynomialcalccheb1 = (_d_polynomialcalccheb1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialcalccheb1"), typeof(_d_polynomialcalccheb1));
            _i_ser_polynomialcalccheb2 = (_d_polynomialcalccheb2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialcalccheb2"), typeof(_d_polynomialcalccheb2));
        _i_x_obj_copy_spline1dinterpolant = (_d_x_obj_copy_spline1dinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_spline1dinterpolant"), typeof(_d_x_obj_copy_spline1dinterpolant));
        _i_x_obj_free_spline1dinterpolant = (_d_x_obj_free_spline1dinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_spline1dinterpolant"), typeof(_d_x_obj_free_spline1dinterpolant));
            _i_ser_spline1dbuildlinear = (_d_spline1dbuildlinear)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dbuildlinear"), typeof(_d_spline1dbuildlinear));
            _i_ser_spline1dbuildcubic = (_d_spline1dbuildcubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dbuildcubic"), typeof(_d_spline1dbuildcubic));
            _i_ser_spline1dgriddiffcubic = (_d_spline1dgriddiffcubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dgriddiffcubic"), typeof(_d_spline1dgriddiffcubic));
            _i_ser_spline1dgriddiff2cubic = (_d_spline1dgriddiff2cubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dgriddiff2cubic"), typeof(_d_spline1dgriddiff2cubic));
            _i_ser_spline1dconvcubic = (_d_spline1dconvcubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dconvcubic"), typeof(_d_spline1dconvcubic));
            _i_ser_spline1dconvdiffcubic = (_d_spline1dconvdiffcubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dconvdiffcubic"), typeof(_d_spline1dconvdiffcubic));
            _i_ser_spline1dconvdiff2cubic = (_d_spline1dconvdiff2cubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dconvdiff2cubic"), typeof(_d_spline1dconvdiff2cubic));
            _i_ser_spline1dbuildcatmullrom = (_d_spline1dbuildcatmullrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dbuildcatmullrom"), typeof(_d_spline1dbuildcatmullrom));
            _i_ser_spline1dbuildhermite = (_d_spline1dbuildhermite)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dbuildhermite"), typeof(_d_spline1dbuildhermite));
            _i_ser_spline1dbuildakima = (_d_spline1dbuildakima)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dbuildakima"), typeof(_d_spline1dbuildakima));
            _i_ser_spline1dcalc = (_d_spline1dcalc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dcalc"), typeof(_d_spline1dcalc));
            _i_ser_spline1ddiff = (_d_spline1ddiff)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1ddiff"), typeof(_d_spline1ddiff));
            _i_ser_spline1dunpack = (_d_spline1dunpack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dunpack"), typeof(_d_spline1dunpack));
            _i_ser_spline1dlintransx = (_d_spline1dlintransx)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dlintransx"), typeof(_d_spline1dlintransx));
            _i_ser_spline1dlintransy = (_d_spline1dlintransy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dlintransy"), typeof(_d_spline1dlintransy));
            _i_ser_spline1dintegrate = (_d_spline1dintegrate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dintegrate"), typeof(_d_spline1dintegrate));
            _i_ser_spline1dbuildmonotone = (_d_spline1dbuildmonotone)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dbuildmonotone"), typeof(_d_spline1dbuildmonotone));
        _i_x_obj_copy_normestimatorstate = (_d_x_obj_copy_normestimatorstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_normestimatorstate"), typeof(_d_x_obj_copy_normestimatorstate));
        _i_x_obj_free_normestimatorstate = (_d_x_obj_free_normestimatorstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_normestimatorstate"), typeof(_d_x_obj_free_normestimatorstate));
            _i_ser_normestimatorcreate = (_d_normestimatorcreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_normestimatorcreate"), typeof(_d_normestimatorcreate));
            _i_ser_normestimatorsetseed = (_d_normestimatorsetseed)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_normestimatorsetseed"), typeof(_d_normestimatorsetseed));
            _i_ser_normestimatorestimatesparse = (_d_normestimatorestimatesparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_normestimatorestimatesparse"), typeof(_d_normestimatorestimatesparse));
            _i_ser_normestimatorresults = (_d_normestimatorresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_normestimatorresults"), typeof(_d_normestimatorresults));
        _i_x_obj_copy_minqpstate = (_d_x_obj_copy_minqpstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_minqpstate"), typeof(_d_x_obj_copy_minqpstate));
        _i_x_obj_free_minqpstate = (_d_x_obj_free_minqpstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_minqpstate"), typeof(_d_x_obj_free_minqpstate));
            _i_ser_minqpcreate = (_d_minqpcreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpcreate"), typeof(_d_minqpcreate));
            _i_ser_minqpsetlinearterm = (_d_minqpsetlinearterm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetlinearterm"), typeof(_d_minqpsetlinearterm));
            _i_ser_minqpsetquadraticterm = (_d_minqpsetquadraticterm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetquadraticterm"), typeof(_d_minqpsetquadraticterm));
            _i_ser_minqpsetquadratictermsparse = (_d_minqpsetquadratictermsparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetquadratictermsparse"), typeof(_d_minqpsetquadratictermsparse));
            _i_ser_minqpsetstartingpoint = (_d_minqpsetstartingpoint)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetstartingpoint"), typeof(_d_minqpsetstartingpoint));
            _i_ser_minqpsetorigin = (_d_minqpsetorigin)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetorigin"), typeof(_d_minqpsetorigin));
            _i_ser_minqpsetscale = (_d_minqpsetscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetscale"), typeof(_d_minqpsetscale));
            _i_ser_minqpsetalgocholesky = (_d_minqpsetalgocholesky)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetalgocholesky"), typeof(_d_minqpsetalgocholesky));
            _i_ser_minqpsetalgobleic = (_d_minqpsetalgobleic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetalgobleic"), typeof(_d_minqpsetalgobleic));
            _i_ser_minqpsetalgoquickqp = (_d_minqpsetalgoquickqp)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetalgoquickqp"), typeof(_d_minqpsetalgoquickqp));
            _i_ser_minqpsetbc = (_d_minqpsetbc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetbc"), typeof(_d_minqpsetbc));
            _i_ser_minqpsetlc = (_d_minqpsetlc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpsetlc"), typeof(_d_minqpsetlc));
            _i_ser_minqpoptimize = (_d_minqpoptimize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpoptimize"), typeof(_d_minqpoptimize));
            _i_ser_minqpresults = (_d_minqpresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpresults"), typeof(_d_minqpresults));
            _i_ser_minqpresultsbuf = (_d_minqpresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minqpresultsbuf"), typeof(_d_minqpresultsbuf));
        _i_x_obj_copy_minlmstate = (_d_x_obj_copy_minlmstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_minlmstate"), typeof(_d_x_obj_copy_minlmstate));
        _i_x_obj_free_minlmstate = (_d_x_obj_free_minlmstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_minlmstate"), typeof(_d_x_obj_free_minlmstate));
        _i_x_minlmstate_get_needf = (_d_x_minlmstate_get_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_needf"), typeof(_d_x_minlmstate_get_needf));
        _i_x_minlmstate_set_needf = (_d_x_minlmstate_set_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_set_needf"), typeof(_d_x_minlmstate_set_needf));
        _i_x_minlmstate_get_needfg = (_d_x_minlmstate_get_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_needfg"), typeof(_d_x_minlmstate_get_needfg));
        _i_x_minlmstate_set_needfg = (_d_x_minlmstate_set_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_set_needfg"), typeof(_d_x_minlmstate_set_needfg));
        _i_x_minlmstate_get_needfgh = (_d_x_minlmstate_get_needfgh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_needfgh"), typeof(_d_x_minlmstate_get_needfgh));
        _i_x_minlmstate_set_needfgh = (_d_x_minlmstate_set_needfgh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_set_needfgh"), typeof(_d_x_minlmstate_set_needfgh));
        _i_x_minlmstate_get_needfi = (_d_x_minlmstate_get_needfi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_needfi"), typeof(_d_x_minlmstate_get_needfi));
        _i_x_minlmstate_set_needfi = (_d_x_minlmstate_set_needfi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_set_needfi"), typeof(_d_x_minlmstate_set_needfi));
        _i_x_minlmstate_get_needfij = (_d_x_minlmstate_get_needfij)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_needfij"), typeof(_d_x_minlmstate_get_needfij));
        _i_x_minlmstate_set_needfij = (_d_x_minlmstate_set_needfij)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_set_needfij"), typeof(_d_x_minlmstate_set_needfij));
        _i_x_minlmstate_get_xupdated = (_d_x_minlmstate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_xupdated"), typeof(_d_x_minlmstate_get_xupdated));
        _i_x_minlmstate_set_xupdated = (_d_x_minlmstate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_set_xupdated"), typeof(_d_x_minlmstate_set_xupdated));
        _i_x_minlmstate_get_f = (_d_x_minlmstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_f"), typeof(_d_x_minlmstate_get_f));
        _i_x_minlmstate_set_f = (_d_x_minlmstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_set_f"), typeof(_d_x_minlmstate_set_f));
        _i_x_minlmstate_get_fi = (_d_x_minlmstate_get_fi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_fi"), typeof(_d_x_minlmstate_get_fi));
        _i_x_minlmstate_get_g = (_d_x_minlmstate_get_g)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_g"), typeof(_d_x_minlmstate_get_g));
        _i_x_minlmstate_get_h = (_d_x_minlmstate_get_h)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_h"), typeof(_d_x_minlmstate_get_h));
        _i_x_minlmstate_get_j = (_d_x_minlmstate_get_j)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_j"), typeof(_d_x_minlmstate_get_j));
        _i_x_minlmstate_get_x = (_d_x_minlmstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minlmstate_get_x"), typeof(_d_x_minlmstate_get_x));
            _i_ser_minlmcreatevj = (_d_minlmcreatevj)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmcreatevj"), typeof(_d_minlmcreatevj));
            _i_ser_minlmcreatev = (_d_minlmcreatev)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmcreatev"), typeof(_d_minlmcreatev));
            _i_ser_minlmcreatefgh = (_d_minlmcreatefgh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmcreatefgh"), typeof(_d_minlmcreatefgh));
            _i_ser_minlmsetcond = (_d_minlmsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmsetcond"), typeof(_d_minlmsetcond));
            _i_ser_minlmsetxrep = (_d_minlmsetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmsetxrep"), typeof(_d_minlmsetxrep));
            _i_ser_minlmsetstpmax = (_d_minlmsetstpmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmsetstpmax"), typeof(_d_minlmsetstpmax));
            _i_ser_minlmsetscale = (_d_minlmsetscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmsetscale"), typeof(_d_minlmsetscale));
            _i_ser_minlmsetbc = (_d_minlmsetbc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmsetbc"), typeof(_d_minlmsetbc));
            _i_ser_minlmsetacctype = (_d_minlmsetacctype)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmsetacctype"), typeof(_d_minlmsetacctype));
            _i_ser_minlmiteration = (_d_minlmiteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmiteration"), typeof(_d_minlmiteration));
            _i_ser_minlmresults = (_d_minlmresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmresults"), typeof(_d_minlmresults));
            _i_ser_minlmresultsbuf = (_d_minlmresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmresultsbuf"), typeof(_d_minlmresultsbuf));
            _i_ser_minlmrestartfrom = (_d_minlmrestartfrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmrestartfrom"), typeof(_d_minlmrestartfrom));
            _i_ser_minlmrequesttermination = (_d_minlmrequesttermination)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmrequesttermination"), typeof(_d_minlmrequesttermination));
            _i_ser_minlmcreatevgj = (_d_minlmcreatevgj)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmcreatevgj"), typeof(_d_minlmcreatevgj));
            _i_ser_minlmcreatefgj = (_d_minlmcreatefgj)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmcreatefgj"), typeof(_d_minlmcreatefgj));
            _i_ser_minlmcreatefj = (_d_minlmcreatefj)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmcreatefj"), typeof(_d_minlmcreatefj));
            _i_ser_minlmsetgradientcheck = (_d_minlmsetgradientcheck)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlmsetgradientcheck"), typeof(_d_minlmsetgradientcheck));
        _i_x_obj_copy_lsfitstate = (_d_x_obj_copy_lsfitstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_lsfitstate"), typeof(_d_x_obj_copy_lsfitstate));
        _i_x_obj_free_lsfitstate = (_d_x_obj_free_lsfitstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_lsfitstate"), typeof(_d_x_obj_free_lsfitstate));
        _i_x_lsfitstate_get_needf = (_d_x_lsfitstate_get_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_needf"), typeof(_d_x_lsfitstate_get_needf));
        _i_x_lsfitstate_set_needf = (_d_x_lsfitstate_set_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_set_needf"), typeof(_d_x_lsfitstate_set_needf));
        _i_x_lsfitstate_get_needfg = (_d_x_lsfitstate_get_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_needfg"), typeof(_d_x_lsfitstate_get_needfg));
        _i_x_lsfitstate_set_needfg = (_d_x_lsfitstate_set_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_set_needfg"), typeof(_d_x_lsfitstate_set_needfg));
        _i_x_lsfitstate_get_needfgh = (_d_x_lsfitstate_get_needfgh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_needfgh"), typeof(_d_x_lsfitstate_get_needfgh));
        _i_x_lsfitstate_set_needfgh = (_d_x_lsfitstate_set_needfgh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_set_needfgh"), typeof(_d_x_lsfitstate_set_needfgh));
        _i_x_lsfitstate_get_xupdated = (_d_x_lsfitstate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_xupdated"), typeof(_d_x_lsfitstate_get_xupdated));
        _i_x_lsfitstate_set_xupdated = (_d_x_lsfitstate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_set_xupdated"), typeof(_d_x_lsfitstate_set_xupdated));
        _i_x_lsfitstate_get_c = (_d_x_lsfitstate_get_c)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_c"), typeof(_d_x_lsfitstate_get_c));
        _i_x_lsfitstate_get_f = (_d_x_lsfitstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_f"), typeof(_d_x_lsfitstate_get_f));
        _i_x_lsfitstate_set_f = (_d_x_lsfitstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_set_f"), typeof(_d_x_lsfitstate_set_f));
        _i_x_lsfitstate_get_g = (_d_x_lsfitstate_get_g)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_g"), typeof(_d_x_lsfitstate_get_g));
        _i_x_lsfitstate_get_h = (_d_x_lsfitstate_get_h)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_h"), typeof(_d_x_lsfitstate_get_h));
        _i_x_lsfitstate_get_x = (_d_x_lsfitstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_lsfitstate_get_x"), typeof(_d_x_lsfitstate_get_x));
            _i_ser_lstfitpiecewiselinearrdpfixed = (_d_lstfitpiecewiselinearrdpfixed)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lstfitpiecewiselinearrdpfixed"), typeof(_d_lstfitpiecewiselinearrdpfixed));
            _i_ser_lstfitpiecewiselinearrdp = (_d_lstfitpiecewiselinearrdp)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lstfitpiecewiselinearrdp"), typeof(_d_lstfitpiecewiselinearrdp));
            _i_ser_polynomialfit = (_d_polynomialfit)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialfit"), typeof(_d_polynomialfit));
            _i_smp_polynomialfit = (_d_polynomialfit)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_polynomialfit"), typeof(_d_polynomialfit));
            _i_ser_polynomialfitwc = (_d_polynomialfitwc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialfitwc"), typeof(_d_polynomialfitwc));
            _i_smp_polynomialfitwc = (_d_polynomialfitwc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_polynomialfitwc"), typeof(_d_polynomialfitwc));
            _i_ser_logisticcalc4 = (_d_logisticcalc4)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_logisticcalc4"), typeof(_d_logisticcalc4));
            _i_ser_logisticcalc5 = (_d_logisticcalc5)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_logisticcalc5"), typeof(_d_logisticcalc5));
            _i_ser_logisticfit4 = (_d_logisticfit4)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_logisticfit4"), typeof(_d_logisticfit4));
            _i_ser_logisticfit4ec = (_d_logisticfit4ec)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_logisticfit4ec"), typeof(_d_logisticfit4ec));
            _i_ser_logisticfit5 = (_d_logisticfit5)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_logisticfit5"), typeof(_d_logisticfit5));
            _i_ser_logisticfit5ec = (_d_logisticfit5ec)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_logisticfit5ec"), typeof(_d_logisticfit5ec));
            _i_ser_logisticfit45x = (_d_logisticfit45x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_logisticfit45x"), typeof(_d_logisticfit45x));
            _i_ser_barycentricfitfloaterhormannwc = (_d_barycentricfitfloaterhormannwc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentricfitfloaterhormannwc"), typeof(_d_barycentricfitfloaterhormannwc));
            _i_smp_barycentricfitfloaterhormannwc = (_d_barycentricfitfloaterhormannwc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_barycentricfitfloaterhormannwc"), typeof(_d_barycentricfitfloaterhormannwc));
            _i_ser_barycentricfitfloaterhormann = (_d_barycentricfitfloaterhormann)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_barycentricfitfloaterhormann"), typeof(_d_barycentricfitfloaterhormann));
            _i_smp_barycentricfitfloaterhormann = (_d_barycentricfitfloaterhormann)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_barycentricfitfloaterhormann"), typeof(_d_barycentricfitfloaterhormann));
            _i_ser_spline1dfitpenalized = (_d_spline1dfitpenalized)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dfitpenalized"), typeof(_d_spline1dfitpenalized));
            _i_smp_spline1dfitpenalized = (_d_spline1dfitpenalized)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spline1dfitpenalized"), typeof(_d_spline1dfitpenalized));
            _i_ser_spline1dfitpenalizedw = (_d_spline1dfitpenalizedw)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dfitpenalizedw"), typeof(_d_spline1dfitpenalizedw));
            _i_smp_spline1dfitpenalizedw = (_d_spline1dfitpenalizedw)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spline1dfitpenalizedw"), typeof(_d_spline1dfitpenalizedw));
            _i_ser_spline1dfitcubicwc = (_d_spline1dfitcubicwc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dfitcubicwc"), typeof(_d_spline1dfitcubicwc));
            _i_smp_spline1dfitcubicwc = (_d_spline1dfitcubicwc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spline1dfitcubicwc"), typeof(_d_spline1dfitcubicwc));
            _i_ser_spline1dfithermitewc = (_d_spline1dfithermitewc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dfithermitewc"), typeof(_d_spline1dfithermitewc));
            _i_smp_spline1dfithermitewc = (_d_spline1dfithermitewc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spline1dfithermitewc"), typeof(_d_spline1dfithermitewc));
            _i_ser_spline1dfitcubic = (_d_spline1dfitcubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dfitcubic"), typeof(_d_spline1dfitcubic));
            _i_smp_spline1dfitcubic = (_d_spline1dfitcubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spline1dfitcubic"), typeof(_d_spline1dfitcubic));
            _i_ser_spline1dfithermite = (_d_spline1dfithermite)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline1dfithermite"), typeof(_d_spline1dfithermite));
            _i_smp_spline1dfithermite = (_d_spline1dfithermite)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_spline1dfithermite"), typeof(_d_spline1dfithermite));
            _i_ser_lsfitlinearw = (_d_lsfitlinearw)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitlinearw"), typeof(_d_lsfitlinearw));
            _i_smp_lsfitlinearw = (_d_lsfitlinearw)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_lsfitlinearw"), typeof(_d_lsfitlinearw));
            _i_ser_lsfitlinearwc = (_d_lsfitlinearwc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitlinearwc"), typeof(_d_lsfitlinearwc));
            _i_smp_lsfitlinearwc = (_d_lsfitlinearwc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_lsfitlinearwc"), typeof(_d_lsfitlinearwc));
            _i_ser_lsfitlinear = (_d_lsfitlinear)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitlinear"), typeof(_d_lsfitlinear));
            _i_smp_lsfitlinear = (_d_lsfitlinear)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_lsfitlinear"), typeof(_d_lsfitlinear));
            _i_ser_lsfitlinearc = (_d_lsfitlinearc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitlinearc"), typeof(_d_lsfitlinearc));
            _i_smp_lsfitlinearc = (_d_lsfitlinearc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smp_lsfitlinearc"), typeof(_d_lsfitlinearc));
            _i_ser_lsfitcreatewf = (_d_lsfitcreatewf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitcreatewf"), typeof(_d_lsfitcreatewf));
            _i_ser_lsfitcreatef = (_d_lsfitcreatef)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitcreatef"), typeof(_d_lsfitcreatef));
            _i_ser_lsfitcreatewfg = (_d_lsfitcreatewfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitcreatewfg"), typeof(_d_lsfitcreatewfg));
            _i_ser_lsfitcreatefg = (_d_lsfitcreatefg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitcreatefg"), typeof(_d_lsfitcreatefg));
            _i_ser_lsfitcreatewfgh = (_d_lsfitcreatewfgh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitcreatewfgh"), typeof(_d_lsfitcreatewfgh));
            _i_ser_lsfitcreatefgh = (_d_lsfitcreatefgh)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitcreatefgh"), typeof(_d_lsfitcreatefgh));
            _i_ser_lsfitsetcond = (_d_lsfitsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitsetcond"), typeof(_d_lsfitsetcond));
            _i_ser_lsfitsetstpmax = (_d_lsfitsetstpmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitsetstpmax"), typeof(_d_lsfitsetstpmax));
            _i_ser_lsfitsetxrep = (_d_lsfitsetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitsetxrep"), typeof(_d_lsfitsetxrep));
            _i_ser_lsfitsetscale = (_d_lsfitsetscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitsetscale"), typeof(_d_lsfitsetscale));
            _i_ser_lsfitsetbc = (_d_lsfitsetbc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitsetbc"), typeof(_d_lsfitsetbc));
            _i_ser_lsfititeration = (_d_lsfititeration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfititeration"), typeof(_d_lsfititeration));
            _i_ser_lsfitresults = (_d_lsfitresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitresults"), typeof(_d_lsfitresults));
            _i_ser_lsfitsetgradientcheck = (_d_lsfitsetgradientcheck)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lsfitsetgradientcheck"), typeof(_d_lsfitsetgradientcheck));
        _i_x_obj_copy_pspline2interpolant = (_d_x_obj_copy_pspline2interpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_pspline2interpolant"), typeof(_d_x_obj_copy_pspline2interpolant));
        _i_x_obj_free_pspline2interpolant = (_d_x_obj_free_pspline2interpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_pspline2interpolant"), typeof(_d_x_obj_free_pspline2interpolant));
        _i_x_obj_copy_pspline3interpolant = (_d_x_obj_copy_pspline3interpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_pspline3interpolant"), typeof(_d_x_obj_copy_pspline3interpolant));
        _i_x_obj_free_pspline3interpolant = (_d_x_obj_free_pspline3interpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_pspline3interpolant"), typeof(_d_x_obj_free_pspline3interpolant));
            _i_ser_pspline2build = (_d_pspline2build)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline2build"), typeof(_d_pspline2build));
            _i_ser_pspline3build = (_d_pspline3build)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline3build"), typeof(_d_pspline3build));
            _i_ser_pspline2buildperiodic = (_d_pspline2buildperiodic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline2buildperiodic"), typeof(_d_pspline2buildperiodic));
            _i_ser_pspline3buildperiodic = (_d_pspline3buildperiodic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline3buildperiodic"), typeof(_d_pspline3buildperiodic));
            _i_ser_pspline2parametervalues = (_d_pspline2parametervalues)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline2parametervalues"), typeof(_d_pspline2parametervalues));
            _i_ser_pspline3parametervalues = (_d_pspline3parametervalues)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline3parametervalues"), typeof(_d_pspline3parametervalues));
            _i_ser_pspline2calc = (_d_pspline2calc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline2calc"), typeof(_d_pspline2calc));
            _i_ser_pspline3calc = (_d_pspline3calc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline3calc"), typeof(_d_pspline3calc));
            _i_ser_pspline2tangent = (_d_pspline2tangent)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline2tangent"), typeof(_d_pspline2tangent));
            _i_ser_pspline3tangent = (_d_pspline3tangent)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline3tangent"), typeof(_d_pspline3tangent));
            _i_ser_pspline2diff = (_d_pspline2diff)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline2diff"), typeof(_d_pspline2diff));
            _i_ser_pspline3diff = (_d_pspline3diff)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline3diff"), typeof(_d_pspline3diff));
            _i_ser_pspline2diff2 = (_d_pspline2diff2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline2diff2"), typeof(_d_pspline2diff2));
            _i_ser_pspline3diff2 = (_d_pspline3diff2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline3diff2"), typeof(_d_pspline3diff2));
            _i_ser_pspline2arclength = (_d_pspline2arclength)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline2arclength"), typeof(_d_pspline2arclength));
            _i_ser_pspline3arclength = (_d_pspline3arclength)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pspline3arclength"), typeof(_d_pspline3arclength));
            _i_ser_parametricrdpfixed = (_d_parametricrdpfixed)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_parametricrdpfixed"), typeof(_d_parametricrdpfixed));
        _i_x_obj_copy_linlsqrstate = (_d_x_obj_copy_linlsqrstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_linlsqrstate"), typeof(_d_x_obj_copy_linlsqrstate));
        _i_x_obj_free_linlsqrstate = (_d_x_obj_free_linlsqrstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_linlsqrstate"), typeof(_d_x_obj_free_linlsqrstate));
            _i_ser_linlsqrcreate = (_d_linlsqrcreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_linlsqrcreate"), typeof(_d_linlsqrcreate));
            _i_ser_linlsqrsetprecunit = (_d_linlsqrsetprecunit)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_linlsqrsetprecunit"), typeof(_d_linlsqrsetprecunit));
            _i_ser_linlsqrsetprecdiag = (_d_linlsqrsetprecdiag)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_linlsqrsetprecdiag"), typeof(_d_linlsqrsetprecdiag));
            _i_ser_linlsqrsetlambdai = (_d_linlsqrsetlambdai)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_linlsqrsetlambdai"), typeof(_d_linlsqrsetlambdai));
            _i_ser_linlsqrsolvesparse = (_d_linlsqrsolvesparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_linlsqrsolvesparse"), typeof(_d_linlsqrsolvesparse));
            _i_ser_linlsqrsetcond = (_d_linlsqrsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_linlsqrsetcond"), typeof(_d_linlsqrsetcond));
            _i_ser_linlsqrresults = (_d_linlsqrresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_linlsqrresults"), typeof(_d_linlsqrresults));
            _i_ser_linlsqrsetxrep = (_d_linlsqrsetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_linlsqrsetxrep"), typeof(_d_linlsqrsetxrep));
        _i_x_obj_copy_rbfmodel = (_d_x_obj_copy_rbfmodel)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_rbfmodel"), typeof(_d_x_obj_copy_rbfmodel));
        _i_x_obj_free_rbfmodel = (_d_x_obj_free_rbfmodel)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_rbfmodel"), typeof(_d_x_obj_free_rbfmodel));
            _i_x_rbfserialize   =   (_d_x_rbfserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfserialize"),   typeof(_d_x_rbfserialize));
            _i_x_rbfunserialize = (_d_x_rbfunserialize)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfunserialize"), typeof(_d_x_rbfunserialize));
            _i_ser_rbfcreate = (_d_rbfcreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfcreate"), typeof(_d_rbfcreate));
            _i_ser_rbfsetpoints = (_d_rbfsetpoints)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfsetpoints"), typeof(_d_rbfsetpoints));
            _i_ser_rbfsetalgoqnn = (_d_rbfsetalgoqnn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfsetalgoqnn"), typeof(_d_rbfsetalgoqnn));
            _i_ser_rbfsetalgomultilayer = (_d_rbfsetalgomultilayer)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfsetalgomultilayer"), typeof(_d_rbfsetalgomultilayer));
            _i_ser_rbfsetlinterm = (_d_rbfsetlinterm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfsetlinterm"), typeof(_d_rbfsetlinterm));
            _i_ser_rbfsetconstterm = (_d_rbfsetconstterm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfsetconstterm"), typeof(_d_rbfsetconstterm));
            _i_ser_rbfsetzeroterm = (_d_rbfsetzeroterm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfsetzeroterm"), typeof(_d_rbfsetzeroterm));
            _i_ser_rbfbuildmodel = (_d_rbfbuildmodel)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfbuildmodel"), typeof(_d_rbfbuildmodel));
            _i_ser_rbfcalc2 = (_d_rbfcalc2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfcalc2"), typeof(_d_rbfcalc2));
            _i_ser_rbfcalc3 = (_d_rbfcalc3)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfcalc3"), typeof(_d_rbfcalc3));
            _i_ser_rbfcalc = (_d_rbfcalc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfcalc"), typeof(_d_rbfcalc));
            _i_ser_rbfcalcbuf = (_d_rbfcalcbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfcalcbuf"), typeof(_d_rbfcalcbuf));
            _i_ser_rbfgridcalc2 = (_d_rbfgridcalc2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfgridcalc2"), typeof(_d_rbfgridcalc2));
            _i_ser_rbfunpack = (_d_rbfunpack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rbfunpack"), typeof(_d_rbfunpack));
        _i_x_obj_copy_spline2dinterpolant = (_d_x_obj_copy_spline2dinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_spline2dinterpolant"), typeof(_d_x_obj_copy_spline2dinterpolant));
        _i_x_obj_free_spline2dinterpolant = (_d_x_obj_free_spline2dinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_spline2dinterpolant"), typeof(_d_x_obj_free_spline2dinterpolant));
            _i_ser_spline2dcalc = (_d_spline2dcalc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dcalc"), typeof(_d_spline2dcalc));
            _i_ser_spline2ddiff = (_d_spline2ddiff)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2ddiff"), typeof(_d_spline2ddiff));
            _i_ser_spline2dlintransxy = (_d_spline2dlintransxy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dlintransxy"), typeof(_d_spline2dlintransxy));
            _i_ser_spline2dlintransf = (_d_spline2dlintransf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dlintransf"), typeof(_d_spline2dlintransf));
            _i_ser_spline2dcopy = (_d_spline2dcopy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dcopy"), typeof(_d_spline2dcopy));
            _i_ser_spline2dresamplebicubic = (_d_spline2dresamplebicubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dresamplebicubic"), typeof(_d_spline2dresamplebicubic));
            _i_ser_spline2dresamplebilinear = (_d_spline2dresamplebilinear)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dresamplebilinear"), typeof(_d_spline2dresamplebilinear));
            _i_ser_spline2dbuildbilinearv = (_d_spline2dbuildbilinearv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dbuildbilinearv"), typeof(_d_spline2dbuildbilinearv));
            _i_ser_spline2dbuildbicubicv = (_d_spline2dbuildbicubicv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dbuildbicubicv"), typeof(_d_spline2dbuildbicubicv));
            _i_ser_spline2dcalcvbuf = (_d_spline2dcalcvbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dcalcvbuf"), typeof(_d_spline2dcalcvbuf));
            _i_ser_spline2dcalcv = (_d_spline2dcalcv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dcalcv"), typeof(_d_spline2dcalcv));
            _i_ser_spline2dunpackv = (_d_spline2dunpackv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dunpackv"), typeof(_d_spline2dunpackv));
            _i_ser_spline2dbuildbilinear = (_d_spline2dbuildbilinear)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dbuildbilinear"), typeof(_d_spline2dbuildbilinear));
            _i_ser_spline2dbuildbicubic = (_d_spline2dbuildbicubic)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dbuildbicubic"), typeof(_d_spline2dbuildbicubic));
            _i_ser_spline2dunpack = (_d_spline2dunpack)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline2dunpack"), typeof(_d_spline2dunpack));
        _i_x_obj_copy_spline3dinterpolant = (_d_x_obj_copy_spline3dinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_spline3dinterpolant"), typeof(_d_x_obj_copy_spline3dinterpolant));
        _i_x_obj_free_spline3dinterpolant = (_d_x_obj_free_spline3dinterpolant)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_spline3dinterpolant"), typeof(_d_x_obj_free_spline3dinterpolant));
            _i_ser_spline3dcalc = (_d_spline3dcalc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline3dcalc"), typeof(_d_spline3dcalc));
            _i_ser_spline3dlintransxyz = (_d_spline3dlintransxyz)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline3dlintransxyz"), typeof(_d_spline3dlintransxyz));
            _i_ser_spline3dlintransf = (_d_spline3dlintransf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline3dlintransf"), typeof(_d_spline3dlintransf));
            _i_ser_spline3dresampletrilinear = (_d_spline3dresampletrilinear)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline3dresampletrilinear"), typeof(_d_spline3dresampletrilinear));
            _i_ser_spline3dbuildtrilinearv = (_d_spline3dbuildtrilinearv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline3dbuildtrilinearv"), typeof(_d_spline3dbuildtrilinearv));
            _i_ser_spline3dcalcvbuf = (_d_spline3dcalcvbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline3dcalcvbuf"), typeof(_d_spline3dcalcvbuf));
            _i_ser_spline3dcalcv = (_d_spline3dcalcv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline3dcalcv"), typeof(_d_spline3dcalcv));
            _i_ser_spline3dunpackv = (_d_spline3dunpackv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spline3dunpackv"), typeof(_d_spline3dunpackv));
            _i_ser_rmatrixludet = (_d_rmatrixludet)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixludet"), typeof(_d_rmatrixludet));
            _i_ser_rmatrixdet = (_d_rmatrixdet)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixdet"), typeof(_d_rmatrixdet));
            _i_ser_cmatrixludet = (_d_cmatrixludet)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixludet"), typeof(_d_cmatrixludet));
            _i_ser_cmatrixdet = (_d_cmatrixdet)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_cmatrixdet"), typeof(_d_cmatrixdet));
            _i_ser_spdmatrixcholeskydet = (_d_spdmatrixcholeskydet)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixcholeskydet"), typeof(_d_spdmatrixcholeskydet));
            _i_ser_spdmatrixdet = (_d_spdmatrixdet)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spdmatrixdet"), typeof(_d_spdmatrixdet));
            _i_ser_smatrixgevd = (_d_smatrixgevd)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixgevd"), typeof(_d_smatrixgevd));
            _i_ser_smatrixgevdreduce = (_d_smatrixgevdreduce)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_smatrixgevdreduce"), typeof(_d_smatrixgevdreduce));
            _i_ser_rmatrixinvupdatesimple = (_d_rmatrixinvupdatesimple)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixinvupdatesimple"), typeof(_d_rmatrixinvupdatesimple));
            _i_ser_rmatrixinvupdaterow = (_d_rmatrixinvupdaterow)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixinvupdaterow"), typeof(_d_rmatrixinvupdaterow));
            _i_ser_rmatrixinvupdatecolumn = (_d_rmatrixinvupdatecolumn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixinvupdatecolumn"), typeof(_d_rmatrixinvupdatecolumn));
            _i_ser_rmatrixinvupdateuv = (_d_rmatrixinvupdateuv)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixinvupdateuv"), typeof(_d_rmatrixinvupdateuv));
            _i_ser_rmatrixschur = (_d_rmatrixschur)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_rmatrixschur"), typeof(_d_rmatrixschur));
        _i_x_obj_copy_minasastate = (_d_x_obj_copy_minasastate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_minasastate"), typeof(_d_x_obj_copy_minasastate));
        _i_x_obj_free_minasastate = (_d_x_obj_free_minasastate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_minasastate"), typeof(_d_x_obj_free_minasastate));
        _i_x_minasastate_get_needfg = (_d_x_minasastate_get_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minasastate_get_needfg"), typeof(_d_x_minasastate_get_needfg));
        _i_x_minasastate_set_needfg = (_d_x_minasastate_set_needfg)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minasastate_set_needfg"), typeof(_d_x_minasastate_set_needfg));
        _i_x_minasastate_get_xupdated = (_d_x_minasastate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minasastate_get_xupdated"), typeof(_d_x_minasastate_get_xupdated));
        _i_x_minasastate_set_xupdated = (_d_x_minasastate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minasastate_set_xupdated"), typeof(_d_x_minasastate_set_xupdated));
        _i_x_minasastate_get_f = (_d_x_minasastate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minasastate_get_f"), typeof(_d_x_minasastate_get_f));
        _i_x_minasastate_set_f = (_d_x_minasastate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minasastate_set_f"), typeof(_d_x_minasastate_set_f));
        _i_x_minasastate_get_g = (_d_x_minasastate_get_g)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minasastate_get_g"), typeof(_d_x_minasastate_get_g));
        _i_x_minasastate_get_x = (_d_x_minasastate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minasastate_get_x"), typeof(_d_x_minasastate_get_x));
            _i_ser_minlbfgssetdefaultpreconditioner = (_d_minlbfgssetdefaultpreconditioner)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetdefaultpreconditioner"), typeof(_d_minlbfgssetdefaultpreconditioner));
            _i_ser_minlbfgssetcholeskypreconditioner = (_d_minlbfgssetcholeskypreconditioner)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minlbfgssetcholeskypreconditioner"), typeof(_d_minlbfgssetcholeskypreconditioner));
            _i_ser_minbleicsetbarrierwidth = (_d_minbleicsetbarrierwidth)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetbarrierwidth"), typeof(_d_minbleicsetbarrierwidth));
            _i_ser_minbleicsetbarrierdecay = (_d_minbleicsetbarrierdecay)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minbleicsetbarrierdecay"), typeof(_d_minbleicsetbarrierdecay));
            _i_ser_minasacreate = (_d_minasacreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasacreate"), typeof(_d_minasacreate));
            _i_ser_minasasetcond = (_d_minasasetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasasetcond"), typeof(_d_minasasetcond));
            _i_ser_minasasetxrep = (_d_minasasetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasasetxrep"), typeof(_d_minasasetxrep));
            _i_ser_minasasetalgorithm = (_d_minasasetalgorithm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasasetalgorithm"), typeof(_d_minasasetalgorithm));
            _i_ser_minasasetstpmax = (_d_minasasetstpmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasasetstpmax"), typeof(_d_minasasetstpmax));
            _i_ser_minasaiteration = (_d_minasaiteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasaiteration"), typeof(_d_minasaiteration));
            _i_ser_minasaresults = (_d_minasaresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasaresults"), typeof(_d_minasaresults));
            _i_ser_minasaresultsbuf = (_d_minasaresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasaresultsbuf"), typeof(_d_minasaresultsbuf));
            _i_ser_minasarestartfrom = (_d_minasarestartfrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minasarestartfrom"), typeof(_d_minasarestartfrom));
        _i_x_obj_copy_minnlcstate = (_d_x_obj_copy_minnlcstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_minnlcstate"), typeof(_d_x_obj_copy_minnlcstate));
        _i_x_obj_free_minnlcstate = (_d_x_obj_free_minnlcstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_minnlcstate"), typeof(_d_x_obj_free_minnlcstate));
        _i_x_minnlcstate_get_needfi = (_d_x_minnlcstate_get_needfi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_get_needfi"), typeof(_d_x_minnlcstate_get_needfi));
        _i_x_minnlcstate_set_needfi = (_d_x_minnlcstate_set_needfi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_set_needfi"), typeof(_d_x_minnlcstate_set_needfi));
        _i_x_minnlcstate_get_needfij = (_d_x_minnlcstate_get_needfij)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_get_needfij"), typeof(_d_x_minnlcstate_get_needfij));
        _i_x_minnlcstate_set_needfij = (_d_x_minnlcstate_set_needfij)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_set_needfij"), typeof(_d_x_minnlcstate_set_needfij));
        _i_x_minnlcstate_get_xupdated = (_d_x_minnlcstate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_get_xupdated"), typeof(_d_x_minnlcstate_get_xupdated));
        _i_x_minnlcstate_set_xupdated = (_d_x_minnlcstate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_set_xupdated"), typeof(_d_x_minnlcstate_set_xupdated));
        _i_x_minnlcstate_get_f = (_d_x_minnlcstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_get_f"), typeof(_d_x_minnlcstate_get_f));
        _i_x_minnlcstate_set_f = (_d_x_minnlcstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_set_f"), typeof(_d_x_minnlcstate_set_f));
        _i_x_minnlcstate_get_fi = (_d_x_minnlcstate_get_fi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_get_fi"), typeof(_d_x_minnlcstate_get_fi));
        _i_x_minnlcstate_get_j = (_d_x_minnlcstate_get_j)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_get_j"), typeof(_d_x_minnlcstate_get_j));
        _i_x_minnlcstate_get_x = (_d_x_minnlcstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnlcstate_get_x"), typeof(_d_x_minnlcstate_get_x));
            _i_ser_minnlccreate = (_d_minnlccreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlccreate"), typeof(_d_minnlccreate));
            _i_ser_minnlccreatef = (_d_minnlccreatef)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlccreatef"), typeof(_d_minnlccreatef));
            _i_ser_minnlcsetbc = (_d_minnlcsetbc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetbc"), typeof(_d_minnlcsetbc));
            _i_ser_minnlcsetlc = (_d_minnlcsetlc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetlc"), typeof(_d_minnlcsetlc));
            _i_ser_minnlcsetnlc = (_d_minnlcsetnlc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetnlc"), typeof(_d_minnlcsetnlc));
            _i_ser_minnlcsetcond = (_d_minnlcsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetcond"), typeof(_d_minnlcsetcond));
            _i_ser_minnlcsetscale = (_d_minnlcsetscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetscale"), typeof(_d_minnlcsetscale));
            _i_ser_minnlcsetprecinexact = (_d_minnlcsetprecinexact)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetprecinexact"), typeof(_d_minnlcsetprecinexact));
            _i_ser_minnlcsetprecexactlowrank = (_d_minnlcsetprecexactlowrank)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetprecexactlowrank"), typeof(_d_minnlcsetprecexactlowrank));
            _i_ser_minnlcsetprecnone = (_d_minnlcsetprecnone)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetprecnone"), typeof(_d_minnlcsetprecnone));
            _i_ser_minnlcsetalgoaul = (_d_minnlcsetalgoaul)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetalgoaul"), typeof(_d_minnlcsetalgoaul));
            _i_ser_minnlcsetxrep = (_d_minnlcsetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetxrep"), typeof(_d_minnlcsetxrep));
            _i_ser_minnlciteration = (_d_minnlciteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlciteration"), typeof(_d_minnlciteration));
            _i_ser_minnlcresults = (_d_minnlcresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcresults"), typeof(_d_minnlcresults));
            _i_ser_minnlcresultsbuf = (_d_minnlcresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcresultsbuf"), typeof(_d_minnlcresultsbuf));
            _i_ser_minnlcrestartfrom = (_d_minnlcrestartfrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcrestartfrom"), typeof(_d_minnlcrestartfrom));
            _i_ser_minnlcsetgradientcheck = (_d_minnlcsetgradientcheck)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnlcsetgradientcheck"), typeof(_d_minnlcsetgradientcheck));
        _i_x_obj_copy_minnsstate = (_d_x_obj_copy_minnsstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_minnsstate"), typeof(_d_x_obj_copy_minnsstate));
        _i_x_obj_free_minnsstate = (_d_x_obj_free_minnsstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_minnsstate"), typeof(_d_x_obj_free_minnsstate));
        _i_x_minnsstate_get_needfi = (_d_x_minnsstate_get_needfi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_get_needfi"), typeof(_d_x_minnsstate_get_needfi));
        _i_x_minnsstate_set_needfi = (_d_x_minnsstate_set_needfi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_set_needfi"), typeof(_d_x_minnsstate_set_needfi));
        _i_x_minnsstate_get_needfij = (_d_x_minnsstate_get_needfij)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_get_needfij"), typeof(_d_x_minnsstate_get_needfij));
        _i_x_minnsstate_set_needfij = (_d_x_minnsstate_set_needfij)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_set_needfij"), typeof(_d_x_minnsstate_set_needfij));
        _i_x_minnsstate_get_xupdated = (_d_x_minnsstate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_get_xupdated"), typeof(_d_x_minnsstate_get_xupdated));
        _i_x_minnsstate_set_xupdated = (_d_x_minnsstate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_set_xupdated"), typeof(_d_x_minnsstate_set_xupdated));
        _i_x_minnsstate_get_f = (_d_x_minnsstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_get_f"), typeof(_d_x_minnsstate_get_f));
        _i_x_minnsstate_set_f = (_d_x_minnsstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_set_f"), typeof(_d_x_minnsstate_set_f));
        _i_x_minnsstate_get_fi = (_d_x_minnsstate_get_fi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_get_fi"), typeof(_d_x_minnsstate_get_fi));
        _i_x_minnsstate_get_j = (_d_x_minnsstate_get_j)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_get_j"), typeof(_d_x_minnsstate_get_j));
        _i_x_minnsstate_get_x = (_d_x_minnsstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_minnsstate_get_x"), typeof(_d_x_minnsstate_get_x));
            _i_ser_minnscreate = (_d_minnscreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnscreate"), typeof(_d_minnscreate));
            _i_ser_minnscreatef = (_d_minnscreatef)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnscreatef"), typeof(_d_minnscreatef));
            _i_ser_minnssetbc = (_d_minnssetbc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnssetbc"), typeof(_d_minnssetbc));
            _i_ser_minnssetlc = (_d_minnssetlc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnssetlc"), typeof(_d_minnssetlc));
            _i_ser_minnssetnlc = (_d_minnssetnlc)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnssetnlc"), typeof(_d_minnssetnlc));
            _i_ser_minnssetcond = (_d_minnssetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnssetcond"), typeof(_d_minnssetcond));
            _i_ser_minnssetscale = (_d_minnssetscale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnssetscale"), typeof(_d_minnssetscale));
            _i_ser_minnssetalgoags = (_d_minnssetalgoags)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnssetalgoags"), typeof(_d_minnssetalgoags));
            _i_ser_minnssetxrep = (_d_minnssetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnssetxrep"), typeof(_d_minnssetxrep));
            _i_ser_minnsrequesttermination = (_d_minnsrequesttermination)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnsrequesttermination"), typeof(_d_minnsrequesttermination));
            _i_ser_minnsiteration = (_d_minnsiteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnsiteration"), typeof(_d_minnsiteration));
            _i_ser_minnsresults = (_d_minnsresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnsresults"), typeof(_d_minnsresults));
            _i_ser_minnsresultsbuf = (_d_minnsresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnsresultsbuf"), typeof(_d_minnsresultsbuf));
            _i_ser_minnsrestartfrom = (_d_minnsrestartfrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_minnsrestartfrom"), typeof(_d_minnsrestartfrom));
        _i_x_obj_copy_lincgstate = (_d_x_obj_copy_lincgstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_lincgstate"), typeof(_d_x_obj_copy_lincgstate));
        _i_x_obj_free_lincgstate = (_d_x_obj_free_lincgstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_lincgstate"), typeof(_d_x_obj_free_lincgstate));
            _i_ser_lincgcreate = (_d_lincgcreate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgcreate"), typeof(_d_lincgcreate));
            _i_ser_lincgsetstartingpoint = (_d_lincgsetstartingpoint)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgsetstartingpoint"), typeof(_d_lincgsetstartingpoint));
            _i_ser_lincgsetprecunit = (_d_lincgsetprecunit)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgsetprecunit"), typeof(_d_lincgsetprecunit));
            _i_ser_lincgsetprecdiag = (_d_lincgsetprecdiag)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgsetprecdiag"), typeof(_d_lincgsetprecdiag));
            _i_ser_lincgsetcond = (_d_lincgsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgsetcond"), typeof(_d_lincgsetcond));
            _i_ser_lincgsolvesparse = (_d_lincgsolvesparse)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgsolvesparse"), typeof(_d_lincgsolvesparse));
            _i_ser_lincgresults = (_d_lincgresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgresults"), typeof(_d_lincgresults));
            _i_ser_lincgsetrestartfreq = (_d_lincgsetrestartfreq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgsetrestartfreq"), typeof(_d_lincgsetrestartfreq));
            _i_ser_lincgsetrupdatefreq = (_d_lincgsetrupdatefreq)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgsetrupdatefreq"), typeof(_d_lincgsetrupdatefreq));
            _i_ser_lincgsetxrep = (_d_lincgsetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_lincgsetxrep"), typeof(_d_lincgsetxrep));
        _i_x_obj_copy_nleqstate = (_d_x_obj_copy_nleqstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_copy_nleqstate"), typeof(_d_x_obj_copy_nleqstate));
        _i_x_obj_free_nleqstate = (_d_x_obj_free_nleqstate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_obj_free_nleqstate"), typeof(_d_x_obj_free_nleqstate));
        _i_x_nleqstate_get_needf = (_d_x_nleqstate_get_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_get_needf"), typeof(_d_x_nleqstate_get_needf));
        _i_x_nleqstate_set_needf = (_d_x_nleqstate_set_needf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_set_needf"), typeof(_d_x_nleqstate_set_needf));
        _i_x_nleqstate_get_needfij = (_d_x_nleqstate_get_needfij)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_get_needfij"), typeof(_d_x_nleqstate_get_needfij));
        _i_x_nleqstate_set_needfij = (_d_x_nleqstate_set_needfij)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_set_needfij"), typeof(_d_x_nleqstate_set_needfij));
        _i_x_nleqstate_get_xupdated = (_d_x_nleqstate_get_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_get_xupdated"), typeof(_d_x_nleqstate_get_xupdated));
        _i_x_nleqstate_set_xupdated = (_d_x_nleqstate_set_xupdated)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_set_xupdated"), typeof(_d_x_nleqstate_set_xupdated));
        _i_x_nleqstate_get_f = (_d_x_nleqstate_get_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_get_f"), typeof(_d_x_nleqstate_get_f));
        _i_x_nleqstate_set_f = (_d_x_nleqstate_set_f)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_set_f"), typeof(_d_x_nleqstate_set_f));
        _i_x_nleqstate_get_fi = (_d_x_nleqstate_get_fi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_get_fi"), typeof(_d_x_nleqstate_get_fi));
        _i_x_nleqstate_get_j = (_d_x_nleqstate_get_j)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_get_j"), typeof(_d_x_nleqstate_get_j));
        _i_x_nleqstate_get_x = (_d_x_nleqstate_get_x)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "x_nleqstate_get_x"), typeof(_d_x_nleqstate_get_x));
            _i_ser_nleqcreatelm = (_d_nleqcreatelm)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_nleqcreatelm"), typeof(_d_nleqcreatelm));
            _i_ser_nleqsetcond = (_d_nleqsetcond)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_nleqsetcond"), typeof(_d_nleqsetcond));
            _i_ser_nleqsetxrep = (_d_nleqsetxrep)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_nleqsetxrep"), typeof(_d_nleqsetxrep));
            _i_ser_nleqsetstpmax = (_d_nleqsetstpmax)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_nleqsetstpmax"), typeof(_d_nleqsetstpmax));
            _i_ser_nleqiteration = (_d_nleqiteration)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_nleqiteration"), typeof(_d_nleqiteration));
            _i_ser_nleqresults = (_d_nleqresults)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_nleqresults"), typeof(_d_nleqresults));
            _i_ser_nleqresultsbuf = (_d_nleqresultsbuf)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_nleqresultsbuf"), typeof(_d_nleqresultsbuf));
            _i_ser_nleqrestartfrom = (_d_nleqrestartfrom)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_nleqrestartfrom"), typeof(_d_nleqrestartfrom));
            _i_ser_polynomialsolve = (_d_polynomialsolve)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_polynomialsolve"), typeof(_d_polynomialsolve));
            _i_ser_airy = (_d_airy)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_airy"), typeof(_d_airy));
            _i_ser_besselj0 = (_d_besselj0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besselj0"), typeof(_d_besselj0));
            _i_ser_besselj1 = (_d_besselj1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besselj1"), typeof(_d_besselj1));
            _i_ser_besseljn = (_d_besseljn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besseljn"), typeof(_d_besseljn));
            _i_ser_bessely0 = (_d_bessely0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_bessely0"), typeof(_d_bessely0));
            _i_ser_bessely1 = (_d_bessely1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_bessely1"), typeof(_d_bessely1));
            _i_ser_besselyn = (_d_besselyn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besselyn"), typeof(_d_besselyn));
            _i_ser_besseli0 = (_d_besseli0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besseli0"), typeof(_d_besseli0));
            _i_ser_besseli1 = (_d_besseli1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besseli1"), typeof(_d_besseli1));
            _i_ser_besselk0 = (_d_besselk0)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besselk0"), typeof(_d_besselk0));
            _i_ser_besselk1 = (_d_besselk1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besselk1"), typeof(_d_besselk1));
            _i_ser_besselkn = (_d_besselkn)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_besselkn"), typeof(_d_besselkn));
            _i_ser_beta = (_d_beta)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_beta"), typeof(_d_beta));
            _i_ser_incompletebeta = (_d_incompletebeta)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_incompletebeta"), typeof(_d_incompletebeta));
            _i_ser_invincompletebeta = (_d_invincompletebeta)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_invincompletebeta"), typeof(_d_invincompletebeta));
            _i_ser_binomialdistribution = (_d_binomialdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_binomialdistribution"), typeof(_d_binomialdistribution));
            _i_ser_binomialcdistribution = (_d_binomialcdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_binomialcdistribution"), typeof(_d_binomialcdistribution));
            _i_ser_invbinomialdistribution = (_d_invbinomialdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_invbinomialdistribution"), typeof(_d_invbinomialdistribution));
            _i_ser_chebyshevcalculate = (_d_chebyshevcalculate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_chebyshevcalculate"), typeof(_d_chebyshevcalculate));
            _i_ser_chebyshevsum = (_d_chebyshevsum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_chebyshevsum"), typeof(_d_chebyshevsum));
            _i_ser_chebyshevcoefficients = (_d_chebyshevcoefficients)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_chebyshevcoefficients"), typeof(_d_chebyshevcoefficients));
            _i_ser_fromchebyshev = (_d_fromchebyshev)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fromchebyshev"), typeof(_d_fromchebyshev));
            _i_ser_chisquaredistribution = (_d_chisquaredistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_chisquaredistribution"), typeof(_d_chisquaredistribution));
            _i_ser_chisquarecdistribution = (_d_chisquarecdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_chisquarecdistribution"), typeof(_d_chisquarecdistribution));
            _i_ser_invchisquaredistribution = (_d_invchisquaredistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_invchisquaredistribution"), typeof(_d_invchisquaredistribution));
            _i_ser_dawsonintegral = (_d_dawsonintegral)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_dawsonintegral"), typeof(_d_dawsonintegral));
            _i_ser_ellipticintegralk = (_d_ellipticintegralk)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_ellipticintegralk"), typeof(_d_ellipticintegralk));
            _i_ser_ellipticintegralkhighprecision = (_d_ellipticintegralkhighprecision)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_ellipticintegralkhighprecision"), typeof(_d_ellipticintegralkhighprecision));
            _i_ser_incompleteellipticintegralk = (_d_incompleteellipticintegralk)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_incompleteellipticintegralk"), typeof(_d_incompleteellipticintegralk));
            _i_ser_ellipticintegrale = (_d_ellipticintegrale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_ellipticintegrale"), typeof(_d_ellipticintegrale));
            _i_ser_incompleteellipticintegrale = (_d_incompleteellipticintegrale)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_incompleteellipticintegrale"), typeof(_d_incompleteellipticintegrale));
            _i_ser_exponentialintegralei = (_d_exponentialintegralei)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_exponentialintegralei"), typeof(_d_exponentialintegralei));
            _i_ser_exponentialintegralen = (_d_exponentialintegralen)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_exponentialintegralen"), typeof(_d_exponentialintegralen));
            _i_ser_fdistribution = (_d_fdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fdistribution"), typeof(_d_fdistribution));
            _i_ser_fcdistribution = (_d_fcdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fcdistribution"), typeof(_d_fcdistribution));
            _i_ser_invfdistribution = (_d_invfdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_invfdistribution"), typeof(_d_invfdistribution));
            _i_ser_fresnelintegral = (_d_fresnelintegral)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_fresnelintegral"), typeof(_d_fresnelintegral));
            _i_ser_hermitecalculate = (_d_hermitecalculate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hermitecalculate"), typeof(_d_hermitecalculate));
            _i_ser_hermitesum = (_d_hermitesum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hermitesum"), typeof(_d_hermitesum));
            _i_ser_hermitecoefficients = (_d_hermitecoefficients)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hermitecoefficients"), typeof(_d_hermitecoefficients));
            _i_ser_jacobianellipticfunctions = (_d_jacobianellipticfunctions)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_jacobianellipticfunctions"), typeof(_d_jacobianellipticfunctions));
            _i_ser_laguerrecalculate = (_d_laguerrecalculate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_laguerrecalculate"), typeof(_d_laguerrecalculate));
            _i_ser_laguerresum = (_d_laguerresum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_laguerresum"), typeof(_d_laguerresum));
            _i_ser_laguerrecoefficients = (_d_laguerrecoefficients)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_laguerrecoefficients"), typeof(_d_laguerrecoefficients));
            _i_ser_legendrecalculate = (_d_legendrecalculate)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_legendrecalculate"), typeof(_d_legendrecalculate));
            _i_ser_legendresum = (_d_legendresum)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_legendresum"), typeof(_d_legendresum));
            _i_ser_legendrecoefficients = (_d_legendrecoefficients)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_legendrecoefficients"), typeof(_d_legendrecoefficients));
            _i_ser_poissondistribution = (_d_poissondistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_poissondistribution"), typeof(_d_poissondistribution));
            _i_ser_poissoncdistribution = (_d_poissoncdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_poissoncdistribution"), typeof(_d_poissoncdistribution));
            _i_ser_invpoissondistribution = (_d_invpoissondistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_invpoissondistribution"), typeof(_d_invpoissondistribution));
            _i_ser_psi = (_d_psi)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_psi"), typeof(_d_psi));
            _i_ser_studenttdistribution = (_d_studenttdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_studenttdistribution"), typeof(_d_studenttdistribution));
            _i_ser_invstudenttdistribution = (_d_invstudenttdistribution)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_invstudenttdistribution"), typeof(_d_invstudenttdistribution));
            _i_ser_sinecosineintegrals = (_d_sinecosineintegrals)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_sinecosineintegrals"), typeof(_d_sinecosineintegrals));
            _i_ser_hyperbolicsinecosineintegrals = (_d_hyperbolicsinecosineintegrals)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_hyperbolicsinecosineintegrals"), typeof(_d_hyperbolicsinecosineintegrals));
            _i_ser_pearsoncorrelationsignificance = (_d_pearsoncorrelationsignificance)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_pearsoncorrelationsignificance"), typeof(_d_pearsoncorrelationsignificance));
            _i_ser_spearmanrankcorrelationsignificance = (_d_spearmanrankcorrelationsignificance)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_spearmanrankcorrelationsignificance"), typeof(_d_spearmanrankcorrelationsignificance));
            _i_ser_jarqueberatest = (_d_jarqueberatest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_jarqueberatest"), typeof(_d_jarqueberatest));
            _i_ser_mannwhitneyutest = (_d_mannwhitneyutest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_mannwhitneyutest"), typeof(_d_mannwhitneyutest));
            _i_ser_onesamplesigntest = (_d_onesamplesigntest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_onesamplesigntest"), typeof(_d_onesamplesigntest));
            _i_ser_studentttest1 = (_d_studentttest1)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_studentttest1"), typeof(_d_studentttest1));
            _i_ser_studentttest2 = (_d_studentttest2)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_studentttest2"), typeof(_d_studentttest2));
            _i_ser_unequalvariancettest = (_d_unequalvariancettest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_unequalvariancettest"), typeof(_d_unequalvariancettest));
            _i_ser_ftest = (_d_ftest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_ftest"), typeof(_d_ftest));
            _i_ser_onesamplevariancetest = (_d_onesamplevariancetest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_onesamplevariancetest"), typeof(_d_onesamplevariancetest));
            _i_ser_wilcoxonsignedranktest = (_d_wilcoxonsignedranktest)Marshal.GetDelegateForFunctionPointer(DynamicAddr(hTmpDL, "alglib_wilcoxonsignedranktest"), typeof(_d_wilcoxonsignedranktest));

    }
    
}
